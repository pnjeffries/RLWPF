<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Nucleus</name>
    </assembly>
    <members>
        <member name="T:Nucleus.Actions.ActionAttribute">
            <summary>
            Attribute c
            </summary>
        </member>
        <member name="P:Nucleus.Actions.ActionAttribute.CommandName">
            <summary>
            The command string used to manually call this action
            </summary>
        </member>
        <member name="P:Nucleus.Actions.ActionAttribute.Description">
            <summary>
            The description of this command
            </summary>
        </member>
        <member name="P:Nucleus.Actions.ActionAttribute.IconForeground">
            <summary>
            The URI string that identifies the image resource to be used as the foreground of the icon for this action 
            on buttons and grasshopper components.
            </summary>
        </member>
        <member name="P:Nucleus.Actions.ActionAttribute.IconBackground">
            <summary>
            The URI string that identifies the image resource to be used as the background of the icon for this action
            on button and grasshopper components.
            </summary>
        </member>
        <member name="P:Nucleus.Actions.ActionAttribute.PreviewLayerType">
            <summary>
            The type of the preview layer (if any) to be used to display the results of this operation.
            </summary>
        </member>
        <member name="M:Nucleus.Actions.ActionAttribute.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="commandName"></param>
        </member>
        <member name="M:Nucleus.Actions.ActionAttribute.#ctor(System.String,System.String)">
            <summary>
            CommandName, Description constructor
            </summary>
            <param name="commandName"></param>
            <param name="description"></param>
        </member>
        <member name="M:Nucleus.Actions.ActionAttribute.#ctor(System.String,System.String,System.String)">
            <summary>
            CommandName, Description, Icon constructor
            </summary>
            <param name="commandName"></param>
            <param name="description"></param>
            <param name="iconBackground"></param>
        </member>
        <member name="M:Nucleus.Actions.ActionAttribute.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            CommandName, Description, Icon (2-layer) constructor
            </summary>
            <param name="commandName"></param>
            <param name="description"></param>
            <param name="iconBackground"></param>
            <param name="iconForeground"></param>
        </member>
        <member name="M:Nucleus.Actions.ActionAttribute.ExtractFrom(System.Type)">
            <summary>
            Helper function to get the (first) ActionAttribute from the specified type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Actions.ActionAttribute.ExtractFrom(Nucleus.Actions.IAction)">
            <summary>
            Helper function to get the action attributes from an action
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Actions.ActionInputAttribute">
            <summary>
            Attributes of an action input parameter property.
            Used to specify information about the input and how it should be obtained/used.
            </summary>
        </member>
        <member name="P:Nucleus.Actions.ActionInputAttribute.Manual">
            <summary>
            If true, the input will be prompted for as an input when this action is run as a manual command.
            Default = true
            </summary>
        </member>
        <member name="P:Nucleus.Actions.ActionInputAttribute.Parametric">
            <summary>
            If true, the input will be made available as an input when this action is used as a parametric component.
            Default = true
            </summary>
        </member>
        <member name="P:Nucleus.Actions.ActionInputAttribute.Required">
            <summary>
            If true, this input *must* be set to a non-null value or the command will not be executed.
            Default = true
            </summary>
        </member>
        <member name="P:Nucleus.Actions.ActionInputAttribute.Persistant">
            <summary>
            If true, the value specified for this input will be re-used as the default value the next time the command is run.
            Default = false
            </summary>
        </member>
        <member name="P:Nucleus.Actions.ActionInputAttribute.Import">
            <summary>
            If true (and the data is of an importable type) the data is to be loaded from an external file rather than selected from the current document
            An import dialog of the appropriate type will be displayed
            Default = false
            </summary>
        </member>
        <member name="P:Nucleus.Actions.ActionInputAttribute.Dialog">
            <summary>
            If true, this input will be set via an auto-generated options dialog
            Default = false
            </summary>
        </member>
        <member name="P:Nucleus.Actions.ActionInputAttribute.OneByOne">
            <summary>
            Only applies to collection types when being wrapped inside a paramatric component.
            If true (default) objects in this collection will be processed one at a time and
            the action executed once for each item individually.
            </summary>
        </member>
        <member name="P:Nucleus.Actions.ActionInputAttribute.SuggestionsPath">
            <summary>
            The path of the property on the action which will supply a list of suggested values for
            the user to choose from.  Used to enable text input with selection from a set of options.
            </summary>
        </member>
        <member name="M:Nucleus.Actions.ActionInputAttribute.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Nucleus.Actions.ActionInputAttribute.#ctor(System.Int32,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="order"></param>
            <param name="description"></param>
        </member>
        <member name="M:Nucleus.Actions.ActionInputAttribute.ExtractFrom(System.Reflection.PropertyInfo)">
            <summary>
            Helper function to get the (first) ActionInput attribute from the specified PropertyInfo
            </summary>
            <param name="pInfo"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Actions.ActionParameterAttribute">
            <summary>
            Base class for Action Parameter attributes.  Used to annotate action input and output
            properties in order to define more information about how they should be used.
            </summary>
        </member>
        <member name="P:Nucleus.Actions.ActionParameterAttribute.Order">
            <summary>
            Weighting value for the display order.  Parameters will be sorted by this value.
            Lower values will be displayed first.
            </summary>
        </member>
        <member name="P:Nucleus.Actions.ActionParameterAttribute.ShortName">
            <summary>
            The abbreviated version of this property name to be displayed in limited-space situations
            such as grasshopper inputs and outputs.  If not explicitly set, the short name will usually
            be generated automatically from the property name itself.
            </summary>
        </member>
        <member name="P:Nucleus.Actions.ActionParameterAttribute.Description">
            <summary>
            The description of this parameter.  This may be displayed as a tooltip or a prompt.
            In the latter case, this string may be prefixed with 'Enter ' - therefore do not capitalise the
            first letter of this description unless it should always be capitalised (i.e. it is a noun).
            In cases where there is no prefix, the first letter will be automatically capitalised.
            </summary>
        </member>
        <member name="P:Nucleus.Actions.ActionParameterAttribute.CapitalisedDescription">
            <summary>
            A version of the Description property with the first character capitalised
            </summary>
        </member>
        <member name="T:Nucleus.Actions.ExecutionInfo">
            <summary>
            A class which contains information about the context in which an action has been executed.
            This is used during object history storage to determine the object's creation circumstances
            and can be used to update that object in future.
            </summary>
        </member>
        <member name="F:Nucleus.Actions.ExecutionInfo._ExecutionID">
            <summary>
            Private backing field for ExecutionID property
            </summary>
        </member>
        <member name="P:Nucleus.Actions.ExecutionInfo.ExecutionID">
            <summary>
            The unique identifier of this particular execution.
            This will be different each time and can be used to tell execution runs apart.
            </summary>
        </member>
        <member name="F:Nucleus.Actions.ExecutionInfo._SourceReference">
            <summary>
            Private backing field for SourceReference property
            </summary>
        </member>
        <member name="P:Nucleus.Actions.ExecutionInfo.SourceReference">
            <summary>
            The reference string used to identify the source of execution of an action,
            used to update previously created output instead of generating it afresh when used
            as part of a parametric process.
            For example, this may be the GUID of the calling grasshopper component.
            Defaults to null when the source is not parametric (i.e. when called manually).
            </summary>
        </member>
        <member name="F:Nucleus.Actions.ExecutionInfo._Iteration">
            <summary>
            Private backing field for Iteration property
            </summary>
        </member>
        <member name="P:Nucleus.Actions.ExecutionInfo.Iteration">
            <summary>
            The iteration number of this execution.  This will increment when the same source calls
            this action multiple times during the same update cycle - for example when a list of inputs
            is plugged into a Grasshopper component.
            </summary>
        </member>
        <member name="F:Nucleus.Actions.ExecutionInfo._HistoryItemCount">
            <summary>
            Private backing field for HistoryItemCount property
            </summary>
        </member>
        <member name="P:Nucleus.Actions.ExecutionInfo.HistoryItemCount">
            <summary>
            The number of history-tracked items that have been created or updated during this execution.
            This will be incremented automatically by the source history manager 
            </summary>
        </member>
        <member name="M:Nucleus.Actions.ExecutionInfo.#ctor">
            <summary>
            Default constructor for manual execution
            </summary>
        </member>
        <member name="M:Nucleus.Actions.ExecutionInfo.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Constructor from parametric source
            </summary>
            <param name="sourceReference"></param>
            <param name="interation"></param>
        </member>
        <member name="T:Nucleus.Actions.IAction">
            <summary>
            An interface which must be implemented by any class which represents an action.
            You can implement this interface entirely yourself, but probably it is better simply to inherit from
            an appropriate base class (ActionBase, DocumentActionBase etc.), which will provide a lot of the basic functionality
            for you.
            </summary>
        </member>
        <member name="M:Nucleus.Actions.IAction.Execute(Nucleus.Actions.ExecutionInfo)">
            <summary>
            Execute this action.  Input parameters will be consumed and output parameters will be populated.
            </summary>
            <param name="exInfo">A set of data communicating the parametric context of execution.
            Used to update existing outputs from the same parametric source instead of generating new ones.
            Will be null if the source is not part of a parametric process.</param>
            <returns>Should return true if the action is successfully completed, false otherwise</returns>
        </member>
        <member name="M:Nucleus.Actions.IAction.PreExecutionOperations(Nucleus.Actions.ExecutionInfo)">
            <summary>
            A function which will be called before the action is executed in normal execution mode.
            </summary>
            <returns>True if execution can be allowed to proceed</returns>
        </member>
        <member name="M:Nucleus.Actions.IAction.PostExecutionOperations(Nucleus.Actions.ExecutionInfo)">
            <summary>
            A function which will be called after the action has been executed in normal execution mode.
            Override to define specific behaviours - typically to consume the outputs of the execution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Actions.IAction.FinalOperations(Nucleus.Actions.ExecutionInfo)">
            <summary>
            A function which will be called on the last action to be executed in a sequence, after any
            PostExecutionOperations have been performed.  For example, in a Grasshopper component dealing 
            with multiple inputs, this will only be called once all inputs have been dealt with.
            Use this to define any tidying up operations that should be performed after the final iteration.
            </summary>
            <param name="exInfo"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Actions.IAction.InputParameters">
            <summary>
            Return a list of the PropertyInfo objects for all input parameters of this action.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Actions.IAction.OutputParameters">
            <summary>
            Return a list of the PropertyInfo objects for all output parameters of this action.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Actions.IAction.PromptUserForInputs(System.Boolean)">
            <summary>
            Use the current input manager to prompt the user for all necessary inputs to this action
            </summary>
            <returns>True if all inputs successful, false if user cancels</returns>
        </member>
        <member name="T:Nucleus.Actions.IActionExtensions">
            <summary>
            Extension methods for the IAction interface
            </summary>
        </member>
        <member name="M:Nucleus.Actions.IActionExtensions.GetAttributes(Nucleus.Actions.IAction)">
            <summary>
            Retrieve the action attributes for this action
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Actions.IActionExtensions.GetCommandName(Nucleus.Actions.IAction)">
            <summary>
            Retrieve the command name for this action
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Actions.IActionExtensions.CopyPersistentValuesFrom(Nucleus.Actions.IAction,Nucleus.Actions.IAction)">
            <summary>
            Copy across persistent input parameter values from another action of the same type
            </summary>
            <param name="action"></param>
            <param name="other"></param>
        </member>
        <member name="M:Nucleus.Actions.IActionExtensions.GetOutputsDictionary(Nucleus.Actions.IAction)">
            <summary>
            Generate a dictionary of the current output property values, keyed by their names
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Actions.IContextualAction">
            <summary>
            An interface for Salamander actions which can automatically extract input data from a 'context' object.
            Typically, this is used for actions linked to embedded buttons in WPF controls, where the passed in context object
            will be the DataContext property of the control.
            </summary>
        </member>
        <member name="M:Nucleus.Actions.IContextualAction.PopulateInputsFromContext(System.Object)">
            <summary>
            This function is to be used to extract any relevant inputs from a 'context' object.
            Extracting the data from the context and populating the input properties is down to you.
            </summary>
            <param name="context">The object which describes the context of the action.
            For example, if called from a WPF button this might be the datacontext of that
            control.</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Actions.IExportAction">
            <summary>
            An interface for Salamander actions which provide file export functionality.
            You can implement this interface yourself, but it's probably better to inherit from ExportActionBase,
            which will provide the basic implementation for you.
            </summary>
        </member>
        <member name="P:Nucleus.Actions.IExportAction.FilePath">
            <summary>
            The filepath that is to be written to
            </summary>
        </member>
        <member name="P:Nucleus.Actions.IExportAction.Document">
            <summary>
            The document to be written to a file
            </summary>
        </member>
        <member name="T:Nucleus.Actions.PreviewParameters">
            <summary>
            A set of parameters used when generating geometry to be displayed
            during a dynamic preview
            </summary>
        </member>
        <member name="P:Nucleus.Actions.PreviewParameters.IsDynamic">
            <summary>
            Is this a dynamic preview (as during point selection)?
            </summary>
        </member>
        <member name="P:Nucleus.Actions.PreviewParameters.Input">
            <summary>
            The input property currently being modified
            </summary>
        </member>
        <member name="P:Nucleus.Actions.PreviewParameters.SelectionPoints">
            <summary>
            The current set of selection points
            </summary>
        </member>
        <member name="M:Nucleus.Actions.PreviewParameters.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Actions.PreviewParameters.#ctor(System.Boolean,System.Reflection.PropertyInfo,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Initialises a new set of Preview Parameters
            </summary>
            <param name="isDynamic"></param>
            <param name="input"></param>
            <param name="cursorPoint"></param>
            <param name="basePoint"></param>
        </member>
        <member name="M:Nucleus.Actions.PreviewParameters.#ctor(System.Boolean,System.Reflection.PropertyInfo,System.Collections.Generic.IList{Nucleus.Geometry.Vector})">
            <summary>
            Initialises a new set of Preview Parameters
            </summary>
            <param name="isDynamic"></param>
            <param name="input"></param>
            <param name="selectionPoints"></param>
        </member>
        <member name="T:Nucleus.AI.Network">
            <summary>
            An Artificial Neural Network consisting of several layers of neurons
            </summary>
        </member>
        <member name="T:Nucleus.AI.Neuron">
            <summary>
            A neuron in an ANN
            </summary>
        </member>
        <member name="F:Nucleus.AI.Neuron._Weights">
            <summary>
            Private backing member variable for the Weights property
            </summary>
        </member>
        <member name="P:Nucleus.AI.Neuron.Weights">
            <summary>
            The indexed list of weightings for neurons in the preceeding layer
            </summary>
        </member>
        <member name="M:Nucleus.AI.Neuron.Initialise(System.Int32)">
            <summary>
            Private initialisation function
            </summary>
            <param name="prevLayerSize"></param>
        </member>
        <member name="T:Nucleus.Alerts.AlertCollection">
            <summary>
            A collection of alerts
            </summary>
        </member>
        <member name="M:Nucleus.Alerts.AlertCollection.AddOrMerge(Nucleus.Alerts.Alert)">
            <summary>
            Add an alert to this collection if it is unique, or merge
            it with an existing alert if one exists in this collection
            already with the same AlertID
            </summary>
            <param name="alert"></param>
        </member>
        <member name="M:Nucleus.Alerts.AlertCollection.HighestLevel">
            <summary>
            Get the highest level of an alert in this collection
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Alerts.AlertLevel">
            <summary>
            Enumerated value to represent different levels of alerts
            </summary>
        </member>
        <member name="F:Nucleus.Alerts.AlertLevel.Information">
            <summary>
            The alert relays information
            </summary>
        </member>
        <member name="F:Nucleus.Alerts.AlertLevel.Warning">
            <summary>
            The alert is a warning drawing attention to a potential problem
            in the process but which does not necessarily invalidate the results
            </summary>
        </member>
        <member name="F:Nucleus.Alerts.AlertLevel.Error">
            <summary>
            The alert draws attention to a major problem which may need
            the process to be halted.
            </summary>
        </member>
        <member name="F:Nucleus.Alerts.AlertLevel.Pass">
            <summary>
            The alert indicates a condition has been passed
            </summary>
        </member>
        <member name="F:Nucleus.Alerts.AlertLevel.Fail">
            <summary>
            The alert indicates that a condition has been failed
            </summary>
        </member>
        <member name="T:Nucleus.Alerts.AlertLog">
            <summary>
            A log to store alerts raised during a process
            </summary>
        </member>
        <member name="M:Nucleus.Alerts.AlertLog.RaiseAlert(Nucleus.Alerts.Alert)">
            <summary>
            Raise an alert
            </summary>
            <param name="alert">The alert to add to the log</param>
        </member>
        <member name="M:Nucleus.Alerts.AlertLog.RaiseAlert(System.String,Nucleus.Alerts.AlertLevel)">
            <summary>
            Raise a unique alert
            </summary>
            <param name="message">The message to display</param>
            <param name="level">The level of the alert</param>
        </member>
        <member name="M:Nucleus.Alerts.AlertLog.RaiseAlert(System.String,System.String,Nucleus.Alerts.AlertLevel)">
            <summary>
            Raise an alert, merging it with any previous alerts with the same ID
            </summary>
            <param name="alertID">The identifier for the alert type.  Multiple alerts with the same ID will be merged.</param>
            <param name="message">The message to display</param>
            <param name="level">The level of the alert</param>
        </member>
        <member name="M:Nucleus.Alerts.AlertLog.RaiseAlert(System.String,System.String,System.Double,Nucleus.Alerts.AlertLevel)">
            <summary>
            Raise a progress alert, merging it with any previous alerts with the same ID
            </summary>
            <param name="alertID">The identifier for the alert type.  Multiple alerts with the same ID will be merged.</param>
            <param name="message">The message to display</param>
            <param name="progress">The progress of the operation</param>
            <param name="level">The level of the alert</param>
        </member>
        <member name="M:Nucleus.Alerts.AlertLog.RaiseAlert(System.String,Nucleus.Model.Element,System.String,Nucleus.Alerts.AlertLevel)">
            <summary>
            Raise an alert regarding an Element, merging it with any previous alerts with the same ID
            </summary>
            <param name="alertID">The identifier for the alert type.  Multiple alerts with the same ID will be merged.</param>
            <param name="element">The element to which the alert refers.</param>
            <param name="message">The message to display.</param>
            <param name="level">The level of the alert.</param>
        </member>
        <member name="M:Nucleus.Alerts.AlertLog.RaiseAlert(System.String,Nucleus.Model.Node,System.String,Nucleus.Alerts.AlertLevel)">
            <summary>
            Raise an alert regarding a Node, merging it with any previous alerts with the same ID
            </summary>
            <param name="alertID">The identifier for the alert type.  Multiple alerts with the same ID will be merged.</param>
            <param name="node">The node to which the alert refers.</param>
            <param name="message">The message to display.</param>
            <param name="level">The level of the alert.</param>
        </member>
        <member name="M:Nucleus.Alerts.AlertLog.RaiseAlert(System.String,Nucleus.Model.Loading.Load,System.String,Nucleus.Alerts.AlertLevel)">
            <summary>
            Raise an alert regarding a Load, merging it with any previous alerts with the same ID
            </summary>
            <param name="alertID">The identifier for the alert type.  Multiple alerts with the same ID will be merged.</param>
            <param name="load">The element to which the alert refers.</param>
            <param name="message">The message to display.</param>
            <param name="level">The level of the alert.</param>
        </member>
        <member name="M:Nucleus.Alerts.AlertLog.Nucleus#Logs#ILog#WriteText(System.String)">
            <summary>
            ILog WriteText implementation
            </summary>
            <param name="text"></param>
        </member>
        <member name="T:Nucleus.Alerts.ElementAlert">
            <summary>
            An alert relating to one or more elements
            </summary>
        </member>
        <member name="T:Nucleus.Alerts.LoadAlert">
            <summary>
            An alert relating to one of many Loads
            </summary>
        </member>
        <member name="T:Nucleus.Alerts.ModelObjectAlert`2">
            <summary>
            Base class for alerts which refer to model objects of a particular type
            </summary>
            <typeparam name="TItem">The type of item to which this alert refers</typeparam>
            <typeparam name="TCollection">The collection which holds the specifed type</typeparam>
        </member>
        <member name="F:Nucleus.Alerts.ModelObjectAlert`2._Items">
            <summary>
            Private backing member variable for the Items property
            </summary>
        </member>
        <member name="P:Nucleus.Alerts.ModelObjectAlert`2.Items">
            <summary>
            The collection of items to which this alert refers
            </summary>
        </member>
        <member name="P:Nucleus.Alerts.ModelObjectAlert`2.TypeName">
            <summary>
            The name of the type of object this alert refers to
            </summary>
        </member>
        <member name="P:Nucleus.Alerts.ModelObjectAlert`2.DisplayText">
            <summary>
            The text which is displayed in the UI to describe this alert
            to the user.  By default consists of the set Message, but may
            be overridden to allow composite messages to be displayed.
            </summary>
        </member>
        <member name="M:Nucleus.Alerts.ModelObjectAlert`2.#ctor(System.String,`0,System.String,Nucleus.Alerts.AlertLevel)">
            <summary>
            Initialise a new generic alert with the specified ID and message
            </summary>
            <param name="alertID">The ID of the alert.  Multiple alerts raised with the same ID may be merged.</param>
            <param name="message">The alert message to display.</param>
            <param name="level">The alert level of the message - indicates how serious the alert is.</param>
        </member>
        <member name="M:Nucleus.Alerts.ModelObjectAlert`2.#ctor(System.String,`0,Nucleus.Alerts.AlertLevel)">
            <summary>
            Initialise a new generic alert with the specified message
            </summary>
            <param name="message">The alert message to display.</param>
            <param name="level">The alert level of the message - indicates how serious the alert is.</param>
        </member>
        <member name="M:Nucleus.Alerts.ModelObjectAlert`2.#ctor(System.String,System.Collections.Generic.IList{`0},System.String,Nucleus.Alerts.AlertLevel)">
            <summary>
            Initialise a new generic alert with the specified ID and message
            </summary>
            <param name="alertID">The ID of the alert.  Multiple alerts raised with the same ID may be merged.</param>
            <param name="message">The alert message to display.</param>
            <param name="level">The alert level of the message - indicates how serious the alert is.</param>
        </member>
        <member name="M:Nucleus.Alerts.ModelObjectAlert`2.#ctor(System.String,System.Collections.Generic.IList{`0},Nucleus.Alerts.AlertLevel)">
            <summary>
            Initialise a new generic alert with the specified message
            </summary>
            <param name="message">The alert message to display.</param>
            <param name="level">The alert level of the message - indicates how serious the alert is.</param>
        </member>
        <member name="M:Nucleus.Alerts.ModelObjectAlert`2.Merge(Nucleus.Alerts.Alert)">
            <summary>
            Merge another alert into this one.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Alerts.NodeAlert">
            <summary>
            An alert relating to one or more Nodes
            </summary>
        </member>
        <member name="T:Nucleus.Alerts.ProgressAlert">
            <summary>
            An alert which reports on the overall progress of an operation
            </summary>
        </member>
        <member name="F:Nucleus.Alerts.ProgressAlert._Progress">
            <summary>
            Private backing field for Progress property
            </summary>
        </member>
        <member name="P:Nucleus.Alerts.ProgressAlert.Progress">
            <summary>
            The progress being reported - typically expressed
            from 0-1.
            </summary>
        </member>
        <member name="T:Nucleus.Alerts.Alert">
            <summary>
            Class to store warning messages which are liable to crop
            up multiple times over the course of a process and which
            may need to be collated and displayed together
            </summary>
        </member>
        <member name="F:Nucleus.Alerts.Alert._AlertID">
            <summary>
            Private backing member variable for the AlertID property
            </summary>
        </member>
        <member name="P:Nucleus.Alerts.Alert.AlertID">
            <summary>
            The ID of the alert type - multiple alerts with the same ID will be merged together
            </summary>
        </member>
        <member name="F:Nucleus.Alerts.Alert._Message">
            <summary>
            Private backing member variable for the Message property
            </summary>
        </member>
        <member name="P:Nucleus.Alerts.Alert.Message">
            <summary>
            A customisable message which will be shown as part of this alert
            </summary>
        </member>
        <member name="P:Nucleus.Alerts.Alert.DisplayText">
            <summary>
            The text which is displayed in the UI to describe this alert
            to the user.  By default consists of the set Message, but may
            be overridden to allow composite messages to be displayed.
            </summary>
        </member>
        <member name="F:Nucleus.Alerts.Alert._Level">
            <summary>
            Private backing member variable for the Level property
            </summary>
        </member>
        <member name="P:Nucleus.Alerts.Alert.Level">
            <summary>
            The level of the alert - used to indicate the degree of seriousness of the message.
            </summary>
        </member>
        <member name="M:Nucleus.Alerts.Alert.#ctor(System.String,System.String,Nucleus.Alerts.AlertLevel)">
            <summary>
            Initialise a new generic alert with the specified ID and message
            </summary>
            <param name="alertID">The ID of the alert.  Multiple alerts raised with the same ID may be merged.</param>
            <param name="message">The alert message to display.</param>
            <param name="level">The alert level of the message - indicates how serious the alert is.</param>
        </member>
        <member name="M:Nucleus.Alerts.Alert.#ctor(System.String,Nucleus.Alerts.AlertLevel)">
            <summary>
            Initialise a new generic alert with the specified message
            </summary>
            <param name="message">The alert message to display.</param>
            <param name="level">The alert level of the message - indicates how serious the alert is.</param>
        </member>
        <member name="M:Nucleus.Alerts.Alert.Merge(Nucleus.Alerts.Alert)">
            <summary>
            Merge another alert into this one.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Analysis.BeamAnalysisBase">
            <summary>
            Abstract base class for beam analysis
            </summary>
        </member>
        <member name="P:Nucleus.Analysis.BeamAnalysisBase.Span">
            <summary>
            The overall span of the member (m)
            </summary>
        </member>
        <member name="P:Nucleus.Analysis.BeamAnalysisBase.UDL">
            <summary>
            The uniformly distributed load along the beam (N/m)
            </summary>
        </member>
        <member name="P:Nucleus.Analysis.BeamAnalysisBase.E">
            <summary>
            The Young's Modulus of the beam in N/m²
            </summary>
        </member>
        <member name="P:Nucleus.Analysis.BeamAnalysisBase.I">
            <summary>
            The second moment of area of the beam about the major axis in m^4
            </summary>
        </member>
        <member name="T:Nucleus.Analysis.EC3MemberChecks">
            <summary>
            Steel member design checks to Eurocode 3 
            </summary>
        </member>
        <member name="F:Nucleus.Analysis.EC3MemberChecks._Section">
            <summary>
            Private backing member variable for the Section property
            </summary>
        </member>
        <member name="P:Nucleus.Analysis.EC3MemberChecks.Section">
            <summary>
            The cross-section of the member
            </summary>
        </member>
        <member name="M:Nucleus.Analysis.EC3MemberChecks.GrossArea">
            <summary>
            Calculate the gross area of the section
            According to EC3 6.2.2.1
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.EC3MemberChecks.NetArea">
            <summary>
            Calculate the net area of the section
            According to EC3 6.2.2.2
            </summary>
            <returns></returns>
        </member>
        <member name="F:Nucleus.Analysis.FlatConcreteSlabChecks._CylinderStrength">
            <summary>
            Private backing member variable for the CylinderStrength property
            </summary>
        </member>
        <member name="P:Nucleus.Analysis.FlatConcreteSlabChecks.CylinderStrength">
            <summary>
            The concrete cylinder strength, in MPa
            </summary>
        </member>
        <member name="M:Nucleus.Analysis.FlatConcreteSlabChecks.CalculateK(System.Double,System.Double,System.Double,System.Double,Nucleus.Logs.ICalculationLog)">
            <summary>
            Calculate value of K
            </summary>
            <param name="M">The design moments, in Nm</param>
            <param name="b">The bredth of section, in m</param>
            <param name="d">The depth of section, in m</param>
            <param name="fck">The cylinder strength of the concrete, in MPa</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Analysis.SolarPositioning">
            <summary>
            Static helper class implementing the Solar Positioning Algorithm.
            Used to calculate the position of the sun at a given date and time.
            Based on http://www.nrel.gov/docs/fy08osti/34302.pdf
            </summary>
        </member>
        <member name="F:Nucleus.Analysis.SolarPositioning.L0Table">
            <summary>
            The subset of Table A4.2 used to calculate the L0 component
            </summary>
        </member>
        <member name="F:Nucleus.Analysis.SolarPositioning.L1Table">
            <summary>
            The subset of Table A4.2 used to calculate the L1 component
            </summary>
        </member>
        <member name="F:Nucleus.Analysis.SolarPositioning.L2Table">
            <summary>
            The subset of Table A4.2 used to calculate the L2 component
            </summary>
        </member>
        <member name="F:Nucleus.Analysis.SolarPositioning.L3Table">
            <summary>
            The subset of Table A4.2 used to calculate the L3 component
            </summary>
        </member>
        <member name="F:Nucleus.Analysis.SolarPositioning.L4Table">
            <summary>
            The subset of table A4.2 used to calculate the L4 component
            </summary>
        </member>
        <member name="F:Nucleus.Analysis.SolarPositioning.L5Table">
            <summary>
            The subset of table A4.2 used to calculate the L5 component
            </summary>
        </member>
        <member name="F:Nucleus.Analysis.SolarPositioning.B0Table">
            <summary>
            The subset of table A4.2 used to calculate the B0 component
            </summary>
        </member>
        <member name="F:Nucleus.Analysis.SolarPositioning.B1Table">
            <summary>
            The subset of table A4.2 used to calculate the B1 component
            </summary>
        </member>
        <member name="F:Nucleus.Analysis.SolarPositioning.R0Table">
            <summary>
            The subset of table A4.2 used to calculate the R0 component
            </summary>
        </member>
        <member name="F:Nucleus.Analysis.SolarPositioning.R1Table">
            <summary>
            The subset of table A4.2 used to calculate the R1 component
            </summary>
        </member>
        <member name="F:Nucleus.Analysis.SolarPositioning.R2Table">
            <summary>
            The subset of table A4.2 used to calculate the R2 component
            </summary>
        </member>
        <member name="F:Nucleus.Analysis.SolarPositioning.R3Table">
            <summary>
            The subset of table A4.2 used to calculate the R3 component
            </summary>
        </member>
        <member name="F:Nucleus.Analysis.SolarPositioning.R4Table">
            <summary>
            The subset of table A4.2 used to calculate the R3 component
            </summary>
        </member>
        <member name="F:Nucleus.Analysis.SolarPositioning.YTable">
            <summary>
            The Y coefficients for sin terms given in table A4.3
            </summary>
        </member>
        <member name="F:Nucleus.Analysis.SolarPositioning.aTable">
            <summary>
            The column of 'a' coefficients from table A4.3
            </summary>
        </member>
        <member name="F:Nucleus.Analysis.SolarPositioning.bTable">
            <summary>
            The column of 'b' coefficients from table A4.3
            </summary>
        </member>
        <member name="F:Nucleus.Analysis.SolarPositioning.cTable">
            <summary>
            The column of 'c' coefficients from table A4.3
            </summary>
        </member>
        <member name="F:Nucleus.Analysis.SolarPositioning.dTable">
            <summary>
            The column of 'd' coefficients from table A4.3
            </summary>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateJulianDay(System.DateTime)">
            <summary>
            Calculate the Julian Day from a date expressed in Universal Time.
            The Julian date starts on January 1, in the year -4712 at 12:00:00 UT.
            </summary>
            <param name="universalTime">The date expressed in Universal Time</param>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateJulianDay(System.Int32,System.Int32,System.Double)">
            <summary>
            Calculate the Julian Day from a date expressed in Universal Time.
            The Julian date starts on January 1, in the year -4712 at 12:00:00 UT.
            </summary>
            <param name="year">The year expressed as an integer (for e.g. 2018)</param>
            <param name="month">The month expressed as an integer (for e.g. January = 1)</param>
            <param name="day">The  day of the month with decimal time (e.g. for the second day of the
            month at 12:30:30 UT, D = 2.521180556).</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateJulianCentury(System.Double)">
            <summary>
            Calculate the Julian Century from the Julian Day.
            (May also be used to calculate the Julian Ephemeris Century (JCE)
            from the Julian Ephemeris Day, should one be so inclined).
            </summary>
            <param name="julianDay"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateJulianMillenium(System.Double)">
            <summary>
            Calculate the Julian Millennium from the Julian Century.
            </summary>
            <param name="julianCentury"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateJulianMillenium(System.DateTime)">
            <summary>
            Calculate the Julian Millennium from the specified date in Universal Time
            </summary>
            <param name="universalTime"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateHeliocentricComponent(System.Double[0:,0:],System.Double)">
            <summary>
            Calculate a component of the helocentric latitude or longitude.
            Equation (9) in the NREL paper.
            </summary>
            <param name="table"></param>
            <param name="julianMillenium"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateEarthHeliocentricLongitude(System.Double)">
            <summary>
            Calculate the Heliocentric longitude of the earth at the specified time.
            Steps 3.2.4 to 3.2.5 using Equation (11) in the NREL paper.
            </summary>
            <param name="julianMillenium"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateEarthHeliocentricLatitude(System.Double)">
            <summary>
            Calculate the Heliocentric latitude of the earth at the specified time.
            Step 3.2.7 and Equation (11) in the NREL paper.
            </summary>
            <param name="julianMillenium"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateEarthRadiusVector(System.Double)">
            <summary>
            Calculate the Earth Radius Vector, R, in Astronomical Units at the specified time.
            Step 3.2.8 and Equation (11) in the NREL paper.
            </summary>
            <param name="julianMillenium"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateGeocentricLongitude(Nucleus.Geometry.Angle)">
            <summary>
            Calculate the geocentric longitude from the heliocentric longitude
            </summary>
            <param name="hcLong"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateGeocentricLatitude(Nucleus.Geometry.Angle)">
            <summary>
            Calculate the geocentric latitude from the heliocentric latitude
            </summary>
            <param name="hcLat"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateNutationCoefficients(System.Double)">
            <summary>
            Calculate the coefficient values used to calculate the 
            nutation in longitude and obliquity.
            Steps 3.4.1 to 3.4.5 and equations (15) to (19) in
            the NREL paper.
            </summary>
            <param name="julianCentury"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateNutationInLongitude(System.Double,Nucleus.Geometry.Angle[])">
            <summary>
            Calculate the nutation in longitude for a specified julian century.
            Step 3.4.7 and equations (20) and (22) in the NREL paper.
            </summary>
            <param name="julianCentury"></param>
            <param name="X"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateNutationInObliquity(System.Double,Nucleus.Geometry.Angle[])">
            <summary>
            Calculate the nutation in longitude for a specified julian century.
            Step 3.4.7 and equations (20) and (22) in the NREL paper.
            </summary>
            <param name="julianCentury"></param>
            <param name="X"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateTrueObliquityOfTheEliptic(System.Double,Nucleus.Geometry.Angle)">
            <summary>
            Calculate the true obliquity of the eliptic.
            Step 3.5 and equations (24) and (25) in the NREL paper
            </summary>
            <param name="julianMillenium"></param>
            <param name="obliquityNutation"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateAberrationCorrection(System.Double)">
            <summary>
            Calculate the aberration correction angle.
            Step 3.6 and equation (26) in the NREL paper
            </summary>
            <param name="R"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateApparentSunLongitude(Nucleus.Geometry.Angle,Nucleus.Geometry.Angle,Nucleus.Geometry.Angle)">
            <summary>
            Calculate the apparent sun longitude.
            Step 3.7 and equation (27) in the NREL paper
            </summary>
            <param name="geocentricLongitude"></param>
            <param name="longitudeNutation"></param>
            <param name="aberrationCorrection"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateApparentSiderealTime(System.Double,System.Double,Nucleus.Geometry.Angle,Nucleus.Geometry.Angle)">
            <summary>
            Calculate the apparent sidereal time at Greenwich.
            Step 3.8 and equations (28) and (29) in the NREL paper
            </summary>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateGeocentricSunRightAscension(Nucleus.Geometry.Angle,Nucleus.Geometry.Angle,Nucleus.Geometry.Angle)">
            <summary>
            Calculate the geocentric sun right ascension.
            Step 3.8 and equation (30) in the NREL paper
            </summary>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateGeocentricSunDeclination(Nucleus.Geometry.Angle,Nucleus.Geometry.Angle,Nucleus.Geometry.Angle)">
            <summary>
            Calculate the geocentric sun declination.
            Step 3.10 in the NREL paper.
            </summary>
            <param name="apparentSunLong"></param>
            <param name="eclipticObliquity"></param>
            <param name="gcLatitude"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateObserverLocalHourAngle(Nucleus.Geometry.Angle,Nucleus.Geometry.Angle,Nucleus.Geometry.Angle)">
            <summary>
            Calculate the observer local hour angle, H
            Step 3.11 and equation (32) in the NREL paper
            </summary>
            <param name="siderealTime"></param>
            <param name="observerLongitude"></param>
            <param name="sunRightAscension"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateTopocentricSunDeclanation(System.Double,Nucleus.Geometry.Angle,System.Double,Nucleus.Geometry.Angle,Nucleus.Geometry.Angle,Nucleus.Geometry.Angle,Nucleus.Geometry.Angle@,Nucleus.Geometry.Angle@)">
            <summary>
            Calculate the topocentric sun right ascension
            Step 3.12 in the NREL paper
            </summary>
            <param name="earthRadiusVector"></param>
            <param name="deltaAlpha">Output.   Parallax in the sun right ascension.</param>
            <param name="alphaDash">Output.   Topocentric sun right ascension.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateTopocentricLocalHourAngle(Nucleus.Geometry.Angle,Nucleus.Geometry.Angle)">
            <summary>
            Calculate the topocentric local hour angle.
            Step 3.13 in the NREL paper
            </summary>
            <param name="localHourAngle"></param>
            <param name="deltaAlpha"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateTopocentricZenithAngle(Nucleus.Geometry.Angle,Nucleus.Geometry.Angle,Nucleus.Geometry.Angle,System.Double,System.Double)">
            <summary>
            Calculate the topocentric zenith angle.
            Step 3.14 in the NREL paper.
            </summary>
            <param name="latitude"></param>
            <param name="gcSunDeclination"></param>
            <param name="tcLocalHour"></param>
            <param name="pressure"></param>
            <param name="temperature"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateTopocentricAzimuthAngle(Nucleus.Geometry.Angle,Nucleus.Geometry.Angle,Nucleus.Geometry.Angle)">
            <summary>
            Calculate topocentric azimuth angle.
            Step 3.15 in the NREL paper.
            </summary>
            <returns>An angle measured eastward from north</returns>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateIncidenceAngle(Nucleus.Geometry.Angle,Nucleus.Geometry.Angle,Nucleus.Geometry.Angle,Nucleus.Geometry.Angle,Nucleus.Geometry.Angle)">
            <summary>
            Calculate the incidence angle to an inclined plane.
            Step 3.16 and equation (47)
            </summary>
            <param name="slope">The slope of the surface measured from the horizontal plane</param>
            <param name="surfaceAzimuth"> the surface azimuth rotation angle, measured from south 
            to the projection of the surface normal on the horizontal plane, positive or negative 
            if oriented west or east from south, respectively</param>
            <param name="theta">The topocentric zenith angle</param>
            <param name="sunAzimuth">The sun azimuth</param>
            <param name="sunLongitude">The apparent sun longitude</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SolarPositioning.CalculateSunPosition(System.DateTime,Nucleus.Geometry.Angle,Nucleus.Geometry.Angle,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Calculate the solar position at the specified time and location.
            </summary>
            <param name="date">The date and time, in Universal Time.</param>
            <param name="latitude">The latitude of the observer.</param>
            <param name="longitude">The longitude of the observer.</param>
            <param name="altitude">The altitude of the observer.</param>
            <param name="temperature">The annual average local temperature.</param>
            <param name="pressure">The annual average local pressure.</param>
            <param name="deltaT">The difference between the Earth rotation time and 
            the Terrestrial Time (TT). It is derived from observation only and reported 
            yearly in the Astronomical Almanac</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Analysis.ICalculationScenario">
            <summary>
            Interface for classes which represent scenarios on which calculations
            are to be performed.
            </summary>
        </member>
        <member name="T:Nucleus.Analysis.WindLoadsBox">
            <summary>
            Calculation of wind loads on a simple box to Eurocode 1 EN 1991-1-4
            </summary>
        </member>
        <member name="M:Nucleus.Analysis.WindLoadsBox.BasicWindVelocity(System.Double,System.Double,System.Double)">
            <summary>
            Calculate the basic wind velocity (v_b) using Expression 4.1
            </summary>
            <param name="v_b0">The fundamental value of the basic wind velocity</param>
            <param name="c_dir">The directional factor.  May be found in the National Annex.</param>
            <param name="c_season">The seasonal factor.  May be found in the National Annex.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.WindLoadsBox.MeanWindVelocity(System.Double,System.Double,System.Double)">
            <summary>
            Calculate the mean wind velocity (v_m) using Expression 4.3
            </summary>
            <param name="v_b">The basic wind velocity</param>
            <param name="c_r">The terrain roughness factor, given in 4.3.2 </param>
            <param name="c_o">The orography factor, taken as 1.0 unless otherwise specified in 4.3.3</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.WindLoadsBox.AltitudeFactor(System.Double,System.Double)">
            <summary>
            Calculate the Altitude Factor (c_alt)
            </summary>
            <param name="A">The site altitude (ground level in front of the building in m above sea level)</param>
            <param name="z_s">The reference height.  For global effects, this is 0.6 * the building height.  For individual element
            calculations this should be taken from EN1991-1-4 Fig. 6.1</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.WindLoadsBox.PeakVelocityPressure(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Calculate the Peak Velocity Pressure (q_p), in Pa
            </summary>
            <param name="v_map">The map velocity, in m/s</param>
            <param name="c_alt">The altitude factor</param>
            <param name="c_dir">The direction factor</param>
            <param name="c_e">The exposure factor</param>
            <param name="c_eT">The town terrain correction factor</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.WindLoadsBox.WindForce(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Calculate the wind force (F_w)
            </summary>
            <param name="q_p">The peak velocity pressure, in Pa</param>
            <param name="c_s">The size factor</param>
            <param name="c_d">The dynamic factor</param>
            <param name="c_f">The force coefficient</param>
            <param name="a_sh">The shadow area (usually b*h)</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.WindLoadsBox.ForceCoefficient(System.Double,System.Double)">
            <summary>
            Calculate the wind force coefficient based on the height and depth of the building
            </summary>
            <param name="h">The height of the building</param>
            <param name="d">The depth of the building</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.WindLoadsBox.FrictionalForce(System.Double,System.Double,System.Double)">
            <summary>
            Calculate the wind frictional force (F_fr)
            </summary>
            <param name="c_fr">The friction coefficient (see EN 1991-1-4 Table 7.10)</param>
            <param name="q_p">The peak velocity pressure.  May substitute for q_p(o) in an orographic situation.</param>
            <param name="A_fr">The frictional area.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.WindLoadsBox.Test(System.Text.StringBuilder)">
            <summary>
            Test-run of wind calculation
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Analysis.SimpleBeamAnalysis">
            <summary>
            Class for performing basic structural engineering calculations on 
            simply-supported beams under uniformly distributed loading
            </summary>
        </member>
        <member name="M:Nucleus.Analysis.SimpleBeamAnalysis.#ctor(System.Double,System.Double)">
            <summary>
            Initialise a beam calculation for the specified length and load
            </summary>
            <param name="length"></param>
            <param name="udl"></param>
        </member>
        <member name="M:Nucleus.Analysis.SimpleBeamAnalysis.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initialise a beam calculation for the specified beam variables
            </summary>
            <param name="length"></param>
            <param name="udl"></param>
            <param name="e"></param>
            <param name="i"></param>
        </member>
        <member name="M:Nucleus.Analysis.SimpleBeamAnalysis.#ctor(Nucleus.Model.LinearElement,System.Double)">
            <summary>
            Initialise a beam calculation for the specified element under the specified load
            </summary>
            <param name="element"></param>
            <param name="udl"></param>
        </member>
        <member name="M:Nucleus.Analysis.SimpleBeamAnalysis.MaxMoment(Nucleus.Logs.ICalculationLog)">
            <summary>
            Calculate the maximum bending moment (about the major axis).
            Requires UDL and Length.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SimpleBeamAnalysis.MomentAt(System.Double,Nucleus.Logs.ICalculationLog)">
            <summary>
            Calculate the bending moment at a position along the beam.
            Requires UDL and Length.
            </summary>
            <param name="x">The position along the beam, as a distance from
            the start (in m).</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SimpleBeamAnalysis.MaxShear">
            <summary>
            Calculate the maximum shear force in the beam.
            Requires UDL and Length.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SimpleBeamAnalysis.ShearAt(System.Double)">
            <summary>
            Calculate the shear force in the beam at the specified distance
            along it.
            Requires UDL and Length.
            </summary>
            <param name="x">The position along the beam, as a distance from
            the start (in m).</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SimpleBeamAnalysis.MaxDeflection">
            <summary>
            Calculate the maximum deflection of the beam.
            Requires UDL, Length, E and I.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SimpleBeamAnalysis.TotalLoad">
            <summary>
            Calculate the total value of all loading applied to the beam.
            Requires UDL and Length.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Analysis.SimpleBeamAnalysis.NaturalFrequencies">
            <summary>
            Calculate (approximately) the first 5 natural frequencies of the beam.
            NOT YET TESTED.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Base.Deletable">
            <summary>
            A named object which implements the IDeletable interface to allow it to be
            tagged for deletion
            </summary>
        </member>
        <member name="F:Nucleus.Base.Deletable._IsDeleted">
            <summary>
            Private backing field for IsDeleted property
            </summary>
        </member>
        <member name="P:Nucleus.Base.Deletable.IsDeleted">
            <summary>
            Get a boolean value indicating whether this object has been
            marked for deletion.  This flag indicates that the object should be
            ignored in any operation that acts only on the current state of the
            model and that it should be removed during the next cleanup sweep.
            </summary>
        </member>
        <member name="M:Nucleus.Base.Deletable.Delete">
            <summary>
            Delete this object.
            The object itself will not be immediately removed from the model
            but will instead be flagged for future removal and ignored in most
            operations.  Check the IsDeleted property to see whether this
            object is marked for deletion.
            </summary>
        </member>
        <member name="M:Nucleus.Base.Deletable.Undelete">
            <summary>
            Undelete this object.
            If the deletion flag on this object is set it will be unset and
            the object restored.
            </summary>
        </member>
        <member name="T:Nucleus.Base.DoubleParameter">
            <summary>
            A named input or output parameter which holds a double value
            </summary>
        </member>
        <member name="P:Nucleus.Base.DoubleParameter.SIValue">
            <summary>
            Get or set the value of this parameter in
            SI units.  If the Units property of this
            parameter is set then the base value of this
            parameter will be converted using the SIFactor
            property of the unit to return a value in
            the equivalent SI units.
            </summary>
        </member>
        <member name="M:Nucleus.Base.DoubleParameter.#ctor(System.String,Nucleus.Units.MeasurementUnit)">
            <summary>
            Creates a new parameter with the specified name.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="units">The units in which the parameter is expressed</param>
        </member>
        <member name="M:Nucleus.Base.DoubleParameter.#ctor(System.String,System.Double,Nucleus.Units.MeasurementUnit)">
            <summary>
            Creates a new parameter with the specified name and
            initial value
            </summary>
            <param name="name">The name of this parameter</param>
            <param name="value">The value of this parameter</param>
            <param name="units">The units in which the parameter is expressed</param>
        </member>
        <member name="M:Nucleus.Base.DoubleParameter.#ctor(System.String,Nucleus.Base.ParameterGroup,System.Double,Nucleus.Units.MeasurementUnit)">
            <summary>
            Creates a new parameter with the specified name, group
            and initial value.
            </summary>
            <param name="name">The name of this parameter</param>
            <param name="group">The group within which this parameter
            should be displayed</param>
            <param name="value">The initial value of the parameter</param>
            <param name="units">The units in which the parameter is expressed</param>
        </member>
        <member name="M:Nucleus.Base.DoubleParameter.#ctor">
            <summary>
            Creates a new parameter with the default value and no name.
            As all parameters require an immutable name, this should not be
            used unless you know what you're doing.
            </summary>
        </member>
        <member name="M:Nucleus.Base.DoubleParameter.#ctor(System.String,Nucleus.Base.ParameterGroup,System.Double,System.String,Nucleus.Units.MeasurementUnit)">
            <summary>
            Creates a new parameter with the specified name, group,
            initial value and description.
            </summary>
            <param name="name">The name of this parameter.</param>
            <param name="group">The group within which this parameter
            should be displayed.</param>
            <param name="value">The initial value of the parameter.</param>
            <param name="description">The description of the parameter's function.</param>
            <param name="units">The units in which the parameter is expressed.</param>
        </member>
        <member name="M:Nucleus.Base.DoubleParameter.GetValueIn(Nucleus.Units.MeasurementUnit)">
            <summary>
            Get the current value of this parameter, expressed in the
            specified units.
            </summary>
            <param name="units"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Base.Gender">
            <summary>
            Enumerated value representing grammatical gender
            </summary>
        </member>
        <member name="F:Nucleus.Base.Gender.Neutral">
            <summary>
            Gender-neutral terms - 'its', 'their' etc.
            </summary>
        </member>
        <member name="F:Nucleus.Base.Gender.Masculine">
            <summary>
            Maculine terms - i.e. 'his'
            </summary>
        </member>
        <member name="F:Nucleus.Base.Gender.Feminine">
            <summary>
            Feminine terms - i.e. 'her'
            </summary>
        </member>
        <member name="T:Nucleus.Base.GenderHelper">
            <summary>
            Static helper functions to aid working with the Gender enum
            </summary>
        </member>
        <member name="M:Nucleus.Base.GenderHelper.GenderOf(System.Object)">
            <summary>
            Get the gender of the specified object (if applicable)
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Base.IFastDuplicatable">
            <summary>
            Interface for objects which implement a 'FastDuplicate()'
            method to create duplicates of objects.
            This duplication must be manually implemented and so
            there is a lot more implementation work involved than with
            the fully automatic IDuplicatable interface but the
            resulting duplication may be significantly more efficient
            as the use of reflection can be avoided.
            </summary>
        </member>
        <member name="M:Nucleus.Base.IFastDuplicatable.FastDuplicate_Internal">
            <summary>
            Method used by the FastDuplicate() extension method.
            Implement this explicitly and manually construct a copy of the original type.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Base.IFastDuplicatableExtensions">
            <summary>
            Extension methods for the IFastDuplicateble 
            </summary>
        </member>
        <member name="M:Nucleus.Base.IFastDuplicatableExtensions.FastDuplicate``1(``0)">
            <summary>
            Produce a duplicate of this object.
            This is an alternative to the more general Duplicate()
            method.
            Unlike Duplicate() this does not (always) use reflection and must
            be manually implemented, meaning that it may be significantly
            faster in execution but that not all properties are guaranteed
            to be fully duplicated (though key ones should be).
            This is typically used to optimise performance-critical code
            where the normal duplication framework would be too expensive.
            </summary>
            <typeparam name="TSelf"></typeparam>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Base.IntParameter">
            <summary>
            A named input or output parameter which holds an integer value
            </summary>
        </member>
        <member name="M:Nucleus.Base.IntParameter.#ctor(System.String,Nucleus.Units.MeasurementUnit)">
            <summary>
            Creates a new parameter with the specified name.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="units">The units in which the parameter is expressed</param>
        </member>
        <member name="M:Nucleus.Base.IntParameter.#ctor(System.String,System.Int32,Nucleus.Units.MeasurementUnit)">
            <summary>
            Creates a new parameter with the specified name and
            initial value
            </summary>
            <param name="name">The name of this parameter</param>
            <param name="value">The value of this parameter</param>
            <param name="units">The units in which the parameter is expressed</param>
        </member>
        <member name="M:Nucleus.Base.IntParameter.#ctor(System.String,Nucleus.Base.ParameterGroup,System.Int32,Nucleus.Units.MeasurementUnit)">
            <summary>
            Creates a new parameter with the specified name, group
            and initial value.
            </summary>
            <param name="name">The name of this parameter</param>
            <param name="group">The group within which this parameter
            should be displayed</param>
            <param name="value">The initial value of the parameter</param>
            <param name="units">The units in which the parameter is expressed</param>
        </member>
        <member name="M:Nucleus.Base.IntParameter.#ctor">
            <summary>
            Creates a new parameter with the default value and no name.
            As all parameters require an immutable name, this should not be
            used unless you know what you're doing.
            </summary>
        </member>
        <member name="M:Nucleus.Base.IntParameter.#ctor(System.String,Nucleus.Base.ParameterGroup,System.Int32,System.String,Nucleus.Units.MeasurementUnit)">
            <summary>
            Creates a new parameter with the specified name, group,
            initial value and description.
            </summary>
            <param name="name">The name of this parameter.</param>
            <param name="group">The group within which this parameter
            should be displayed.</param>
            <param name="value">The initial value of the parameter.</param>
            <param name="description">The description of the parameter's function.</param>
            <param name="units">The units in which the parameter is expressed.</param>
        </member>
        <member name="T:Nucleus.Base.IRefreshable">
            <summary>
            Interface for objects which may be refreshed
            </summary>
        </member>
        <member name="M:Nucleus.Base.IRefreshable.Refresh">
            <summary>
            Refresh this object
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Base.IRefreshableExtensions">
            <summary>
            Extension methods for the IRefreshable interface
            </summary>
        </member>
        <member name="M:Nucleus.Base.IRefreshableExtensions.RefreshAll``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Refresh all of the objects in this collection
            </summary>
            <typeparam name="TRefreshable"></typeparam>
            <param name="refreshables"></param>
        </member>
        <member name="T:Nucleus.Base.Option">
            <summary>
            Abstract base class for Options.  Represents one potential
            design configuration which is under consideration.
            </summary>
        </member>
        <member name="T:Nucleus.Base.Option`1">
            <summary>
            Abstract generic base class for Options.  Represents one potential
            design configuration which is under consideration.
            </summary>
            <typeparam name="TDesign">The type of data that represents 
            the design within this option</typeparam>
        </member>
        <member name="F:Nucleus.Base.Option`1._Design">
            <summary>
            Private backing member variable for the Design property
            </summary>
        </member>
        <member name="P:Nucleus.Base.Option`1.Design">
            <summary>
            The design of this option
            </summary>
        </member>
        <member name="T:Nucleus.Base.OptionCollection">
            <summary>
            A collection of options
            </summary>
        </member>
        <member name="T:Nucleus.Base.Parameter">
            <summary>
            Abstract base class for named input or output parameters 
            associated with a design option.
            </summary>
        </member>
        <member name="F:Nucleus.Base.Parameter._Name">
            <summary>
            Protected backing field for the Name property
            </summary>
        </member>
        <member name="P:Nucleus.Base.Parameter.Name">
            <summary>
            Get the name of this parameter
            </summary>
        </member>
        <member name="F:Nucleus.Base.Parameter._Group">
            <summary>
            Private backing field for Group property
            </summary>
        </member>
        <member name="P:Nucleus.Base.Parameter.Group">
            <summary>
            Get or set the group (if any) to which this parameter belongs.
            </summary>
        </member>
        <member name="F:Nucleus.Base.Parameter._Units">
            <summary>
            Private backing field for the Units property
            </summary>
        </member>
        <member name="P:Nucleus.Base.Parameter.Units">
            <summary>
            Get or set the units of measurement of the parameter
            </summary>
        </member>
        <member name="F:Nucleus.Base.Parameter._Description">
            <summary>
            Private backing field for the Description property
            </summary>
        </member>
        <member name="P:Nucleus.Base.Parameter.Description">
            <summary>
            Get or set the description of this parameter.
            May be used as a tooltip.
            </summary>
        </member>
        <member name="F:Nucleus.Base.Parameter._Visible">
            <summary>
            Private backing field for the Visible property
            </summary>
        </member>
        <member name="P:Nucleus.Base.Parameter.Visible">
            <summary>
            Should the parameter be displayed?
            </summary>
        </member>
        <member name="M:Nucleus.Base.Parameter.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Base.Parameter.#ctor(System.String)">
            <summary>
            Name constructor
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Nucleus.Base.Parameter.SetValue(System.Object)">
            <summary>
            Set the value of the parameter to the specified new value
            </summary>
            <param name="newValue"></param>
            <returns>True if the value was successfully set, false if not.</returns>
        </member>
        <member name="M:Nucleus.Base.Parameter.GetValue">
            <summary>
            Get the value of the parameter.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.Parameter.SetValueFrom(Nucleus.Base.Parameter)">
            <summary>
            Set the value of this parameter by copying the value of
            the specified other parameter (if it is of the appropriate type).
            </summary>
            <param name="other"></param>
            <returns>True if the value is successfully set, false if not.</returns>
        </member>
        <member name="T:Nucleus.Base.Parameter`1">
            <summary>
            Generic class for named input or output parameters 
            associated with a design option
            </summary>
            <typeparam name="T">The type of the parameter</typeparam>
        </member>
        <member name="F:Nucleus.Base.Parameter`1._Value">
            <summary>
            Private backing member variable for the Value property
            </summary>
        </member>
        <member name="P:Nucleus.Base.Parameter`1.Value">
            <summary>
            The parameter value
            </summary>
        </member>
        <member name="M:Nucleus.Base.Parameter`1.#ctor">
            <summary>
            Creates a new parameter with the default value and no name.
            As all parameters require an immutable name, this should not be
            used unless you know what you're doing.
            </summary>
        </member>
        <member name="M:Nucleus.Base.Parameter`1.#ctor(System.String,Nucleus.Units.MeasurementUnit)">
            <summary>
            Creates a new parameter with the specified name.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="units">The units in which the parameter is expressed</param>
        </member>
        <member name="M:Nucleus.Base.Parameter`1.#ctor(System.String,`0,Nucleus.Units.MeasurementUnit)">
            <summary>
            Creates a new parameter with the specified name and
            initial value
            </summary>
            <param name="name">The name of this parameter</param>
            <param name="value">The value of this parameter</param>
            <param name="units">The units in which the parameter is expressed</param>
        </member>
        <member name="M:Nucleus.Base.Parameter`1.#ctor(System.String,Nucleus.Base.ParameterGroup,`0,Nucleus.Units.MeasurementUnit)">
            <summary>
            Creates a new parameter with the specified name, group
            and initial value.
            </summary>
            <param name="name">The name of this parameter.</param>
            <param name="group">The group within which this parameter
            should be displayed.</param>
            <param name="value">The initial value of the parameter.</param>
            <param name="units">The units in which the parameter is expressed.</param>
        </member>
        <member name="M:Nucleus.Base.Parameter`1.#ctor(System.String,Nucleus.Base.ParameterGroup,`0,System.String,Nucleus.Units.MeasurementUnit)">
            <summary>
            Creates a new parameter with the specified name, group,
            initial value and description.
            </summary>
            <param name="name">The name of this parameter.</param>
            <param name="group">The group within which this parameter
            should be displayed.</param>
            <param name="value">The initial value of the parameter.</param>
            <param name="description">The description of the parameter's function.</param>
            <param name="units">The units in which the parameter is expressed.</param>
        </member>
        <member name="M:Nucleus.Base.Parameter`1.SetValue(System.Object)">
            <summary>
            Set the value of the parameter to the specified new value
            </summary>
            <param name="newValue"></param>
            <returns>True if the value was successfully set, false if not.</returns>
        </member>
        <member name="M:Nucleus.Base.Parameter`1.SetValueFrom(Nucleus.Base.Parameter)">
            <summary>
            Set the value of this parameter by copying the value of
            the specified other parameter (if it is of the appropriate type).
            </summary>
            <param name="other"></param>
            <returns>True if the value is successfully set, false if not.</returns>
        </member>
        <member name="M:Nucleus.Base.Parameter`1.GetValue">
            <summary>
            Get the value of the parameter.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Base.ParameterCollection">
            <summary>
            A collection of parameters.
            Each parameter within this collection must have a unique name.
            </summary>
        </member>
        <member name="M:Nucleus.Base.ParameterCollection.#ctor">
            <summary>
            Creates a new empty ParameterCollection
            </summary>
        </member>
        <member name="M:Nucleus.Base.ParameterCollection.#ctor(Nucleus.Base.Parameter[])">
            <summary>
            Creates a new ParameterCollection containing the specified parameters
            </summary>
            <param name="paras"></param>
        </member>
        <member name="M:Nucleus.Base.ParameterCollection.GetKeyForItem(Nucleus.Base.Parameter)">
            <summary>
            Get the key value from the parameter item
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.ParameterCollection.GetGroupedParameters">
            <summary>
            Get the parameters in this collection sorted into their assigned groups.
            This will return a dictionary of separate lists for each group.  The
            dictionary returned will be sorted according to the Order weighting of
            the groups.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Base.ParameterGroup">
            <summary>
            A named grouping of parameters.
            Parameters can be tagged with a group in order
            to define their 
            </summary>
        </member>
        <member name="P:Nucleus.Base.ParameterGroup.Order">
            <summary>
            The order weighting for this parameter group.  Those with a lower order
            weighting will be displayed first.
            </summary>
        </member>
        <member name="M:Nucleus.Base.ParameterGroup.#ctor">
            <summary>
            Default constructor, creates a blank empty parameter group
            with no name.  Only use this constructor if you know what 
            you're doing.
            </summary>
        </member>
        <member name="M:Nucleus.Base.ParameterGroup.#ctor(System.String)">
            <summary>
            Creates a new ParameterGroup with the specified name
            </summary>
            <param name="name">The name of the group</param>
        </member>
        <member name="M:Nucleus.Base.ParameterGroup.#ctor(System.String,System.Double)">
            <summary>
            Creates a new ParameterGroup with the specified name and 
            ordering weighting
            </summary>
            <param name="name"></param>
            <param name="order"></param>
        </member>
        <member name="M:Nucleus.Base.ParameterGroup.CompareTo(Nucleus.Base.ParameterGroup)">
            <summary>
            IComparable implementation to aid sorting groups
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.ParameterGroup.CompareTo(System.Object)">
            <summary>
            IComparable implementation to aid sorting groups
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Base.ParameterGroupCollection">
            <summary>
            A collection of ParameterGroups.
            Each group within this collection must have a unique name.
            </summary>
        </member>
        <member name="M:Nucleus.Base.ParameterGroupCollection.GetKeyForItem(Nucleus.Base.ParameterGroup)">
            <summary>
            Get the key for the specified group
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Base.StringParameter">
            <summary>
            A named input or output parameter that holds a string value
            </summary>
        </member>
        <member name="T:Nucleus.Base.Bool6D">
            <summary>
            6D Boolean Structure.
            Represents true or false values related to the three dimensions X,Y,Z and to
            rotations about these axes (termed XX, YY and ZZ respectively).
            Immutable.
            </summary>
            <remarks>
            This type is currently implemented as a struct rather than a class,
            though this will be subject to review and may be changed.</remarks>
        </member>
        <member name="F:Nucleus.Base.Bool6D.False">
            <summary>
            A constant value representing a Bool6D with all components set
            to false.
            </summary>
        </member>
        <member name="F:Nucleus.Base.Bool6D.True">
            <summary>
            A constant value representing a Bool6D with all components set
            to true.
            </summary>
        </member>
        <member name="F:Nucleus.Base.Bool6D.X">
            <summary>
            The value in the X-direction
            </summary>
        </member>
        <member name="F:Nucleus.Base.Bool6D.Y">
            <summary>
            The value in the Y-direction
            </summary>
        </member>
        <member name="F:Nucleus.Base.Bool6D.Z">
            <summary>
            The value in the Z-direction
            </summary>
        </member>
        <member name="F:Nucleus.Base.Bool6D.XX">
            <summary>
            The value about the XX axis
            </summary>
        </member>
        <member name="F:Nucleus.Base.Bool6D.YY">
            <summary>
            The value about the YY axis
            </summary>
        </member>
        <member name="F:Nucleus.Base.Bool6D.ZZ">
            <summary>
            The value about the ZZ axis
            </summary>
        </member>
        <member name="P:Nucleus.Base.Bool6D.AllFalse">
            <summary>
            Returns true if all six values in this Bool6D are false
            </summary>
        </member>
        <member name="P:Nucleus.Base.Bool6D.AllTrue">
            <summary>
            Returns true if all six values in this Bool6D are true
            </summary>
        </member>
        <member name="P:Nucleus.Base.Bool6D.Item(Nucleus.Geometry.Direction)">
            <summary>
            Get the value in the specified direction
            </summary>
            <param name="dir"></param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Base.Bool6D.Item(System.Int32)">
            <summary>
            Get the value at the specified index, where:
            0 = X,
            1 = Y,
            2 = Z,
            3 = XX,
            4 = YY,
            5 = ZZ
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.Bool6D.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Initialise a Bool6D with the specified values
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <param name="xx"></param>
            <param name="yy"></param>
            <param name="zz"></param>
        </member>
        <member name="M:Nucleus.Base.Bool6D.#ctor(System.Boolean)">
            <summary>
            Initialise a Bool6D with all values set to either true or false
            </summary>
            <param name="all"></param>
        </member>
        <member name="M:Nucleus.Base.Bool6D.#ctor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Initialise a Bool6D with the specified X,Y,Z values.
            XX, YY and ZZ will be set to false.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:Nucleus.Base.Bool6D.#ctor(Nucleus.Geometry.Direction)">
            <summary>
            Initialise a Bool6D with only the specified direction set to true
            </summary>
            <param name="direction"></param>
        </member>
        <member name="M:Nucleus.Base.Bool6D.#ctor(System.String)">
            <summary>
            Initialise a Bool6D from a text description.
            </summary>
            <param name="description"></param>
        </member>
        <member name="M:Nucleus.Base.Bool6D.Invert">
            <summary>
            Create a new Bool6D as a negated copy of this one.
            All components will have the opposite values.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.Bool6D.WithX(System.Boolean)">
            <summary>
            Create a new Bool6D copying all values from this one
            bar the new specified value of X.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.Bool6D.WithY(System.Boolean)">
            <summary>
            Create a new Bool6D copying all values from this one
            bar the new specified value of Y.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.Bool6D.WithZ(System.Boolean)">
            <summary>
            Create a new Bool6D copying all values from this one
            bar the new specified value of Z.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.Bool6D.WithXX(System.Boolean)">
            <summary>
            Create a new Bool6D copying all values from this one
            bar the new specified value of XX.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.Bool6D.WithYY(System.Boolean)">
            <summary>
            Create a new Bool6D copying all values from this one
            bar the new specified value of YY.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.Bool6D.WithZZ(System.Boolean)">
            <summary>
            Create a new Bool6D copying all values from this one
            bar the new specified value of ZZ.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.Bool6D.With(Nucleus.Geometry.Direction,System.Boolean)">
            <summary>
            Create a new Bool6D copying all values from this one
            but overriding the specififed dimension
            </summary>
            <param name="direction"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.Bool6D.ReOrientate(Nucleus.Geometry.Direction)">
            <summary>
            Re-orientate this 6D boolean such that the specified axis direction
            becomes the new Z-axis.  This is equivalent to a 90 degree rotation
            to take the specified axis to the vertical position.
            </summary>
            <param name="newZ"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.Bool6D.ToString">
            <summary>
            Turn this Bool6D into a string representing the current values
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.Bool6D.ToString(System.String,System.String)">
            <summary>
            Turn this Bool6D into a string representing the current values
            via the specified symbols for true and false for each component
            </summary>
            <param name="trueString">The string or character used to represent true values</param>
            <param name="falseString">The string or character used to represent false values</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.Bool6D.ToArray">
            <summary>
            Convert this Bool6D to an array of six booleans,
            in order X,Y,Z,XX,YY,ZZ
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.Bool6D.ToRestraintDescription">
            <summary>
            Turn this Bool6D to a string describing it as a restraint condition.
            Gives the same result as ToString(), but with the additional special cases
            of 'Pin' and 'Fixed' for translational and full restraint respectively.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.Bool6D.Or(Nucleus.Base.Bool6D)">
            <summary>
            Obtain a new Bool6D with each dimension the logical OR
            of the equivalent component in this and another Bool6D
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.Bool6D.And(Nucleus.Base.Bool6D)">
            <summary>
            Obtain a new Bool6D with each dimension the logical AND
            of the equivalent component in this and another Bool6D
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.Bool6D.Equals(Nucleus.Base.Bool6D)">
            <summary>
            Does this Bool6D equal another?
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.Bool6D.PrimaryAxis">
            <summary>
            Retrieve direction axis pointing in the direction of one of the
            global axes, determined by the true values of this 6D boolean.
            The Z axis is prioritised, followed by X and then Y.
            This is intended for geometrical display purposes and has no
            deeper significance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.Bool6D.PrimaryAxis(Nucleus.Geometry.Direction)">
            <summary>
            Retrieve direction axis pointing in the direction of one of the
            global axes, determined by the true values of this 6D boolean.
            The specified direction is favoured if true.  Otherwise
            the Z axis is prioritised, followed by X and then Y.
            This is intended for geometrical display purposes and has no
            deeper significance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.Bool6D.FromTokensList(System.Collections.Generic.IList{System.String},System.Int32,System.String)">
            <summary>
            Create a vector from a sequential set of values in a list,
            starting at the specified index.  Out-of-bounds errors are automatically checked for.
            </summary>
            <param name="tokens"></param>
            <param name="startIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.Bool6D.FromTokensList(System.Collections.Generic.IList{System.Char},System.Int32,System.Char)">
            <summary>
            Create a vector from a sequential set of values in a list,
            starting at the specified index.  Out-of-bounds errors are automatically checked for.
            </summary>
            <param name="tokens"></param>
            <param name="startIndex"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Base.CollectionCopyAttribute">
            <summary>
            Attribute applied to collection types and fields to determine the correct procedure for dealing
            with them when automatically copying their values and their contents to another object.
            By default, fields are 'shallow-copied' - i.e. values and references are copied.
            It is only necessary to apply this attribute to fields where this behaviour should
            be changed.  Attributes applied to types define the default behaviour of that type,
            but field-level attributes will override this where present.
            </summary>
        </member>
        <member name="P:Nucleus.Base.CollectionCopyAttribute.ItemsBehaviour">
            <summary>
            The behaviour of the items contained within the annotated field during a copy operation.
            By default, properties have their values 'shallow-copied', but may
            instead be prevented from being copied or be duplicated instead,
            provided the property type is duplicatable.
            </summary>
        </member>
        <member name="T:Nucleus.Base.IUniqueWithModifiableGUID">
            <summary>
            Interface for unique objects which allow you to modify their
            GUID.  This is generally a very bad idea and is intended for use
            only when deserialising uniques or when wanting to produce an
            *exact* copy between two separate models.
            The main purpose of this interface is to make setting the GUID
            difficult to do without due consideration - implement this interface
            explicitly to prevent its members showing up in intellisense.
            </summary>
        </member>
        <member name="T:Nucleus.Base.KeyedCollection`2">
            <summary>
            A customised re-implementation of System.Collections.ObjectModel.KeyedCollection that
            marks the backing dictionary as nonserialisable in order to avoid storing redundant data
            and makes some other small improvements.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="F:Nucleus.Base.KeyedCollection`2.DefaultThreshold">
            <summary>
            The size at which a dictionary will be created
            </summary>
        </member>
        <member name="P:Nucleus.Base.KeyedCollection`2.Dictionary">
            <summary>
            The backing dictionary that allows for fast lookup by key
            </summary>
        </member>
        <member name="M:Nucleus.Base.KeyedCollection`2.Reverse">
            <summary>
            Reverse the order of the items in this collection
            </summary>
        </member>
        <member name="T:Nucleus.Base.Pair`2">
            <summary>
            A utility structure to contain two related objects
            </summary>
            <typeparam name="TFirst">The type of the first object</typeparam>
            <typeparam name="TSecond">The type of the second object</typeparam>
        </member>
        <member name="P:Nucleus.Base.Pair`2.First">
            <summary>
            The first field
            </summary>
        </member>
        <member name="P:Nucleus.Base.Pair`2.Second">
            <summary>
            The second field
            </summary>
        </member>
        <member name="T:Nucleus.Base.Pair">
            <summary>
            Static helper functions relating to the Pair structure
            </summary>
        </member>
        <member name="M:Nucleus.Base.Pair.Create``2(``0,``1)">
            <summary>
            Static helper function to create a Pair structure containing two objects.
            This can be used to rapidly instantiate new pairs without the necessity to
            explicitly specify the type parameters each time.
            </summary>
            <typeparam name="TFirst"></typeparam>
            <typeparam name="TSecond"></typeparam>
            <param name="first"></param>
            <param name="second"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Base.SetFilterCollection`2">
            <summary>
            Generic base type for collections of Set Filters
            </summary>
        </member>
        <member name="M:Nucleus.Base.SetFilterCollection`2.Pass(`1)">
            <summary>
            Does the specified item pass all filters in this collection?
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Base.ISetFilter`1">
            <summary>
            Interface for conditional filters suitable to be applied to sets
            </summary>
        </member>
        <member name="M:Nucleus.Base.ISetFilter`1.Pass(`0)">
            <summary>
            Does the specified item pass through this filter?
            </summary>
            <param name="item">The item to be tested</param>
            <returns>True if the item passes through the filter, false if not.</returns>
        </member>
        <member name="T:Nucleus.Base.PathBinding">
            <summary>
            A binding that represents a connection to a particular member on an object.
            Equivalent to WPF Binding class
            </summary>
        </member>
        <member name="F:Nucleus.Base.PathBinding._Path">
            <summary>
            Private backing field for Path property
            </summary>
        </member>
        <member name="P:Nucleus.Base.PathBinding.Path">
            <summary>
            The path of the property or method to bind to
            </summary>
        </member>
        <member name="F:Nucleus.Base.PathBinding._Source">
            <summary>
            Private backing field for Source property
            </summary>
        </member>
        <member name="P:Nucleus.Base.PathBinding.Source">
            <summary>
            The source object
            </summary>
        </member>
        <member name="M:Nucleus.Base.PathBinding.#ctor(System.String)">
            <summary>
            Initialise a new PathBinding with the specified path
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:Nucleus.Base.PathBinding.#ctor(System.String,System.Object)">
            <summary>
            Initialse a new PathBinding with the specified path and source object
            </summary>
            <param name="path"></param>
            <param name="source"></param>
        </member>
        <member name="M:Nucleus.Base.PathBinding.Value(System.Object)">
            <summary>
            Get the return value of the bound member on the source object
            </summary>
        </member>
        <member name="T:Nucleus.Base.MessageRaiser">
            <summary>
            Abstract base class for objects which can raise message events.
            Typically used for objects which own and run a lengthy process
            that may need to raise Message events in order to communicate
            progress and errors encountered to the outside environment
            without interrupting program flow.
            </summary>
        </member>
        <member name="F:Nucleus.Base.MessageRaiser.Message">
            <summary>
            Message event raised when this object has something to communicate to the
            outside world.
            </summary>
        </member>
        <member name="M:Nucleus.Base.MessageRaiser.RaiseMessage(System.String)">
            <summary>
            Raise a message event
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:Nucleus.Base.ObservablePair`2">
            <summary>
            A generic, general-purpose pairing of objects that raises notify property changed events
            when modified.
            </summary>
            <typeparam name="TFirst">The first type of object in the pair</typeparam>
            <typeparam name="TSecond">The second type of object in the pair</typeparam>
        </member>
        <member name="F:Nucleus.Base.ObservablePair`2._First">
            <summary>
            Private backing field for the First property
            </summary>
        </member>
        <member name="P:Nucleus.Base.ObservablePair`2.First">
            <summary>
            The first item in the pair
            </summary>
        </member>
        <member name="F:Nucleus.Base.ObservablePair`2._Second">
            <summary>
            Private backing field for the Second property
            </summary>
        </member>
        <member name="P:Nucleus.Base.ObservablePair`2.Second">
            <summary>
            The second item in the pair
            </summary>
        </member>
        <member name="M:Nucleus.Base.ObservablePair`2.#ctor">
            <summary>
            Default constructor.
            Initialises a new, empty pair
            </summary>
        </member>
        <member name="M:Nucleus.Base.ObservablePair`2.#ctor(`0,`1)">
            <summary>
            First, Second constructor.
            Initialises a new pair containing the specififed values
            </summary>
            <param name="first"></param>
            <param name="second"></param>
        </member>
        <member name="T:Nucleus.Base.ObservablePairExtensions">
            <summary>
            Extension methods for ObservablePairs and containers which hold them
            </summary>
        </member>
        <member name="M:Nucleus.Base.ObservablePairExtensions.FindByFirst``2(System.Collections.Generic.IEnumerable{Nucleus.Base.ObservablePair{``0,``1}},``0)">
            <summary>
            Find a pair by its first value
            </summary>
            <typeparam name="TFirst"></typeparam>
            <typeparam name="TSecond"></typeparam>
            <param name="collection"></param>
            <param name="first">The item to search for</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.ObservablePairExtensions.FindBySecond``2(System.Collections.Generic.IEnumerable{Nucleus.Base.ObservablePair{``0,``1}},``1)">
            <summary>
            Find a pair by its second value
            </summary>
            <typeparam name="TFirst"></typeparam>
            <typeparam name="TSecond"></typeparam>
            <param name="collection"></param>
            <param name="second">The item to search for</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.ObservablePairExtensions.Add``2(System.Collections.Generic.ICollection{Nucleus.Base.ObservablePair{``0,``1}},``0,``1)">
            <summary>
            Add a new pair to this collection.
            Shortcut method that automatically generates an ObservablePair from the specififed objects and
            adds it to this collection
            </summary>
            <typeparam name="TFirst"></typeparam>
            <typeparam name="TSecond"></typeparam>
            <param name="collection"></param>
            <param name="first">The first item in the pair</param>
            <param name="second">The second item in the pair</param>
        </member>
        <member name="M:Nucleus.Base.ObservablePairExtensions.Insert``2(System.Collections.Generic.IList{Nucleus.Base.ObservablePair{``0,``1}},System.Int32,``0,``1)">
            <summary>
            Insert a new pair to this list at the specified position.
            Shortcut method that automatically generates an ObservablePair from the specififed objects and
            adds it to this collection.
            </summary>
            <typeparam name="TFirst"></typeparam>
            <typeparam name="TSecond"></typeparam>
            <param name="collection"></param>
            <param name="index">The index to insert the new pair at</param>
            <param name="first">The first item in the pair</param>
            <param name="second">The second item in the pair</param>
        </member>
        <member name="M:Nucleus.Base.ObservablePairExtensions.CountWhereFirst``2(System.Collections.Generic.IEnumerable{Nucleus.Base.ObservablePair{``0,``1}},``0)">
            <summary>
            Count the number of pairs in this set where the first item in the pair is equal to the value
            specified.
            </summary>
            <typeparam name="TFirst"></typeparam>
            <typeparam name="TSecond"></typeparam>
            <param name="collection"></param>
            <param name="equals">The value to check the first item in each pair for equality to</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.ObservablePairExtensions.CountWhereSecond``2(System.Collections.Generic.IEnumerable{Nucleus.Base.ObservablePair{``0,``1}},``1)">
            <summary>
            Count the number of pairs in this set where the second item in the pair is equal to the value
            specified.
            </summary>
            <typeparam name="TFirst"></typeparam>
            <typeparam name="TSecond"></typeparam>
            <param name="collection"></param>
            <param name="equals">The value to check the second item in each pair for equality to</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Base.BiDirectionary`2">
            <summary>
            A bi-directional dictionary that stores pairs of values and allows fast
            lookup of the second by the first or the first by the second.
            </summary>
            <typeparam name="TFirst">The type of the first item in each pair</typeparam>
            <typeparam name="TSecond">The type of the second item in each pair</typeparam>
        </member>
        <member name="F:Nucleus.Base.BiDirectionary`2._FirstToSecond">
            <summary>
            The dictionary mapping the first set of data as keys to the second
            </summary>
        </member>
        <member name="F:Nucleus.Base.BiDirectionary`2._SecondToFirst">
            <summary>
            The reversed dictionary mapping the second set of data as keys to the first
            </summary>
        </member>
        <member name="P:Nucleus.Base.BiDirectionary`2.Item(`0)">
            <summary>
            Get or set a value by a key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Base.BiDirectionary`2.Item(`1)">
            <summary>
            Get or set a key by a value
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Base.BiDirectionary`2.Count">
            <summary>
            Get the number of elements contained within the dictionary
            </summary>
        </member>
        <member name="M:Nucleus.Base.BiDirectionary`2.#ctor">
            <summary>
            Default constructor.  Initialises a new BiDirectionary.
            </summary>
        </member>
        <member name="M:Nucleus.Base.BiDirectionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Adds a linked pair of items to the BiDirectionary
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Nucleus.Base.BiDirectionary`2.Add(`0,`1)">
            <summary>
            Adds the linked pair of items to the BiDirectionary
            </summary>
            <param name="first"></param>
            <param name="second"></param>
        </member>
        <member name="M:Nucleus.Base.BiDirectionary`2.Set(`0,`1)">
            <summary>
            Set the linked pair of items within the BiDirectionary.
            This will override any existing stored relationship
            </summary>
            <param name="first"></param>
            <param name="second"></param>
        </member>
        <member name="M:Nucleus.Base.BiDirectionary`2.Clear">
            <summary>
            Removes all items from the BiDirectionary
            </summary>
        </member>
        <member name="M:Nucleus.Base.BiDirectionary`2.GetFirst(`1)">
            <summary>
            Get the value within the first set keyed by the specified
            value from within the second.
            </summary>
            <param name="bySecond"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.BiDirectionary`2.GetSecond(`0)">
            <summary>
            Get the value within the second set keyed by the specified
            value from within the first set
            </summary>
            <param name="byFirst"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.BiDirectionary`2.ContainsFirst(`0)">
            <summary>
            Determines whether this BiDirectionary contains the value specified within
            the first set.
            </summary>
            <param name="first"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.BiDirectionary`2.ContainsSecond(`1)">
            <summary>
            Determines whether this BiDirectionary contains the value specified within
            the second set.
            </summary>
            <param name="second"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Base.CopyAttribute">
            <summary>
            Attribute applied to types and fields to determine the correct procedure for dealing
            with them when automatically copying their values to another object.
            By default, fields are 'shallow-copied' - i.e. values and references are copied.
            It is only necessary to apply this attribute to fields where this behaviour should
            be changed.  Attributes applied to types define the defauly behaviour of that type,
            but field-level attributes will override this where present.
            </summary>
        </member>
        <member name="P:Nucleus.Base.CopyAttribute.Behaviour">
            <summary>
            The behaviour of the annotated field during a copy operation.
            By default, properties have their values 'shallow-copied', but may
            instead be prevented from being copied or be duplicated instead,
            provided the property type is duplicatable.
            </summary>
        </member>
        <member name="M:Nucleus.Base.CopyAttribute.#ctor(Nucleus.Base.CopyBehaviour)">
            <summary>
            Constructor.  Initialise this attribute with the specified copying
            behaviour.
            </summary>
            <param name="behaviour">The copying behaviour of this field.</param>
        </member>
        <member name="T:Nucleus.Base.CopyBehaviour">
            <summary>
            Enum used to describe the behaviour of a field during a
            data copying operation
            </summary>
        </member>
        <member name="F:Nucleus.Base.CopyBehaviour.COPY">
            <summary>
            Copy the value or reference assigned to the field
            - i.e. create a 'shallow' copy.  This is the default
            behaviour, you do not need to specify this value.
            </summary>
        </member>
        <member name="F:Nucleus.Base.CopyBehaviour.DO_NOT_COPY">
            <summary>
            The field should not be copied at all - the original
            value of the field should not be overwritten.
            Use when a field should survive a copy operation without
            being modified - for example the GUID of the object.
            </summary>
        </member>
        <member name="F:Nucleus.Base.CopyBehaviour.DUPLICATE">
            <summary>
            Duplicate the object assigned to this field, creating
            a 'deep copy'.  The object type of this field *must* itself
            implement the IDuplicatable interface in order for this
            value to be valid.
            </summary>
        </member>
        <member name="F:Nucleus.Base.CopyBehaviour.MAP">
            <summary>
            Map the reference assigned to this field to the duplication of
            that object created during this same copy operation.
            If no such object has been included in this duplication thus far,
            do not copy anything.  Use this when you have a back-reference
            to a parent object and want that reference to kept to the *new*
            parent when copied, unless the child object is being copied on
            its own and will not *have* a parent.
            </summary>
        </member>
        <member name="F:Nucleus.Base.CopyBehaviour.MAP_OR_COPY">
            <summary>
            Map the reference assigned to this field to the duplication of
            that object created during this same copy operation.
            If no such object has been included in this duplication thus far,
            copy the reference itself.
            </summary>
        </member>
        <member name="F:Nucleus.Base.CopyBehaviour.MAP_OR_DUPLICATE">
            <summary>
            Map the reference assigned to this field to the duplication of
            that object created during this same copy operation.
            If no such object has been included in this duplication thus far,
            create that duplicate.   The object type of this field *must* itself
            implement the IDuplicatable interface in order for this
            behaviour to be valid.
            </summary>
        </member>
        <member name="T:Nucleus.Base.EventBase">
            <summary>
            Reusable base class for objects that raise events.
            Provides a protected function which can be used to raise events safely.
            </summary>
        </member>
        <member name="M:Nucleus.Base.EventBase.RaiseEvent(System.EventHandler,System.EventArgs)">
            <summary>
            Raise an event.
            Checks for a null handler before raising.
            </summary>
            <param name="handler">The event handler</param>
            <param name="args">The event args</param>
        </member>
        <member name="M:Nucleus.Base.EventBase.RaiseEvent(System.EventHandler,System.Object,System.EventArgs)">
            <summary>
            Raise an event, passing through the original sender.
            Checks for a null handler before raising.
            Used to 'bubble' up events from sub-objects
            </summary>
            <param name="handler">The event handler</param>
            <param name="sender">The original sender object</param>
            <param name="args">The event args</param>
        </member>
        <member name="M:Nucleus.Base.EventBase.RaiseEvent``1(System.EventHandler{``0},``0)">
            <summary>
            Raise an event with a generic handler
            </summary>
            <typeparam name="TArgs">The type of the event arguments</typeparam>
            <param name="handler">The event handler</param>
            <param name="args">The event args</param>
        </member>
        <member name="T:Nucleus.Base.FilePath">
            <summary>
            A structure that represents a file path.
            Wraps a string path variable to provide additional
            file handling utility methods.  Essentially provides
            much of the same functionality as the System.IO.Path
            and File classes but in a non-static way that is 
            quicker to use and easier to bind to.
            Can be used interchangably with file paths stored
            as strings.
            </summary>
        </member>
        <member name="P:Nucleus.Base.FilePath.AppData">
            <summary>
            Get a filepath representing the path of the current AppData directory
            </summary>
        </member>
        <member name="P:Nucleus.Base.FilePath.Temp">
            <summary>
            Get a filepath representing the path of the user's Temp directory
            </summary>
        </member>
        <member name="P:Nucleus.Base.FilePath.Current">
            <summary>
            Get a filepath pointing to the current working directory.
            Will not include a trailing slash
            </summary>
        </member>
        <member name="P:Nucleus.Base.FilePath.LocalAppData">
            <summary>
            Get a filepath pointing to the local application data folder for the current user
            </summary>
        </member>
        <member name="F:Nucleus.Base.FilePath._Path">
            <summary>
            Private backing field for Path property
            </summary>
        </member>
        <member name="P:Nucleus.Base.FilePath.Path">
            <summary>
            The full string value of the filepath
            </summary>
        </member>
        <member name="P:Nucleus.Base.FilePath.IsValid">
            <summary>
            Is the path a valid file location?
            </summary>
        </member>
        <member name="P:Nucleus.Base.FilePath.IsSet">
            <summary>
            Is the path set?  (i.e. is it non-null?)
            </summary>
        </member>
        <member name="P:Nucleus.Base.FilePath.Extension">
            <summary>
            Gets the extension of this filepath.
            Includes the preceding '.'.
            </summary>
        </member>
        <member name="P:Nucleus.Base.FilePath.Exists">
            <summary>
            Does the file that this path points to exist?
            </summary>
        </member>
        <member name="P:Nucleus.Base.FilePath.FileName">
            <summary>
            Gets the name of the file at the end of the path,
            including its extension but not the preceding
            directory structure.
            </summary>
        </member>
        <member name="P:Nucleus.Base.FilePath.Directory">
            <summary>
            Gets the directory of the filepath
            </summary>
        </member>
        <member name="P:Nucleus.Base.FilePath.Shortened">
            <summary>
            Get this filepath shortened to 50 characters or less
            </summary>
        </member>
        <member name="P:Nucleus.Base.FilePath.Info">
            <summary>
            Get the fileInfo for the file represented by this path, if it exists
            If the file does not exist, returns null.
            </summary>
        </member>
        <member name="M:Nucleus.Base.FilePath.#ctor(System.String)">
            <summary>
            Path Constructor
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:Nucleus.Base.FilePath.ToString">
            <summary>
            ToString override
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.FilePath.GetHashCode">
            <summary>
            GetHashCode override
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.FilePath.TrimExtension">
            <summary>
            Returns a version of this FilePath with it's file extension trimmed off
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.FilePath.ChangeExtension(System.String)">
            <summary>
            Returns a version of this FilePath with the specified new extension
            </summary>
            <param name="newExtension">The extension to use.  If not preceded with a '.' one will be added automatically</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.FilePath.AddNameSuffix(System.String)">
            <summary>
            Returns a copy of this FilePath with a suffix appended to the filename, inserted between the
            file name and extension
            </summary>
            <param name="suffix">The suffix to add to the filename</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.FilePath.AddNameSuffix(System.String,System.String)">
            <summary>
            Returns a copy of this FilePath with a suffix appended to the filename, inserted between the
            file name and extension
            </summary>
            <param name="suffix">The suffix to add to the filename</param>
            <param name="newExtension">The new file extension.  If not preceded with a '.' one will be added automatically.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.FilePath.DirectoryOf(System.Reflection.Assembly)">
            <summary>
            Return the path of the directory within which the specified loaded assembly exists
            </summary>
            <param name="assembly"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.FilePath.op_Implicit(Nucleus.Base.FilePath)~System.String">
            <summary>
            Implicit to string conversion operator
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:Nucleus.Base.FilePath.op_Implicit(System.String)~Nucleus.Base.FilePath">
            <summary>
            Implicit from string conversion operator
            </summary>
            <param name="path"></param>
        </member>
        <member name="T:Nucleus.Base.FilePathCollection">
            <summary>
            A collection of file paths intended to store the collection of most recently opened files
            for an application
            </summary>
        </member>
        <member name="F:Nucleus.Base.FilePathCollection._MaximumStored">
            <summary>
            Private backing field for MaximumStored property.
            </summary>
        </member>
        <member name="P:Nucleus.Base.FilePathCollection.MaximumStored">
            <summary>
            The maximum number of files that will be retained within this collection.
            If set to zero the number stored is unlimited.
            </summary>
        </member>
        <member name="M:Nucleus.Base.FilePathCollection.#ctor">
            <summary>
            Initialise a new empty FilePathCollection with unlimited storage
            </summary>
        </member>
        <member name="M:Nucleus.Base.FilePathCollection.#ctor(System.Int32)">
            <summary>
            Initialise a new empty FilePathCollection 
            </summary>
            <param name="maximumStored"></param>
        </member>
        <member name="T:Nucleus.Base.IDeletable">
            <summary>
            Interface for objects which can be 'deleted'.
            Deleted objects will remain within the object model but be marked for
            deletion and removed at some future point, allowing them to be easily
            restored via 'Undeletion'
            </summary>
        </member>
        <member name="P:Nucleus.Base.IDeletable.IsDeleted">
            <summary>
            Get a boolean value indicating whether this object has been
            marked for deletion.  This flag indicates that the object should be
            ignored in any operation that acts only on the current state of the
            model and that it should be removed during the next cleanup sweep.
            </summary> 
        </member>
        <member name="M:Nucleus.Base.IDeletable.Delete">
            <summary>
            Delete this object.
            The object itself will not be immediately removed from the model
            but will instead be flagged for future removal and ignored wherever
            appropriate.
            </summary>
        </member>
        <member name="M:Nucleus.Base.IDeletable.Undelete">
            <summary>
            Undelete this object.
            If the deletion flag on this object is set it will be unset and
            the object restored.
            </summary>
        </member>
        <member name="T:Nucleus.Base.IDeletableExtensions">
            <summary>
            Extension methods to act on IDeletable objects and/or collections of same
            </summary>
        </member>
        <member name="M:Nucleus.Base.IDeletableExtensions.RemoveDeleted``1(System.Collections.Generic.IList{``0})">
            <summary>
            Remove all deleted objects from this list
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:Nucleus.Base.IDeletableExtensions.Undeleted``2(``0)">
            <summary>
            Extract the subset of objects from this collection that are not deleted,
            as a list.
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.IDeletableExtensions.Undeleted``1(System.Collections.Generic.IList{``0})">
            <summary>
            Extract the subset of objects from this collection that are not deleted,
            as a list.
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.IDeletableExtensions.UndeletedCount``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Get the number of objects in this collection which are not deleted
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.IDeletableExtensions.DeleteAll(System.Collections.Generic.IEnumerable{Nucleus.Base.IDeletable})">
            <summary>
            Delete all objects in this collection.
            The objects themselves will not be immediately removed from the model
            but will instead be flagged for future removal and ignored wherever
            appropriate.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:Nucleus.Base.IDeletableExtensions.UndeleteAll(System.Collections.Generic.IEnumerable{Nucleus.Base.IDeletable})">
            <summary>
            Undelete all objects in this collection.
            If the deletion flag on any object is set it will be unset and
            the object restored.
            </summary>
            <param name="list"></param>
        </member>
        <member name="T:Nucleus.Base.IDuplicatable">
            <summary>
            Interface for objects which can be duplicated.
            Objects implementing this interface automatically gain
            a 'Duplicate()' extension method which uses reflection
            to procedurally create a new object and populate its properties
            to create a duplicate of the original.
            Duplicating produces a shallow clone with the exception
            of property values which are expected to be unique per instance
            of the object, which will themselves be duplicated.  This is
            determined by tagging those properties with the CopyBehaviour
            attribute.
            </summary>
        </member>
        <member name="T:Nucleus.Base.IDuplicatableExtensions">
            <summary>
            Extension methods for the IDuplicatable interface
            </summary>
        </member>
        <member name="M:Nucleus.Base.IDuplicatableExtensions.Duplicate``1(``0,Nucleus.Base.CopyBehaviour)">
            <summary>
            Produce a duplicated copy of this object.
            Family references will be copied, save for those which
            are intended to be unique to this object, which will themselves
            be duplicated.
            This method uses reflection to walk through the full property tree
            of the object and copy property values automatically depending on
            the CopyBehaviour they are tagged with.
            This is convenient and comprehensive, but can be very slow - be wary of
            overusing it in performance-critical scenarios.
            </summary>
            <param name="itemsBehaviour">The duplication behaviour of items contained within
            this object, if this object is a collection</param>
            <returns>A duplicated copy of this object</returns>
        </member>
        <member name="M:Nucleus.Base.IDuplicatableExtensions.Duplicate``1(``0,System.Collections.Generic.Dictionary{System.Object,System.Object}@,Nucleus.Base.CopyBehaviour)">
            <summary>
            Produce a duplicated copy of this object.
            Family references will be copied, save for those which
            are intended to be unique to this object, which will themselves
            be duplicated.
            </summary>
            <param name="objectMap">The map of original objects to duplicated objects.</param>
            <returns>A duplicated copy of this object</returns>
        </member>
        <member name="M:Nucleus.Base.IDuplicatableExtensions.CopyPropertiesFrom(System.Object,System.Object)">
            <summary>
            Populate the properties of this object by copying them from equivalent public
            fields on another object.  The properties to be copied must share names and types
            in order to be successfully transferred.
            </summary>
            <param name="target"></param>
            <param name="source"></param>
        </member>
        <member name="M:Nucleus.Base.IDuplicatableExtensions.CopyFieldsFrom(System.Object,System.Object)">
            <summary>
            Popualate the fields of this object by copying them from equivelent fields on 
            another object.  The fields to be copied must share names and types in order to
            be successfully transferred.
            </summary>
            <param name="source">The object to copy fields from.</param>
        </member>
        <member name="M:Nucleus.Base.IDuplicatableExtensions.CopyFieldsFrom(System.Object,System.Object,System.Collections.Generic.Dictionary{System.Object,System.Object}@)">
            <summary>
            Populate the fields of this object by copying them from equivalent fields on 
            another object.  The fields to be copied must share names and types in order to
            be successfully transferred.
            The CopyAttribute will be used to determine the correct behaviour when copying fields
            accross - first on the field itself and then, if not set, on the type of the field.
            If neither of these is specified the default is to do a 'shallow' or reference-copy on all objects
            except for collection type, where the default is to not copy any fields *unless* they are
            specifically annotated.
            </summary>
            <param name="source">The object to copy fields from.</param>
            <param name="objectMap">A map of original objects to their copies.  Used when duplicating multiple
            objects at once to create links between them of the same relative relationships.</param>
        </member>
        <member name="M:Nucleus.Base.IDuplicatableExtensions.ValueToAssign(System.Object,Nucleus.Base.CopyBehaviour@,Nucleus.Base.CopyBehaviour,System.Collections.Generic.Dictionary{System.Object,System.Object}@)">
            <summary>
            Convert the value extracted from the source object into an equivalent value suitable
            to be assigned to the target property, based on the copying behaviour assigned
            </summary>
            <param name="value"></param>
            <param name="behaviour"></param>
            <param name="objectMap"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Base.INamed">
            <summary>
            Interface for objects which have a name
            </summary>
        </member>
        <member name="P:Nucleus.Base.INamed.Name">
            <summary>
            The name of this object
            </summary>
        </member>
        <member name="T:Nucleus.Base.IMutableNamed">
            <summary>
            Interface for objects which have a name that
            can be changed.
            </summary>
        </member>
        <member name="P:Nucleus.Base.IMutableNamed.Name">
            <summary>
            The name of this object
            </summary>
        </member>
        <member name="T:Nucleus.Base.INamedExtensions">
            <summary>
            Extension methods for INamed objects and collections thereof
            </summary>
        </member>
        <member name="M:Nucleus.Base.INamedExtensions.FindByName``1(System.Collections.Generic.IEnumerable{``0},System.String,``0)">
            <summary>
            Find an item in this collection by name.
            </summary>
            <typeparam name="TItem"></typeparam>
            <param name="collection"></param>
            <param name="name">The name of the item to find.  Not case sensitive.</param>
            <returns>The first encountered item in this collection with the given name.</returns>
        </member>
        <member name="M:Nucleus.Base.INamedExtensions.ToNames``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String)">
            <summary>
            Create a string which lists all of the names of the objects in this collection
            </summary>
            <typeparam name="TItem"></typeparam>
            <param name="collection"></param>
            <param name="separator"></param>
            <param name="nullReplacement"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.INamedExtensions.GetNamesList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Get a list of all of the names of the objects in this enumerable
            </summary>
            <typeparam name="TItem"></typeparam>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.INamedExtensions.NextAvailableName``1(System.Collections.Generic.IList{``0},System.String,``0,System.Boolean,System.Boolean)">
            <summary>
            Return the next version of this name with an attached numerical postfix that
            will be a unique name in this collection.
            </summary>
            <param name="list"></param>
            <param name="baseName">The base name</param>
            <param name="ignore">Optional.  If specified, this object will be ignored during the search.</param>
            <param name="enforcePostFix">Optional.  If set true, a postfix numeral will always be applied, even if it is 1.</param>
            <param name="includeSpace">Optional.  If true (default) a space will be inserted between the name and number</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Base.IOwned`1">
            <summary>
            Interface for objects which may be 'owned' by some specific other object.
            Note that while these objects are capable of being owned it does not follow
            that they always have an owner.
            </summary>
        </member>
        <member name="P:Nucleus.Base.IOwned`1.Owner">
            <summary>
            This oject that this object 'belongs' to, if any.
            </summary>
        </member>
        <member name="M:Nucleus.Base.IOwnedExtensions.RemoveUnowned``2(System.Collections.Generic.IList{``0})">
            <summary>
            Remove all objects from this list that do not have an owner
            </summary>
            <param name="list"></param>
        </member>
        <member name="T:Nucleus.Base.Named">
            <summary>
            Abstract base class for unique objects that can be named
            </summary>
        </member>
        <member name="F:Nucleus.Base.Named._Name">
            <summary>
            Private backing field for Name property
            </summary>
        </member>
        <member name="P:Nucleus.Base.Named.Name">
            <summary>
            The name, or mark, of this object
            </summary>
        </member>
        <member name="M:Nucleus.Base.Named.#ctor">
            <summary>
            Protected default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Base.Named.#ctor(Nucleus.Base.Named)">
            <summary>
            Protected duplication constructor
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Nucleus.Base.Named.#ctor(System.String)">
            <summary>
            Name constructor
            </summary>
            <param name="name"></param>
        </member>
        <member name="T:Nucleus.Base.NotifyPropertyChangedBase">
            <summary>
            Reusable base class that provides a basic implementation of the INotifyPropertyChanged interface.
            Raises a PropertyChanged event that is used to update bound WPF UI controls
            </summary>
        </member>
        <member name="E:Nucleus.Base.NotifyPropertyChangedBase.PropertyChanged">
            <summary>
            Event raised when a property of this object is changed
            </summary>
        </member>
        <member name="M:Nucleus.Base.NotifyPropertyChangedBase.NotifyPropertyChanged(System.String)">
            <summary>
            Raise a PropertyChanged event for the specified property name
            </summary>
            <param name="propertyName">The name of the property</param>
        </member>
        <member name="M:Nucleus.Base.NotifyPropertyChangedBase.NotifyPropertyChanged(System.String,System.Object,System.Object)">
            <summary>
            Raise a PropertyChanged event for the specified property name,
            utilising an extended version of the event arguments that includes the old
            and new values of the property.
            </summary>
            <param name="propertyName">The name of the property</param>
            <param name="oldValue">The original value of the property</param>
            <param name="newValue">The new value of the property</param>
        </member>
        <member name="M:Nucleus.Base.NotifyPropertyChangedBase.NotifyPropertyChanged(System.String@,System.Object@,System.Object@)">
            <summary>
            Raise a PropertyChanged event for the specified property name,
            utilising an extended version of the event arguments that includes the old
            and new values of the property.
            </summary>
            <param name="propertyName">The name of the property</param>
            <param name="oldValue">The original value of the property</param>
            <param name="newValue">The new value of the property</param>
        </member>
        <member name="M:Nucleus.Base.NotifyPropertyChangedBase.NotifyPropertiesChanged(System.String[])">
            <summary>
            Raise a PropertyChanged event for several property names at once.
            </summary>
            <param name="propertyNames">The name(s) of the changed property</param>
        </member>
        <member name="M:Nucleus.Base.NotifyPropertyChangedBase.RaiseEvent(System.ComponentModel.PropertyChangedEventHandler,System.ComponentModel.PropertyChangedEventArgs)">
            <summary>
            Raise an event.
            Checks for a null handler before raising.
            </summary>
            <param name="handler">The event handler</param>
            <param name="args">The event args</param>
        </member>
        <member name="M:Nucleus.Base.NotifyPropertyChangedBase.RaiseEvent(System.ComponentModel.PropertyChangedEventHandler,System.Object,System.ComponentModel.PropertyChangedEventArgs)">
            <summary>
            Raise an event, passing through the original sender.
            Checks for a null handler before raising.
            Used to 'bubble' up events from sub-objects
            </summary>
            <param name="handler">The event handler</param>
            <param name="sender">The original sender object</param>
            <param name="args">The event args</param>
        </member>
        <member name="M:Nucleus.Base.NotifyPropertyChangedBase.ChangeProperty``1(``0@,``0,System.String,System.Boolean)">
            <summary>
            Helper method to modify the backing field of a property and perform associated activities
            on a single line.
            In addition to updating the specified backing field a PropertyChanged event will be
            raised using the extended argument set that includes both previous and new values of
            the property.  This can be used as the basis for undo operations.
            </summary>
            <typeparam name="T">The type of the property</typeparam>
            <param name="backingField">The backing field to be changed</param>
            <param name="newValue">The new value to be assigned</param>
            <param name="propertyName">The name of the property.  If not specified the CallerMemberName will be used.</param>
            <param name="notifyIfSame">If false (default), a property changed notification will not be raised
            unless the old and new values of the property are not equal.  If true, it will be raised regardless.</param>
        </member>
        <member name="T:Nucleus.Base.ObservableKeyedCollection`2">
            <summary>
            Implementation of an observable version of KeyedCollection.
            Based (roughly) on the code from:
            http://geekswithblogs.net/NewThingsILearned/archive/2010/01/12/make-keyedcollectionlttkey-titemgt-to-work-properly-with-wpf-data-binding.aspx
            </summary>
            <typeparam name="TKey">The key type</typeparam>
            <typeparam name="TValue">The item type</typeparam>
        </member>
        <member name="E:Nucleus.Base.ObservableKeyedCollection`2.CollectionChanged">
            <summary>
            CollectionChanged event implementation - raised when the collection is changed
            </summary>
        </member>
        <member name="E:Nucleus.Base.ObservableKeyedCollection`2.PropertyChanged">
            <summary>
            Event raised when a property of this object is changed
            </summary>
        </member>
        <member name="F:Nucleus.Base.ObservableKeyedCollection`2._SuppressNotifyCollectionChanged">
            <summary>
            Boolean flag to temporarily suppress CollectionChanged event raising
            </summary>
        </member>
        <member name="M:Nucleus.Base.ObservableKeyedCollection`2.NotifyPropertyChanged(System.String)">
            <summary>
            Raise a PropertyChanged event for the specified property name
            </summary>
            <param name="propertyName"></param>
        </member>
        <member name="M:Nucleus.Base.ObservableKeyedCollection`2.RaiseEvent(System.Collections.Specialized.NotifyCollectionChangedEventHandler,System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            Raise an event
            </summary>
            <param name="handler"></param>
            <param name="args"></param>
        </member>
        <member name="M:Nucleus.Base.ObservableKeyedCollection`2.NotifyCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            Raise a CollectionChanged event, signalling that this collection has been modified.
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Nucleus.Base.ObservableKeyedCollection`2.NotifyCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedAction,`1,`1,System.Int32)">
            <summary>
            Raise a CollectionChanged event, signalling that this collection has been modified.
            </summary>
        </member>
        <member name="M:Nucleus.Base.ObservableKeyedCollection`2.NotifyCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedAction,`1,System.Int32)">
            <summary>
            Raise a CollectionChanged event, signalling that this collection has been modified.
            </summary>
        </member>
        <member name="M:Nucleus.Base.ObservableKeyedCollection`2.NotifyCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedAction,`1)">
            <summary>
            Raise a CollectionChanged event, signalling that this collection has been modified.
            </summary>
        </member>
        <member name="M:Nucleus.Base.ObservableKeyedCollection`2.NotifyCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedAction)">
            <summary>
            Raise a CollectionChanged event, signalling that this collection has been modified.
            </summary>
        </member>
        <member name="M:Nucleus.Base.ObservableKeyedCollection`2.NotifyCollectionChangedMultiItem(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            Raise a CollectionChanged event for multiple items at once.
            Includes a fix for WPF collectionviews throwing an exception when more than one item
            is added at once.
            See: http://geekswithblogs.net/NewThingsILearned/archive/2008/01/16/listcollectionviewcollectionview-doesnt-support-notifycollectionchanged-with-multiple-items.aspx
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Nucleus.Base.ObservableKeyedCollection`2.TryAdd(`1)">
            <summary>
            Attempt to add a new item to the end of this collection, first checking whether the collection already
            contains an item with the specified key (and aborting if so)
            </summary>
            <param name="item">The object to be added to the end of the collection</param>
            <returns>True if the item was successfully added, false if an equivalent key already existed and it was not</returns>
        </member>
        <member name="M:Nucleus.Base.ObservableKeyedCollection`2.AddRange``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Add a collection of items to the end of this collection
            </summary>
            <param name="items">The items to be added to the end of the collection</param>
        </member>
        <member name="M:Nucleus.Base.ObservableKeyedCollection`2.RemoveRange(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Remove multiple items from this collection
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:Nucleus.Base.ObservableKeyedCollection`2.TryAddRange(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Attempt to add a collection of items to the end of this collection,
            checking whether each item has a matching key before adding it.
            </summary>
            <param name="items">The items to be added to the end of the collection</param>
            <returns>The sub-set of the input items that was successfully added</returns>
        </member>
        <member name="M:Nucleus.Base.ObservableKeyedCollection`2.SetItem(System.Int32,`1)">
            <summary>
            Overrides SetItem to raise a collection changed event when called
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:Nucleus.Base.ObservableKeyedCollection`2.InsertItem(System.Int32,`1)">
            <summary>
            Overrides InsertItem to raise a collection changed event when called
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:Nucleus.Base.ObservableKeyedCollection`2.ClearItems">
            <summary>
            Overrides ClearItems to raise a collection changed event when called
            </summary>
        </member>
        <member name="M:Nucleus.Base.ObservableKeyedCollection`2.RemoveItem(System.Int32)">
            <summary>
            Overrides RemoveItem to raise a collection changed event when called
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Nucleus.Base.ObservableKeyedCollection`2.OnCollectionChanged">
            <summary>
            Protected function called when the collection is changed.
            Used by subclasses to synchronise cached data.
            </summary>
        </member>
        <member name="M:Nucleus.Base.ObservableKeyedCollection`2.CombinedValue``1(System.Func{`1,``0},``0,``0)">
            <summary>
            Retrieve the combined value of a member of all items in this collection,
            expressed as a lambda function.  If the value of that member is consistent across all items
            in this collection then that value will be returned, else the specified value will be returned
            to indicate multiple values.
            </summary>
            <param name="propertyDelegate">A lambda function that returns a particular property for each item in the selection</param>
            <param name="multiValue">The value that should be returned to indicate multiple inconsistent values</param>
            <param name="nullValue">The value that should be returned if there are no items in this collection</param>
            <returns>The consistent value that is shared between all items, if that is the case, else the input multiValue</returns>
        </member>
        <member name="M:Nucleus.Base.ObservableKeyedCollection`2.MoveToLast(`0)">
            <summary>
            Move the item with the specified key to the last position in the collection
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Nucleus.Base.ObservableKeyedCollection`2.Replace(`1)">
            <summary>
            Replace the object in this collection with the same key, at the position of the original.
            If no object with the same key exists, the specified value will be added to the end of the list.
            </summary>
            <param name="item"></param>
        </member>
        <member name="T:Nucleus.Base.OwnedCollection`2">
            <summary>
            A collection of unique objects which may be owned
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TOwner"></typeparam>
        </member>
        <member name="F:Nucleus.Base.OwnedCollection`2._Owner">
            <summary>
            Private backing member variable for the Owner property
            </summary>
        </member>
        <member name="P:Nucleus.Base.OwnedCollection`2.Owner">
            <summary>
            The owning geometry of this vertex collection
            </summary>
        </member>
        <member name="M:Nucleus.Base.OwnedCollection`2.#ctor">
            <summary>
            Default constructor.  Initialises a collection with no owner.
            </summary>
        </member>
        <member name="M:Nucleus.Base.OwnedCollection`2.#ctor(`1)">
            <summary>
            Owner constructor.
            </summary>
            <param name="owner">The object which owns this collection</param>
        </member>
        <member name="M:Nucleus.Base.OwnedCollection`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            Collection combination constructor
            </summary>
            <param name="toBeCombined"></param>
        </member>
        <member name="M:Nucleus.Base.OwnedCollection`2.SetItem(System.Int32,`0)">
            <summary>
            Overrides SetItem to set item owner
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:Nucleus.Base.OwnedCollection`2.InsertItem(System.Int32,`0)">
            <summary>
            Overrides InsertItem to set item owner
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:Nucleus.Base.OwnedCollection`2.RemoveItem(System.Int32)">
            <summary>
            Overrides RemoveItem to clear item owner
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Nucleus.Base.OwnedCollection`2.ClearItems">
            <summary>
            Overrides ClearItems to clear items owner
            </summary>
        </member>
        <member name="M:Nucleus.Base.OwnedCollection`2.SetItemOwner(`0)">
            <summary>
            Set the owner of the specified item
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Nucleus.Base.OwnedCollection`2.ClearItemOwner(`0)">
            <summary>
            Clear the owner of the specified item
            </summary>
            <param name="item"></param>
        </member>
        <member name="T:Nucleus.Base.TypeCollection">
            <summary>
            A keyed collection of types.
            </summary>
        </member>
        <member name="M:Nucleus.Base.TypeCollection.ClosestAncestor(System.Type)">
            <summary>
            Find the type in this set of types which is the least number of
            inheritance levels above the specified type.
            </summary>
            <param name="forType">The type to seach for</param>
            <returns>The type in this collection that is closest in the inheritance
            hierarchy to the specified type.  Or, null if the type does not have an
            ancestor in the collection.</returns>
        </member>
        <member name="T:Nucleus.Base.Document">
            <summary>
            Abstract base class for documents -
            objects which store persistent data and allow it to
            be loaded and saved to files.
            </summary>
        </member>
        <member name="F:Nucleus.Base.Document._FilePath">
            <summary>
            Private backing field for the FilePath property
            </summary>
        </member>
        <member name="P:Nucleus.Base.Document.FilePath">
            <summary>
            The filepath to which the document was last saved
            </summary>
        </member>
        <member name="F:Nucleus.Base.Document._LastSaved">
            <summary>
            Private backing field for LastSaved property
            </summary>
        </member>
        <member name="P:Nucleus.Base.Document.LastSaved">
            <summary>
            The time and date that this document was last saved.
            </summary>
        </member>
        <member name="M:Nucleus.Base.Document.Save">
            <summary>
            Save this document to the last-saved location, if possible,
            in binary format.
            </summary>
            <returns>True if the file was successfully saved, else false</returns>
        </member>
        <member name="M:Nucleus.Base.Document.SaveAs(Nucleus.Base.FilePath,Nucleus.IO.DocumentSaveFileType)">
            <summary>
            Save this document to the specified location
            in binary format.
            </summary>
            <param name="filePath">The filepath to save the document to</param>
            <returns>True if the file was successfully saved, else false</returns>
        </member>
        <member name="M:Nucleus.Base.Document.SaveAs``1(Nucleus.Base.FilePath,Nucleus.IO.DocumentTextSerialiser{``0})">
            <summary>
            Save this document to the specified location
            in text format via the specified customisable text serialiser
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filePath"></param>
            <param name="textSerialiser"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.Document.ToBinary">
            <summary>
            Serialise this object to a Base64 Binary String
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Base.Document.Load``1(Nucleus.Base.FilePath,Nucleus.IO.DocumentSaveFileType)">
            <summary>
            Load a document from a file stored in binary format
            </summary>
            <param name="filePath">The path of the file to be loaded.</param>
            <returns>The loaded document, if a document could indeed be loaded.
            Else, null.</returns>
        </member>
        <member name="M:Nucleus.Base.Document.FromBinary``1(System.Byte[])">
            <summary>
            Deserialize a document of the specified type from binary data
            </summary>
            <typeparam name="T"></typeparam>
            <param name="binaryData">The binary data to deserialize</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Base.IUnique">
            <summary>
            Interface for entities which are uniquely identifiable via a GUID
            </summary>
        </member>
        <member name="P:Nucleus.Base.IUnique.GUID">
            <summary>
            The GUID of this object, which can be used to uniquely identify it 
            </summary>
        </member>
        <member name="T:Nucleus.Base.Unique">
            <summary>
            Abstract base class implementing the IUnique interface
            Unique objects are uniquely identifiable via a GUID
            </summary>
        </member>
        <member name="F:Nucleus.Base.Unique._GUID">
            <summary>
            Private backing field for GUID property
            </summary>
        </member>
        <member name="P:Nucleus.Base.Unique.GUID">
            <summary>
            The GUID of this object, which can be used to uniquely identify it. 
            </summary>
        </member>
        <member name="T:Nucleus.Base.UniquesCollection`1">
            <summary>
            A collection of objects implementing the IUnique interface
            Each item must be unique within this collection - duplicate entries are not allowed.
            </summary>
            <typeparam name="TItem">The type of uniquely identifiable item</typeparam>
        </member>
        <member name="M:Nucleus.Base.UniquesCollection`1.TryGet(System.Guid)">
            <summary>
            Try to get a unique item stored by the specified key GUID.
            If no entry with that key is stored, this function will return null.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Base.UniquesCollection">
            <summary>
            A collection of unique objects.
            </summary>
        </member>
        <member name="T:Nucleus.Debugging.CollectionDebugView`1">
            <summary>
            A collection debug view to present collection items in 
            the debug inspector.
            Based on https://www.codeproject.com/Articles/28405/Make-the-debugger-show-the-contents-of-your-custom
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Nucleus.Extensions.AssemblyExtensions">
            <summary>
            Extension methods for the Assembly class
            </summary>
        </member>
        <member name="M:Nucleus.Extensions.AssemblyExtensions.GetUnserializableTypes(System.Reflection.Assembly)">
            <summary>
            Get a list of all non-static types in this assembly which have not been tagged
            with the [Serializable] attribute.
            </summary>
            <param name="assembly"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Extensions.RandomExtensions">
            <summary>
            Extension methods for 
            </summary>
        </member>
        <member name="M:Nucleus.Extensions.RandomExtensions.NextDouble(System.Random,System.Double)">
            <summary>
            Returns a random floating-point number between 0 and maxValue
            </summary>
            <param name="rng"></param>
            <param name="maxValue">The maximum extent of the random range</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.RandomExtensions.NextDouble(System.Random,System.Double,System.Double)">
            <summary>
            Returns a random floating-point number between minValue and maxValue
            </summary>
            <param name="rng"></param>
            <param name="minValue">The minimum extent of the random range</param>
            <param name="maxValue">The maximum extent of the random range</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.RandomExtensions.NextDoubleNear(System.Random,System.Double,System.Double)">
            <summary>
            Returns a random floating-point number within range of origin.
            </summary>
            <param name="rng"></param>
            <param name="origin">The number to generate close to</param>
            <param name="range">The difference either side of origin that gives
            the acceptable range.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.RandomExtensions.NextAngle(System.Random)">
            <summary>
            Returns a random angle between 0 and 2*PI radians
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.RandomExtensions.NextPoint(System.Random,Nucleus.Geometry.BoundingBox)">
            <summary>
            Generate a random point within the specified bounding box
            </summary>
            <param name="rng"></param>
            <param name="bounds">The bounding box within which the point
            is to be generated.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.RandomExtensions.NextPoint(System.Random,Nucleus.Geometry.Vector,System.Double)">
            <summary>
            Generate a random point within the specified range of the given origin
            point.
            </summary>
            <param name="rng"></param>
            <param name="origin"></param>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Extensions.CharExtensions">
            <summary>
            Extension methods for the standard Character type
            </summary>
        </member>
        <member name="M:Nucleus.Extensions.CharExtensions.EqualsIgnoreCase(System.Char,System.Char)">
            <summary>
            Is this char equal to another, ignoring the case of the character
            </summary>
            <param name="c"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Extensions.BoolExtensions">
            <summary>
            Extension methods for bool and bool? types
            </summary>
        </member>
        <member name="M:Nucleus.Extensions.BoolExtensions.ToBool(System.Nullable{System.Boolean})">
            <summary>
            Convert this nullable bool to a plain old
            bool.  If it does not have a value, that will be
            treated as false.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Extensions.EventHandlerExtensions">
            <summary>
            Extension methods for the EventHandler class
            </summary>
        </member>
        <member name="M:Nucleus.Extensions.EventHandlerExtensions.Raise(System.EventHandler,System.Object,System.EventArgs)">
            <summary>
            Raise an event.
            Checks for a null handler before raising.
            </summary>
            <param name="handler">The event handler</param>
            <param name="sender">The original sender object</param>
            <param name="args">The event args</param>
        </member>
        <member name="M:Nucleus.Extensions.EventHandlerExtensions.Raise``1(System.EventHandler{``0},System.Object,``0)">
            <summary>
            Raise an event with a generic handler.
            Checks for a null handler before raising.
            </summary>
            <typeparam name="TArgs">The type of the event arguments</typeparam>
            <param name="handler">The event handler</param>
            <param name="args">The event args</param>
        </member>
        <member name="M:Nucleus.Extensions.MemberInfoExtensions.GetAttribute``1(System.Reflection.MemberInfo)">
            <summary>
            Retrieves a custom attribute applied to this member
            </summary>
            <typeparam name="TAttribute">The type of attribute to retrieve</typeparam>
            <param name="memberInfo"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Extensions.NotifyCollectionChangedEventArgsExtensions">
            <summary>
            Static extension methods for the NotifyCollectionChangedEventArgs class
            </summary>
        </member>
        <member name="M:Nucleus.Extensions.NotifyCollectionChangedEventArgsExtensions.Reverse(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            Invert these arguments to represent the opposite action
            </summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Extensions.IDictionaryExtensions">
            <summary>
            Extension methods for the IDictionary interface
            </summary>
        </member>
        <member name="M:Nucleus.Extensions.IDictionaryExtensions.KeyRange``1(System.Collections.Generic.IDictionary{System.Double,``0})">
            <summary>
            Get the range of keys in this dictionary
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="dictionary"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Extensions.IEnumerableExtensions">
            <summary>
            Extension methods for IEnumerable objects
            </summary>
        </member>
        <member name="M:Nucleus.Extensions.IEnumerableExtensions.ContainedTypes``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Get a collection of all the unique types currently contained within this collection
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.IEnumerableExtensions.ContainsOnlyType(System.Collections.IEnumerable,System.Type)">
            <summary>
            Does this enumerable contain only items of the specified type, or types
            which inherit from it?
            </summary>
            <param name="collection"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.IEnumerableExtensions.CombinedValue``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},``1,``1)">
            <summary>
            Retrieve the combined value of a member of all items in this collection,
            expressed as a lambda function.  If the value of that member is consistent across all items
            in this collection then that value will be returned, else the specified value will be returned
            to indicate multiple values.
            </summary>
            <param name="propertyDelegate">A lambda function that returns a particular property for each item in the selection</param>
            <param name="multiValue">The value that should be returned to indicate multiple inconsistent values</param>
            <param name="nullValue">The value that should be returned if there are no items in this collection</param>
            <returns>The consistent value that is shared between all items, if that is the case, else the input multiValue</returns>
        </member>
        <member name="M:Nucleus.Extensions.IListExtensions.GetBounded``1(System.Collections.Generic.IList{``0},System.Int32,System.Boolean)">
            <summary>
            Get the item at the specified index, automatically limiting
            the index to the bounds of the list.  Entering an index less than
            zero will return the first item.  Entering an index greater than the
            size of the array will return the last item.
            Optionally, the indexing may be reversed.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="index">The index.  Will be bounded to the list domain.</param>
            <param name="reverse">Optional.  If true the indexing will be reversed.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.IListExtensions.GetOrDefault``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Get the item at the specified index, or the default value
            of the relevant type if the index is outside the bounds of the array.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.IListExtensions.GetWrapped``1(System.Collections.Generic.IList{``0},System.Int32,System.Boolean)">
            <summary>
            Get the item at the specified index, automatically wrapping if it is outside the
            bounds of the collection.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="index"></param>
            <param name="wrap">Wrapping toggle - if false the wrapping will not occur and the list
            will be accessed normally.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.IListExtensions.FromEnd``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Get the item the specified number of places from the end of this
            list.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.IListExtensions.RemoveDuplicates``1(System.Collections.Generic.IList{``0})">
            <summary>
            Remove duplicate objects from this collection, leaving
            the first discovered
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Nucleus.Extensions.IListExtensions.RemoveAllDuplicates``1(System.Collections.Generic.IList{``0})">
            <summary>
            Remove *all* duplicate objects from this collection, including
            the first instance discovered.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Nucleus.Extensions.IListExtensions.AllBetween``1(System.Collections.Generic.IList{``0},System.Double,System.Double)">
            <summary>
            Return the sub-list of all items in this list between the two specified index parameters.
            If the end value is lower than the start value, the item selection will wrap.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="start">The start of the index range to extract</param>
            <param name="end">The end of the index range to extract</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.IListExtensions.LastIndex``1(System.Collections.Generic.IList{``0})">
            <summary>
            Get the index of the last item in the list
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.IListExtensions.RemoveLast``1(System.Collections.Generic.IList{``0})">
            <summary>
            Remove the last item in this list, for
            safety checking first whether there are any items within
            the list.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Nucleus.Extensions.IListExtensions.RemoveFirst``1(System.Collections.Generic.IList{``0})">
            <summary>
            Remove the first item in this list,
            for safety checking first whether there are any items to remove.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Nucleus.Extensions.IListExtensions.SubListFrom``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Get the sublist containing the item at the specified index and
            every subsequent item
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.IListExtensions.MaxDelegateValue``2(System.Collections.Generic.IList{``0},System.Func{``0,``1})">
            <summary>
            Find the maximum value of a property or method on the items in this list
            </summary>
            <typeparam name="TItem">The type of item in the list</typeparam>
            <typeparam name="TProperty">The type of the property to be interrogated</typeparam>
            <param name="list"></param>
            <param name="propertyDelegate">Delegate function which returns the value of the property
            for each item in this list.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.IListExtensions.MinDelegateValue``2(System.Collections.Generic.IList{``0},System.Func{``0,``1})">
            <summary>
            Find the minimum value of a property or method on the items in this list
            </summary>
            <typeparam name="TItem">The type of item in the list</typeparam>
            <typeparam name="TProperty">The type of the property to be interrogated</typeparam>
            <param name="list"></param>
            <param name="propertyDelegate">Delegate function which returns the value
            for each list item.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.IListExtensions.AverageDelegateValue``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Double})">
            <summary>
            Find the average of a set of double values obtainable via a delegate function from the items
            in this list.
            </summary>
            <typeparam name="TItem">The type of item in this list.</typeparam>
            <param name="list"></param>
            <param name="valueDelegate">Delegate function which returns the value to be averaged for each list item.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.IListExtensions.TotalDelegateValue``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Double})">
            <summary>
            Find the total of a set of double values obtainable via a delegate function from the
            items in this list.
            </summary>
            <typeparam name="TItem"></typeparam>
            <param name="list"></param>
            <param name="valueDelegate">Delegate function which returns the value to the summed.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.IListExtensions.GetSafe``1(System.Collections.Generic.IList{System.Collections.Generic.IList{``0}},System.Int32,System.Int32,``0)">
            <summary>
            Get a value from this 2-dimensional jagged list, returning a fallback value in the case that the specified indices are
            out-of bounds
            </summary>
            <typeparam name="TItem"></typeparam>
            <param name="lists"></param>
            <param name="i">The index in the outer list</param>
            <param name="j">The index in the inner list</param>
            <param name="fallback">The value to be returned when the specified index doesn't exist in this dataset</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.IListExtensions.GetRandom``1(System.Collections.Generic.IList{``0},System.Random)">
            <summary>
            Get a random item from this list.
            </summary>
            <typeparam name="TItem"></typeparam>
            <param name="list"></param>
            <param name="rng">The random number generator to use to determine the item to be selected</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.IListExtensions.SetAutoExtend``1(System.Collections.Generic.IList{``0},System.Int32,``0)">
            <summary>
            Set the value at the specified index if the list is long enough or if it is not
            extend the list up to that length, populating intervening indices with the
            default value of the appropriate type.
            </summary>
            <typeparam name="TItem"></typeparam>
            <param name="list"></param>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="T:Nucleus.Extensions.IntExtensions">
            <summary>
            Extension methods for integers
            </summary>
        </member>
        <member name="M:Nucleus.Extensions.IntExtensions.IsEven(System.Int32)">
            <summary>
            Is this integer even?
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.IntExtensions.IsOdd(System.Int32)">
            <summary>
            Is this integer odd?
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.IntExtensions.Digits(System.Int32)">
            <summary>
            Get the number of digits used in the decimal representation
            of this integer.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.IntExtensions.Abs(System.Int32)">
            <summary>
            Get the absolute value of this integer
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nucleus.Extensions.IntExtensions.InRange(System.Int32,System.Int32,System.Int32)" -->
        <member name="M:Nucleus.Extensions.IntExtensions.Exceeded(System.Int32,System.Int32,System.Int32)">
            <summary>
            Has this integer value exceeded a limit.  The condition to test may
            optionally be controlled by specifying the sign of the increment -
            if positive will return true if the value is higher than the limit,
            if negative will return true if the value is lower.
            </summary>
            <param name="value"></param>
            <param name="limit"></param>
            <param name="sign"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.IntExtensions.ClosestIndexBelow(System.Collections.Generic.IList{System.Int32},System.Int32)">
            <summary>
            Find and return the index of the value in this list closest
            but lower than the specified value
            </summary>
            <param name="list"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Extensions.ObjectExtensions">
            <summary>
            Static extension methods on any object type
            </summary>
        </member>
        <member name="M:Nucleus.Extensions.ObjectExtensions.SetByPath(System.Object,System.String,System.Object,Nucleus.Conversion.IStringConversionContext)">
            <summary>
            Set the value of a property on this object at the specified path
            </summary>
            <param name="obj"></param>
            <param name="path">The path, consisting of property names and sub-property names
            separated by '.' characters.  For example: 'PropertyName.SubPropertyName.SubSubPropertyName' etc.
            Parameterless methods may also be invoked by adding '()', i.e.:
            'PropertyName.SubMethodName().SubSubPropertyName'.
            Methods and properties on the optional context object may also be invoked in the same way, via a
            '*' redirection.  For example: '*.MethodName()'.  When switching to the context
            object the SetSourceObject method on it will be called and the current object or property value
            passed in.  This allows for complex operations to be performed in order to return a value
            provided that functionality is implemented in a suitable context object provided.</param>
            <param name="value">The value to be assigned to the property</param>
            <param name="context">The (optional) string conversion context object.  If supplies this allows
            the '*' symbol to be used within property paths in order to access properties and
            functions supplied on the context object.</param>
        </member>
        <member name="M:Nucleus.Extensions.ObjectExtensions.GenerateBindingChain(System.Object,System.String)">
            <summary>
            Generate a binding chain for the specified path on this object.
            A binding chain is a list of all objects in the chain which implement the
            INotifyPropertyChanged interface accompanied by the name of the property
            on that object which, when changed, will require the bindings of objects 
            further down the chain to be refreshed.
            </summary>
            <param name="obj"></param>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.ObjectExtensions.GetFromPath(System.Object,System.String,Nucleus.Conversion.IStringConversionContext)">
            <summary>
            Get the value of a property on this object at the specified path
            </summary>
            <param name="obj"></param>
            <param name="path">The path, consisting of property names and sub-property names
            separated by '.' characters.  For example: 'PropertyName.SubPropertyName.SubSubPropertyName' etc.
            Parameterless methods may also be invoked by adding '()', i.e.:
            'PropertyName.SubMethodName().SubSubPropertyName'.
            Methods and properties on the optional context object may also be invoked in the same way, via a
            '*' redirection.  For example: '*.MethodName()'.  When switching to the context
            object the SetSourceObject method on it will be called and the current object or property value
            passed in.  This allows for complex operations to be performed in order to return a value
            provided that functionality is implemented in a suitable context object provided.</param>
            <param name="context">The (optional) string conversion context object.  If supplies this allows
            the '*' symbol to be used within property paths in order to access properties and
            functions supplied on the context object.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.ObjectExtensions.ToString(System.Object,System.String,System.Char,System.Char,System.String,System.String,Nucleus.Conversion.IStringConversionContext)">
            <summary>
            Convert this object to a string in the specified format.
            </summary>
            <param name="obj"></param>
            <param name="format">The format to be used to construct the text string.
            This should take the form of a string interspersed with property paths surrounded by
            open and close tag characters, the values of which will be inserted into the text.
            For example "The value of the subproperty is: {PropertyName.SubPropertyName}"</param>
            <param name="openTag">The opening tag for specifying property paths.  Default is '{'.</param>
            <param name="closeTag">The closing tag for specifying property paths.  Default is '}'.</param>
            <param name="context">The (optional) string conversion context object.  If supplies this allows
            the '*' symbol to be used within property paths in order to access properties and
            functions supplied on the context object.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.ObjectExtensions.CreateFormattedString(System.Object,System.String,System.Char,System.Char,System.String,System.String,Nucleus.Conversion.IStringConversionContext,System.Text.StringBuilder,System.Text.StringBuilder)">
            <summary>
            Generate a formatted string which represents the object or a subcomponent of it
            </summary>
            <param name="obj"></param>
            <param name="format"></param>
            <param name="openTag"></param>
            <param name="closeTag"></param>
            <param name="context"></param>
            <param name="resultBuilder"></param>
            <param name="pathBuilder"></param>
        </member>
        <member name="T:Nucleus.Extensions.PropertyInfoExtensions">
            <summary>
            Extension methods for PropertyInfo objects
            </summary>
        </member>
        <member name="M:Nucleus.Extensions.PropertyInfoExtensions.HasAttribute(System.Reflection.PropertyInfo,System.Type)">
            <summary>
            Does this property have an attribute of the specified type?
            </summary>
            <param name="property"></param>
            <param name="attributeType"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.PropertyInfoExtensions.GetCustomAttribute``1(System.Reflection.PropertyInfo)">
            <summary>
            Retrieves a custom attribute applied to this property
            </summary>
            <typeparam name="TAttribute">The type of attribute to retrieve</typeparam>
            <param name="propertyInfo"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.PropertyInfoExtensions.GetCustomAttribute(System.Reflection.PropertyInfo,System.Type)">
            <summary>
            Retrieves a custom attribute applied to this property
            </summary>
            <typeparam name="TAttribute">The type of attribute to retrieve</typeparam>
            <param name="propertyInfo"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Extensions.SortedListExtensions">
            <summary>
            Extension functions for the SortedList standard type
            </summary>
        </member>
        <member name="M:Nucleus.Extensions.SortedListExtensions.InterpolatedValueAt``1(System.Collections.Generic.SortedList{System.Double,``0},System.Double,Nucleus.Maths.Interpolation,System.Func{``0,``0,System.Double,Nucleus.Maths.Interpolation,``0})">
            <summary>
            Determine a value at a specified key, even if an object with that key is not explicitly a
            member of this list, interpolating between values as necessary.  Note that the datatype
            held within this list must be interpolatable (i.e. it must implement an override of the '+',
            '-' and '*' operators) or else you're gonna have a bad time.
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="list"></param>
            <param name="key">The key value for which to retrieve or interpolate a value</param>
            <param name="tweening">The tweening algorithm to be used for the interpolation.</param>
            <param name="interpolationFunction">A custom interpolation function to use for non-standard datatypes</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.SortedListExtensions.NextAfter``2(System.Collections.Generic.SortedList{``0,``1},``0,``0@,System.Boolean)">
            <summary>
            Get the stored value with the key after the specified key value.
            Returns the first item in this list with a key that compared greater than
            that specified.  If none can be found, returns null.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="list"></param>
            <param name="key">The key value to search for</param>
            <param name="nextKey">OUTPUT.  The key of the next value.</param>
            <param name="wrap">If true, the list is treated as wrapping - i.e. if no item with a key greater
            than that specified can be found the first item will be returned instead.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.SortedListExtensions.NextAfter``2(System.Collections.Generic.SortedList{``0,``1},``0,System.Boolean)">
            <summary>
            Get the stored value with the key after the specified key value.
            Returns the first item in this list with a key that compared greater than
            that specified.  If none can be found, returns null.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="list"></param>
            <param name="key">The key value to search for</param>
            <param name="wrap">If true, the list is treated as wrapping - i.e. if no item with a key greater
            than that specified can be found the first item will be returned instead.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.SortedListExtensions.LastBefore``2(System.Collections.Generic.SortedList{``0,``1},``0,``0@,System.Boolean)">
            <summary>
            Get the stored value with the key before the specified key value.
            Returns the last item in this list with a key that compared lower than
            that specified.  If none can be found, returns null.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="list"></param>
            <param name="key">The key value to search for</param>
            <param name="lastKey">OUTPUT. The last key before the specified key.</param>
            <param name="wrap">If true, the list is treated as wrapping - i.e. if no item with a key lower
            than that specified can be found the last item will be returned instead.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.SortedListExtensions.LastBefore``2(System.Collections.Generic.SortedList{``0,``1},``0,System.Boolean)">
            <summary>
            Get the stored value with the key before the specified key value.
            Returns the last item in this list with a key that compared lower than
            that specified.  If none can be found, returns null.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="list"></param>
            <param name="key">The key value to search for</param>
            <param name="wrap">If true, the list is treated as wrapping - i.e. if no item with a key lower
            than that specified can be found the last item will be returned instead.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.SortedListExtensions.AddSafe``1(System.Collections.Generic.SortedList{System.Double,``0},System.Double,``0)">
            <summary>
            Adds an element with the specified key and value into the SortedList,
            automatically dealing with the case where the specified key already exists
            within the list by incrementing the key to the next valid value.
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="list"></param>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="T:Nucleus.Extensions.StringBuilderExtensions">
            <summary>
            Extension methods for the StringBuilderClass
            </summary>
        </member>
        <member name="M:Nucleus.Extensions.StringBuilderExtensions.Append(System.Text.StringBuilder,System.String,System.String)">
            <summary>
            Appends a copy of the specified string value to this instance,
            preceding it with the specified separator character if something has
            already been appended to this StringBuilder.
            </summary>
            <param name="sb"></param>
            <param name="value"></param>
            <param name="separator"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Extensions.DoubleExtensions">
            <summary>
            Extension methods for doubles
            </summary>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.Equals(System.Double,System.Double,System.Double)">
            <summary>
            Test for approximate equality between this double and another
            </summary>
            <param name="a">The first number</param>
            <param name="b">The number to check against</param>
            <param name="epsilon">The accuracy tolerance.  Values within this range of b will be treated as equal.</param>
            <returns>True if this value is within epsilon of b, else false</returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.Sign(System.Double)">
            <summary>
            Gets the sign of the double, expressed as +1 for positive numbers
            and -1 for negative ones.  Zero is treated as being positive in this
            instance.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.MatchSign(System.Double,System.Double)">
            <summary>
            Returns the magnitude of this double with a sign matching the specified value
            </summary>
            <param name="value"></param>
            <param name="toThis"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.Power(System.Double,System.Double)">
            <summary>
            Raise this number to a power.
            Shortcut for Math.Pow(x,y)
            </summary>
            <param name="value"></param>
            <param name="power">The exponent to raise this number to</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.Power(System.Double,System.Int32)">
            <summary>
            Raise this number to an integer power.
            Should be faster than Math.Pow because it does not
            need to deal with the general case.
            </summary>
            <param name="value"></param>
            <param name="power">The exponent to raise this number to</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.Squared(System.Double)">
            <summary>
            Multiply this number by itself
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.Root(System.Double)">
            <summary>
            Calculate the square root of this number
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.Abs(System.Double)">
            <summary>
            Return the absolute (i.e. unsigned) value of this number
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.Round(System.Double,System.Double)">
            <summary>
            Round this double to the nearest whole increment
            </summary>
            <param name="value"></param>
            <param name="increment"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.Ceiling(System.Double)">
            <summary>
            Returns the smallest integral value which is greater than or equal to this number
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.Floor(System.Double)">
            <summary>
            Returns the largest integer value which is lower than or equal to this number
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.Limit(System.Double,System.Double,System.Double)">
            <summary>
            Limit this double to the specified range.
            Returns the value if it lies within the range, or the
            minimum or maximum limit if it falls outside that range
            </summary>
            <param name="value"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.InRange(System.Double,System.Double,System.Double)">
            <summary>
            Is this value within the specified range?
            i.e. is it greater than min and lower than max
            </summary>
            <param name="value"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.InRangeInclusive(System.Double,System.Double,System.Double)">
            <summary>
            Is this value within the specified range?
            i.e. is it >= min and =&lt; max
            </summary>
            <param name="value"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.IsTiny(System.Double)">
            <summary>
            Is this number really small?
            (-0.00000001 > value > 0.00000001)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.IsNaN(System.Double)">
            <summary>
            Is this Not A Number?
            </summary>
            <param name="value"></param>
            <returns></returns>
            <remarks>Same as double.IsNaN(double) but less typing!</remarks>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.InterlockedAdd(System.Double@,System.Double)">
            <summary>
            Utility function to add one double to another in a thread-safe way.
            Equivalent to toBeModified += value, and similar to the Interlocked.Add()
            function for integers.
            </summary>
            <param name="toBeModified"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.NextValidValue(System.Double)">
            <summary>
            Increment this number by the smallest step that will produce a differentiable
            floating point number greater than this one
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.Interpolate(System.Double,System.Double,System.Double)">
            <summary>
            Interpolate between this value and another
            </summary>
            <param name="value"></param>
            <param name="towards">The value to interpolate towards</param>
            <param name="factor">The interpolation factor. 0 = this value, 1 = the 'towards' value</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.Interpolate(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Interpolate between this value and another
            </summary>
            <param name="v0"></param>
            <param name="v1">The value to be interpolated towards</param>
            <param name="x0">The key value mapped to this value</param>
            <param name="x1">The key value mapped to the other value</param>
            <param name="x">The key value at the position to be interpolated</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.Remap(System.Double,Nucleus.Maths.Interval,Nucleus.Maths.Interval)">
            <summary>
            Remap this number from it's relative position in one interval to the same relative
            position in another.
            </summary>
            <param name="value"></param>
            <param name="fromThis"></param>
            <param name="toThis"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.RoundToSignificantFigures(System.Double,System.Int32)">
            <summary>
            Round this number to the specified number of significant figures
            </summary>
            <param name="value"></param>
            <param name="digits"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.Mean(System.Collections.Generic.IList{System.Double})">
            <summary>
            Calculate the arithmetic mean of the values in this list
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.StandardDeviation(System.Collections.Generic.IList{System.Double})">
            <summary>
            Calculate the standard deviation - the root of the average
            squared distance from the mean of the values in this list.
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.WrapTo(System.Double,Nucleus.Maths.Interval)">
            <summary>
            Wrap this value until it falls into the specified interval
            </summary>
            <param name="value"></param>
            <param name="interval">The interval to wrap to.  Size should be > 0.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.MultiplyAll(System.Collections.Generic.IList{System.Double},System.Double)">
            <summary>
            Multiply all of the values in this list by the specified factor and get the result.
            The original set of values will not be modified.
            </summary>
            <param name="values"></param>
            <param name="factor">The factor to multiply all values in the list by.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.ToIntegers(System.Collections.Generic.IList{System.Double})">
            <summary>
            Cast all of the values in this list to integers
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.ToIntegerCeilings(System.Collections.Generic.IList{System.Double})">
            <summary>
            Cast all of the values in this list to integers, rounding up
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.DoubleExtensions.IsWholeNumber(System.Double)">
            <summary>
            Is this value (within tolerance of) a whole number?
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Extensions.ICollectionExtensions">
            <summary>
            ICollection extension methods
            </summary>
        </member>
        <member name="M:Nucleus.Extensions.ICollectionExtensions.ContainsType(System.Collections.ICollection,System.Type)">
            <summary>
            Does this collection contain any item of the specified type?
            </summary>
            <param name="col"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.ICollectionExtensions.ContainsOnlyType(System.Collections.ICollection,System.Type)">
            <summary>
            Does this collection contain only objects of the given type or its subclasses?
            </summary>
            <param name="col"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.ICollectionExtensions.ExtractAllOfType``1(System.Collections.ICollection,System.Collections.Generic.ICollection{``0})">
            <summary>
            Extract all of the objects of a specified type into a separate collection
            </summary>
            <typeparam name="T">The type of object to extract from this collection</typeparam>
            <param name="col"></param>
            <param name="toCollection">The collection to which the objects will be added</param>
        </member>
        <member name="M:Nucleus.Extensions.ICollectionExtensions.ExtractAllOfType``1(System.Collections.Generic.ICollection{``0},System.Type,System.Collections.Generic.ICollection{``0})">
            <summary>
            Extract all of the objects of a specified type into a separate collection
            </summary>
            <typeparam name="T">The type of object to extract from this collection</typeparam>
            <param name="col"></param>
            <param name="toCollection">The collection to which the objects will be added</param>
        </member>
        <member name="M:Nucleus.Extensions.ICollectionExtensions.ToFlatString``1(System.Collections.Generic.ICollection{``0},System.String)">
            <summary>
            Create a string containing the ToString() results of all objects in the collection
            separated by the optionally specified separator sequence.
            </summary>
            <param name="col"></param>
            <param name="separator">The separator string to place between items</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.ICollectionExtensions.ToCompressedString(System.Collections.Generic.ICollection{System.Int32},System.String,System.String)">
            <summary>
            Create a string containing all of the integer values in the list, but with consecutive values shortened 
            to the form 'A to B'.
            </summary>
            <param name="col"></param>
            <param name="separator"></param>
            <param name="bridge"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.ICollectionExtensions.ToCompressedString(System.Collections.Generic.ICollection{System.Int64},System.String,System.String)">
            <summary>
            Create a string containing all of the integer values in the list, but with consecutive values shortened 
            to the form 'A to B'.
            </summary>
            <param name="col"></param>
            <param name="separator"></param>
            <param name="bridge"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.CapitaliseFirst(System.String)">
            <summary>
            Returns a version of this string with the first character captalised
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.AutoSpace(System.String)">
            <summary>
            Returns a version of this string with spaces automatically placed before CamelCase capitals
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.IsInteger(System.String)">
            <summary>
            Does this string represent an integer value?
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.IsNumeric(System.String)">
            <summary>
            Does this string represent a floating-point or
            integer value?
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.IsNumeric(System.Collections.Generic.IList{System.String})">
            <summary>
            Are all of the strings in this set numeric?
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.TrimNonNumeric(System.String)">
            <summary>
            Removes all non-numeric characters from the start and end of this string.
            </summary>
            <param name="str"></param>
            <returns>A new string with characters that do not count as numbers removed from the 
            start and end, or an empty string if there are no numbers at all in the starting 
            string.</returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.ToDouble(System.String,System.Double)">
            <summary>
            Convert this string to a double.  If the conversion cannot be made,
            the specified fallback value (default: NaN) will be returned.
            </summary>
            <param name="str"></param>
            <param name="fallbackValue">The value to be returned in the case that this string
            cannot be successfully parsed into a double.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.ToInteger(System.String,System.Int32)">
            <summary>
            Convert this string to an integer.  If the conversion cannot be made,
            the specified fallback value (default: 0) will be returned.
            </summary>
            <param name="str"></param>
            <param name="fallbackValue">The value to be returned in the case that this string
            cannot be successfully parsed into an integer</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.ToLong(System.String,System.Int64)">
            <summary>
            Convert this string to a Long.  If the conversion cannot be made,
            the specified fallback value (default: 0) will be returned.
            </summary>
            <param name="str"></param>
            <param name="fallbackValue">The value to be returned in the case that this string
            cannot be successfully parsed into a long</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.TrimNonLetters(System.String)">
            <summary>
            Removes all non-letter characters from the start and end of this string.
            </summary>
            <param name="str"></param>
            <returns>A new string with characters that do not count as letters removed from the 
            start and end, or an empty string if there are no letters at all in the starting 
            string.  </returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.StartingLetters(System.String)">
            <summary>
            Get the set of contiguous letter characters from the start of this string up
            to the first space or non-letter character
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.TokeniseIgnoringLiterals(System.String)">
            <summary>
            Split this string using the separator characters ' ' and ','.
            String literals enclosed by '"' will be kept intact.
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.ExtractToken(System.String,System.Int32@,System.Int32,System.Int32,System.Collections.Generic.IList{System.String})">
            <summary>
            Extract a token from a string and add it to an output list
            </summary>
            <param name="str"></param>
            <param name="iStart"></param>
            <param name="i"></param>
            <param name="nexti"></param>
            <param name="output"></param>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.TokeniseResolvingIDSequences(System.String)">
            <summary>
            Converts the string into a set of string IDs and names.
            Numerical entries separated by the keyword 'to' will be resolved
            to intermediate sequential numbers.
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.ToIDSet(System.String)">
            <summary>
            Converts the string into a set of integer ID numbers.
            The string must consist only of numbers separated by spaces and the 'to' keyword,
            used to indicate continuous incementing ranges of ID numbers.
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.EqualsIgnoreCase(System.String,System.String)">
            <summary>
            Determines whether this string and another are equal, ignoring differences in case
            </summary>
            <param name="thisString"></param>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.RemoveWhitespace(System.String)">
            <summary>
            Remove all whitespace characters from this string
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.NonEmptyCount(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Count the number of non-null-or-whitespace entries in this array of strings
            </summary>
            <param name="strings"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.TrimEnd(System.String,System.String,System.StringComparison)">
            <summary>
            Trim an occurrences of the specified suffix from the end of this string
            </summary>
            <param name="input"></param>
            <param name="suffixToRemove"></param>
            <param name="comparisonType"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.TruncateMiddle(System.String,System.Int32,System.String)">
            <summary>
            Shorten this string to within the set maximum number of characters
            by truncating the middle of the string with an ellipsis
            </summary>
            <param name="input"></param>
            <param name="maxChars"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.TruncatePascal(System.String,System.Int32)">
            <summary>
            Shorten this string to within the set maximum number of characters
            by compressing the non-capitalised parts of the string
            </summary>
            <param name="input"></param>
            <param name="maxChars"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.OverwriteEnd(System.String,System.String)">
            <summary>
            Overwrite the ending characters of this string with the specified new ending
            </summary>
            <param name="input"></param>
            <param name="newEnd"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.CountUpper(System.String)">
            <summary>
            Count the number of upper-case characters in this string
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.NextChunk(System.String,System.Int32@,System.Char[])">
            <summary>
            Get the chunk of text that starts from the specified index and proceeds
            up to the next found instance of the specified character
            </summary>
            <param name="str"></param>
            <param name="index">The start index of the chunk.  This will be updated to the
            start position of the next chunk</param>
            <param name="toChar"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.NextChunk(System.String,System.Char@,System.Int32@,System.Char[])">
            <summary>
            Get the chunk of text that starts from the specified index and proceeds
            up to the next found instance of the specified character
            </summary>
            <param name="str"></param>
            <param name="terminator">The found character which terminates this chunk</param>
            <param name="index">The start index of the chunk.  This will be updated to the
            start position of the next chunk</param>
            <param name="toChar"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.NextBracketed(System.String,System.Char,System.Char)">
            <summary>
            Get the first substring between matching open and close brackets in this string.
            </summary>
            <param name="str"></param>
            <param name="startFrom"></param>
            <param name="openBracket"></param>
            <param name="closeBracket"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.NextBracketed(System.String,System.Int32@,System.Char,System.Char)">
            <summary>
            Get the first substring between matching open and close brackets in this string
            after the specified position.  Returns null if a matching pair of brackets is not found.
            </summary>
            <param name="str"></param>
            <param name="startIndex">The index to start searching from.  Will be modified to give
            the position of the opening bracket, or the last index in the string + 1 if nothing
            was found.</param>
            <param name="openBracket">The opening bracket character</param>
            <param name="closeBracket">The closing bracket character</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.Before(System.String,System.Char)">
            <summary>
            Return the portion of this string before the first instance
            of the specified character.  If the character is not present
            in the string then the entire original string will be returned.
            </summary>
            <param name="str"></param>
            <param name="character"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.SplitHyperlinks(System.String)">
            <summary>
            Split up a text string to different hyperlinks and the fragments of text
            between them.
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.IsURI(System.String)">
            <summary>
            Can this string be parsed as a valid URI?
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.IndexOfUpper(System.String,System.Int32)">
            <summary>
            Find the index of the first capital letter at or after the specified start index
            </summary>
            <param name="str"></param>
            <param name="startIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.AppearsAt(System.String,System.Int32,System.String)">
            <summary>
            Does this string contain the specified substring, starting from the specified
            index?
            </summary>
            <param name="str"></param>
            <param name="startIndex"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.BeforeLast(System.String,System.Char)">
            <summary>
            Get the portion of this string before the last instance of the specified 
            character.
            </summary>
            <param name="str"></param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.AfterLast(System.String,System.Char)">
            <summary>
            Get the portion of this string after the last instance of the specified character
            </summary>
            <param name="str"></param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.ToCharSubstrings(System.String)">
            <summary>
            Explode this string to a list of strings where each entry is a separate character
            from the original string
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.StringExtensions.ToNext(System.String,System.Int32@,System.Char[])">
            <summary>
            Return the block of text from the specified index to the next instance of one
            of the specified characters
            </summary>
            <param name="str"></param>
            <param name="index">The index to start from.  This will be modified to give
            the index of the first found character</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Extensions.ArrayExtensions">
            <summary>
            Extension method for arrays
            </summary>
        </member>
        <member name="M:Nucleus.Extensions.ArrayExtensions.ToString(System.Object[0:,0:],System.String,System.String,System.String,System.String)">
            <summary>
            Convert this two-dimensional array into a separated string
            </summary>
            <param name="array">The array</param>
            <param name="entrySeparator">The string to use to separate each value</param>
            <param name="lineSeparator">The string used to separate each line</param>
            <param name="startWrapper">The string to be placed before each entry</param>
            <param name="endWrapper">The string to be placed after each entry</param>
            <returns>A string formatted in the specified way.</returns>
        </member>
        <member name="M:Nucleus.Extensions.ArrayExtensions.ToString(System.Object[0:,0:],System.String,System.String,System.String)">
            <summary>
            Convert this two-dimensional array into a separated string.
            Each row of the array will be separated by a newline character.
            </summary>
            <param name="array">The array</param>
            <param name="entrySeparator">The string to use to separate each value</param>
            <param name="startWrapper">The string to be placed before each entry</param>
            <param name="endWrapper">The string to be placed after each entry</param>
            <returns>A string formatted in the specified way.</returns>
        </member>
        <member name="M:Nucleus.Extensions.ArrayExtensions.ToCSV(System.Object[0:,0:],System.String,System.String)">
            <summary>
            Convert this two-dimensional array into a comma-separated-value string.
            Each entry of each row will be separated by a comma and each row of the 
            array will be separated by a newline character.
            </summary>
            <param name="array">The array</param>
            <param name="startWrapper">The string to be placed before each entry</param>
            <param name="endWrapper">The string to be placed after each entry</param>
            <returns>A string formatted in the specified way.</returns>
        </member>
        <member name="M:Nucleus.Extensions.ArrayExtensions.GetSafe``1(``0[0:,0:],System.Int32,System.Int32)">
            <summary>
            Get a value from this 2D array, checking if the specified indices are outside
            of the bounds of the array and if so returning the default value of the specified
            type.
            </summary>
            <typeparam name="TArray"></typeparam>
            <param name="array"></param>
            <param name="i"></param>
            <param name="j"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Extensions.TypeExtensions">
            <summary>
            Extension methods on types and collections of types
            </summary>
        </member>
        <member name="M:Nucleus.Extensions.TypeExtensions.InheritanceLevelsTo(System.Type,System.Type,System.Int32)">
            <summary>
            The number of levels of inheritance between this type and a type that
            is somewhere in its inheritance chain.
            </summary>
            <param name="type">This type</param>
            <param name="ancestorType">A type which is an ancestor of this one</param>
            <param name="interfaceProxy">The value to be returned in the case that the 
            specified type is not a direct ancestor but is still assignable</param>
            <returns>If the specified type is an ancestor of this one, the number of
            inheritance levels between the two types.  If the specified type is this 
            type, 0.  If the specified type cannot be found in the inheritance chain,
            -1.</returns>
        </member>
        <member name="M:Nucleus.Extensions.TypeExtensions.ClosestAncestor(System.Collections.Generic.IEnumerable{System.Type},System.Type,System.Boolean,System.Int32)">
            <summary>
            Find the type in this set of types which is the least number of
            inheritance levels above the specified type.
            </summary>
            <param name="forType">The type to seach for</param>
            <param name="inTypes">The collection of types to look within</param>
            <param name="includeSelf">If true (default) the type itself may be returned if found.
            Otherwise it will be excluded from the search and only its ancestors may be returned.</param>
            <param name="interfaceProxy">The number of inheritance levels to be assumed in the case of
            compatible interfaces</param>
            <returns>The type in this collection that is closest in the inheritance
            hierarchy to the specified type.  Or, null if the type does not have an
            ancestor in the collection.</returns>
        </member>
        <member name="M:Nucleus.Extensions.TypeExtensions.ClosestDescendent(System.Collections.Generic.IEnumerable{System.Type},System.Type)">
            <summary>
            Find the type in this set of types which is the least number of
            inheritance levels below the specified type.
            </summary>
            <param name="forType">The type to seach for</param>
            <param name="inTypes">The collection of types to look within</param>
            <returns>The type in this collection that is closest in the inheritance
            hierarchy to the specified type.  Or, null if the type does not have a
            descendent in the collection.</returns>
        </member>
        <member name="M:Nucleus.Extensions.TypeExtensions.IsCollection(System.Type)">
            <summary>
            Is this a collection type? i.e. does it implement ICollection?
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.TypeExtensions.IsEnumerable(System.Type)">
            <summary>
            Is this an enumerable type?  i.e. does it implement IEnumerable?
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.TypeExtensions.IsList(System.Type)">
            <summary>
            Is this a List type?  i.e. does it implement IList?
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.TypeExtensions.IsDictionary(System.Type)">
            <summary>
            Is this a dictionary type?
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.TypeExtensions.IsStandardDictionary(System.Type)">
            <summary>
            Is this the standard CLR Dictionary type or a subclass of it?
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.TypeExtensions.GetAutoUIMembers(System.Type)">
            <summary>
            Extract all members from this type that have been annotated with an AutoUIAttribute,
            sorted by their order.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.TypeExtensions.GetAutoUIProperties(System.Type)">
            <summary>
            Extract all properties from this type that have been annotated with an AutoUIAttribute,
            sorted by their order.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.TypeExtensions.GetAutoUIProperties(System.Collections.Generic.IEnumerable{System.Type},System.Boolean)">
            <summary>
            Extract all properties from this set of types that have been annotated with an
            AutoUIAttribute, sorted by their order.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.TypeExtensions.GetAutoUIMethods(System.Type)">
            <summary>
            Extract all methods from this type that have been annotated with an AutoUIAttribute,
            sorted by their order.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.TypeExtensions.GetOnDeserializedMethod(System.Type)">
            <summary>
            Get the method (if any) on this object tagged with the OnDeserializedAttribute
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.TypeExtensions.GetSubTypes(System.Type,System.Boolean,System.Boolean)">
            <summary>
            Get a list of all the non-abstract types that derive from this type
            </summary>
            <param name="type"></param>
            <param name="allAssemblies">If true, all loaded assembles will be checked, else only the assembly the 
            base type is defined in.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.TypeExtensions.GetAllFields(System.Type,System.Collections.Generic.ICollection{System.Reflection.FieldInfo},System.Reflection.BindingFlags,System.Boolean,System.Func{System.Reflection.FieldInfo,System.Boolean})">
            <summary>
            Get all fields of this type, including private ones inherited from base classes
            </summary>
            <param name="type"></param>
            <param name="outFields">The collection of field infos to be populated</param>
            <param name="flags">A bitmask composed of one or more BindingFlags which specify 
            how the search is conduted</param>
        </member>
        <member name="M:Nucleus.Extensions.TypeExtensions.GetAllFields(System.Type,System.Reflection.BindingFlags,System.Boolean,System.Func{System.Reflection.FieldInfo,System.Boolean})">
            <summary>
            Get all fields of this type, including private ones inherited from base classes
            </summary>
            <param name="type"></param>
            <param name="flags">A bitmask composed of one or more BindingFlags which specify 
            how the search is conduted</param>
            <param name="ignoreNonSerialised"></param>
        </member>
        <member name="M:Nucleus.Extensions.TypeExtensions.GetAllFields(System.Type,System.Boolean,System.Func{System.Reflection.FieldInfo,System.Boolean})">
            <summary>
            Get all fields of this type, including private ones inherited from base classes
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Nucleus.Extensions.TypeExtensions.GetBaseField(System.Type,System.String,System.Reflection.BindingFlags)">
            <summary>
            Searches for the specified field recursively.  If it cannot be found within this type,
            the base class hierarchy will be searched also.
            </summary>
            <param name="type"></param>
            <param name="name">The name of the field to find</param>
            <param name="flags">>A bitmask composed of one or more BindingFlags which specify 
            how the search is conduted</param>
            <returns>The FieldInfo if found, else null</returns>
        </member>
        <member name="M:Nucleus.Extensions.TypeExtensions.GetBaseField(System.Type,System.String)">
            <summary>
            Searches for the specified public or private field recursively.  
            If it cannot be found within this type, the base class hierarchy 
            will be searched also.
            </summary>
            <param name="type"></param>
            <param name="name">The name of the field to find</param>
            <param name="flags">>A bitmask composed of one or more BindingFlags which specify 
            how the search is conduted</param>
            <returns>The FieldInfo if found, else null</returns>
        </member>
        <member name="M:Nucleus.Extensions.TypeExtensions.HasParameterlessConstructor(System.Type)">
            <summary>
            Does this type posess a parameterless constructor
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.TypeExtensions.GetDependencies(System.Type,System.Boolean)">
            <summary>
            Get a collection of all types which this type relies on for its definition
            </summary>
            <param name="type"></param>
            <param name="ignoreNonSerialised"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.TypeExtensions.GetDependencies(System.Type,System.Collections.Generic.ICollection{System.Type},System.Boolean)">
            <summary>
            Get a collection of all types which this type relies on for its definition
            </summary>
            <param name="type"></param>
            <param name="ignoreNonSerialised"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.TypeExtensions.GetItemType(System.Type)">
            <summary>
            Get the type of the items stored within this collection type
            </summary>
            <param name="collectionType"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.TypeExtensions.FindIEnumerable(System.Type)">
            <summary>
            Get the generic IEnumerable type of the specified collection type
            </summary>
            <param name="collectionType"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.TypeExtensions.GetCustomAttribute``1(System.Type)">
            <summary>
            Retrieves a custom attribute applied to this type
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <param name="type"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nucleus.Extensions.TypeExtensions.Instantiate(System.Type)" -->
        <member name="M:Nucleus.Extensions.TypeExtensions.DefaultCopyBehaviour(System.Type)">
            <summary>
            Get the default copying behaviour for this type during duplication,
            as (possibly) specified by the CopyAttribute on the type itself.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Extensions.TypeExtensions.DefaultConversionType(System.Type,System.Type)">
            <summary>
            Get the default equivalent type into which the specified type
            will be converted via the 'Convert' method on this converter type.
            </summary>
            <param name="converter"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.AngleIntervals">
            <summary>
            Class to store angular intervals in a full 360 degree panorama
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.AngleIntervals.Regions">
            <summary>
            The angle intervals, stored in the form [Start],[End]
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.AngleIntervals.Wraps">
            <summary>
            Does a region wrap around and cross the 360/0 degrees border?
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.AngleIntervals.IsFull">
            <summary>
            Is the full circle filled?
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.AngleIntervals.IsEmpty">
            <summary>
            Have no angle regions yet been stored?
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.AngleIntervals.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.AngleIntervals.#ctor(Nucleus.Geometry.Angle,Nucleus.Geometry.Angle)">
            <summary>
            Starting interval constructor
            </summary>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="M:Nucleus.Geometry.AngleIntervals.addRegion(Nucleus.Geometry.Angle,Nucleus.Geometry.Angle)">
            <summary>
            Add a new angle interval, automatically merging it with
            existing intervals as appropriate
            </summary>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="M:Nucleus.Geometry.AngleIntervals.isInsideRegion(Nucleus.Geometry.Angle,System.Double)">
            <summary>
            Is the specified angle within a stored interval?
            </summary>
            <param name="angle"></param>
            <param name="tolerance"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.AngleIntervals.isInsideRegion(Nucleus.Geometry.Angle,Nucleus.Geometry.Angle,System.Double)">
            <summary>
            Is the specified range of angles within a stored interval?
            </summary>
            <param name="startAngle"></param>
            <param name="endAngle"></param>
            <param name="tolerance"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.AngleIntervals.InverseCone(Nucleus.Geometry.Angle,Nucleus.Geometry.Angle)">
            <summary>
            Create a new set of angle intervals containing all outside the specified
            cone
            </summary>
            <param name="coneAngle"></param>
            <param name="coneWidth"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.AnglePair">
            <summary>
            Structure to represent pairs of angles.
            Immutable.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.AnglePair.Elevation">
            <summary>
            The elevation angle, or latitude
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.AnglePair.Azimuth">
            <summary>
            The azimuth angle, or longitude
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.AnglePair.#ctor(Nucleus.Geometry.Angle,Nucleus.Geometry.Angle)">
            <summary>
            Create a new AnglePair
            </summary>
            <param name="elevation">The elevation angle, or latitude</param>
            <param name="azimuth">The azimuth angle, or longitude</param>
        </member>
        <member name="M:Nucleus.Geometry.AnglePair.FromDegrees(System.Double,System.Double)">
            <summary>
            Create an angle pair from values expressed in degrees
            </summary>
            <param name="elevation">The elevation angle, or latitude</param>
            <param name="azimuth">The azimuth angle, or longitude</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.MapData">
            <summary>
            CellMap data storage for elements 
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.MapData.MapCell">
            <summary>
            The MapCell the element is currently inside
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.MapData.Position">
            <summary>
            Get the position of the element as defined by the
            map cell.
            </summary>
        </member>
        <member name="T:Nucleus.Geometry.CellObscurance">
            <summary>
            Class to represent the obscurance condition of a map cell
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.CellObscurance.Unobscured">
            <summary>
            The condition that represents full unobscurance
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.CellObscurance.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.CellObscurance.IsUnobscured(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Is the specified position in the cell unobscured from the specified
            source position
            </summary>
            <param name="positionInCell"></param>
            <param name="sourcePosition"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.PartialCellObscurance">
            <summary>
            Class that represents partial obscurance of a map cell
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.PartialCellObscurance._StartAngle">
            <summary>
            Private backing member variable for the StartAngle property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.PartialCellObscurance.StartAngle">
            <summary>
            The starting angle of the shadow region
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.PartialCellObscurance._EndAngle">
            <summary>
            Private backing member variable for the EndAngle property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.PartialCellObscurance.EndAngle">
            <summary>
            The ending angle of the shadow region
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.PartialCellObscurance.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.PartialCellObscurance.#ctor(Nucleus.Geometry.Angle,Nucleus.Geometry.Angle)">
            <summary>
            Start and end angle constructor
            </summary>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="T:Nucleus.Geometry.CompassDirection">
            <summary>
            An enumerated value representing the points of the compass
            </summary>
        </member>
        <member name="T:Nucleus.Geometry.CompassDirectionExtensions">
            <summary>
            Extension methods for the CompassDirection enum
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.CompassDirectionExtensions.TurnClockwise(Nucleus.Geometry.CompassDirection)">
            <summary>
            Find the next compass direction clockwise from the current one
            </summary>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.CompassDirectionExtensions.TurnAntiClockwise(Nucleus.Geometry.CompassDirection)">
            <summary>
            Find the next compass direction anticlockwise from the current one
            </summary>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.CompassDirectionExtensions.Reverse(Nucleus.Geometry.CompassDirection)">
            <summary>
            Flip this direction to face the opposite way
            </summary>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.CompassDirectionExtensions.IsVertical(Nucleus.Geometry.CompassDirection)">
            <summary>
            Is this direction 'vertical' (i.e. North/South)
            </summary>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.CompassDirectionExtensions.IsHorizontal(Nucleus.Geometry.CompassDirection)">
            <summary>
            Is this direction 'horizontal' (i.e. East/West)
            </summary>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.CompassDirectionExtensions.RandomOther(Nucleus.Geometry.CompassDirection,System.Random)">
            <summary>
            Generate a random direction other than this one
            </summary>
            <param name="direction"></param>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.CompassDirectionExtensions.RandomTurn(Nucleus.Geometry.CompassDirection,System.Random)">
            <summary>
            Generate a random direction at right angles to this one
            </summary>
            <param name="direction"></param>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.Extrusion">
            <summary>
            A solid defined as an extrusion of a planar region along a straight line
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Extrusion._Profile">
            <summary>
            Backing field for Profile property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Extrusion.Profile">
            <summary>
            The cross-sectional profile which is extruded to define the volume
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Extrusion._Path">
            <summary>
            Backing field for Path property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Extrusion.Path">
            <summary>
            The extrusion path.  The profile will be extruded along this
            vector in order to define the full 3D geometry of the extrusion volume
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Extrusion.IsValid">
            <summary>
            Does this extrusion have a valid geometric definition?
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Extrusion.Vertices">
            <summary>
            The collection of vertices which are used to define the geometry of this shape.
            Different shapes will provide different means of editing this collection.
            DO NOT directly modify the collection returned from this property unless you are
            sure you know what you are doing.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Extrusion.#ctor">
            <summary>
            Initialise a new Extrusion object with a blank definition
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Extrusion.#ctor(Nucleus.Geometry.PlanarRegion,Nucleus.Geometry.Vector)">
            <summary>
            Initialise a new Extrusion object representing an 
            extrusion of the specified profile along the specified path
            </summary>
            <param name="profile">The profile surface to extrude</param>
            <param name="path">The extrusion vector</param>
        </member>
        <member name="M:Nucleus.Geometry.Extrusion.#ctor(Nucleus.Geometry.Curve,Nucleus.Geometry.Vector)">
            <summary>
            Initialise a new Extrusion object representing an 
            extrusion of the specified profile along the specified path
            </summary>
            <param name="profile">The profile perimeter curve.  Must be planar.</param>
            <param name="path">The extrusion vector</param>
        </member>
        <member name="T:Nucleus.Geometry.HandSide">
            <summary>
            Enum to represent a direction either to the left or right
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.HandSide.Right">
            <summary>
            The right-hand side
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.HandSide.Left">
            <summary>
            The left-hand side
            </summary>
        </member>
        <member name="T:Nucleus.Geometry.HandSideExtensions">
            <summary>
            Extension methods for the HandSide enum
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.HandSideExtensions.Flip(Nucleus.Geometry.HandSide)">
            <summary>
            Return the opposite side
            </summary>
            <param name="side"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.HandSideExtensions.OffsetSign(Nucleus.Geometry.HandSide)">
            <summary>
            Returns either 1 or -1 depending on whether this side
            would typically require a positive or negative curve
            offset value
            </summary>
            <param name="side"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.Rectangle`1">
            <summary>
            A generic base class for two-dimensional intervals
            </summary>
            <typeparam name="TCoord"></typeparam>
        </member>
        <member name="P:Nucleus.Geometry.Rectangle`1.XStart">
            <summary>
            The first value in the first dimension
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Rectangle`1.YStart">
            <summary>
            The first value in the second dimension
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Rectangle`1.XEnd">
            <summary>
            The second value in the first dimension
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Rectangle`1.YEnd">
            <summary>
            The second value in the second dimension
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Rectangle`1.XMin">
            <summary>
            Get the minimum value in the first dimension
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Rectangle`1.XMax">
            <summary>
            Get the maximum value in the first dimension
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Rectangle`1.YMin">
            <summary>
            Get the minimum value in the second dimension
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Rectangle`1.YMax">
            <summary>
            Get the maximum value in the second dimension
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Rectangle`1.XSize">
            <summary>
            Get the size of the domain in the first dimension
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Rectangle`1.YSize">
            <summary>
            Get the size of the domain in the second dimension
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Rectangle`1.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Rectangle`1.#ctor(`0,`0,`0,`0)">
            <summary>
            Initialise the bounds of this rectangle to the specified values
            </summary>
            <param name="xStart">The start value of the x-domain</param>
            <param name="xEnd">The end value of the x-domain</param>
            <param name="yStart">The start value of the y-domain</param>
            <param name="yEnd">The end value of the y-domain</param>
        </member>
        <member name="M:Nucleus.Geometry.Rectangle`1.#ctor(`0)">
            <summary>
            Initialise all bounds to a given value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Nucleus.Geometry.Rectangle`1.#ctor(`0,`0)">
            <summary>
            Initialise a rectangle with both start and end values
            set to the specified values in each dimension
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Nucleus.Geometry.Rectangle`1.IsInside(`0,`0)">
            <summary>
            Do the specified values in each dimension fall within this rectangular interval
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Rectangle`1.Expand(`0)">
            <summary>
            Expand this rectangular interval equally in all directions by a specified amount
            </summary>
            <param name="amount"></param>
        </member>
        <member name="M:Nucleus.Geometry.Rectangle`1.Grow(Nucleus.Geometry.CompassDirection,`0)">
            <summary>
            Grow this rectangle in the specified direction
            by the specified amount
            </summary>
            <param name="direction"></param>
            <param name="amount"></param>
        </member>
        <member name="M:Nucleus.Geometry.Rectangle`1.Move(Nucleus.Geometry.CompassDirection,`0)">
            <summary>
            Move this rectangle in the specified direction by the
            specified distance
            </summary>
            <param name="direction"></param>
            <param name="distance"></param>
        </member>
        <member name="M:Nucleus.Geometry.Rectangle`1.Add(`0,`0)">
            <summary>
            Add two values
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
        </member>
        <member name="M:Nucleus.Geometry.Rectangle`1.Subtract(`0,`0)">
            <summary>
            Subtract two values
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.Rectangle">
            <summary>
            A rectangular two-dimensional interval defined by double value bounds
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Rectangle.Width">
            <summary>
            Get the width of the rectangle
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Rectangle.Height">
            <summary>
            Get the height of the rectangle
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Rectangle.#ctor">
            <summary>
            Default constructor.  Initialise all bounds to 0.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Rectangle.#ctor(System.Double)">
            <summary>
            Initialise all bounds to a given value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Nucleus.Geometry.Rectangle.#ctor(System.Double,System.Double)">
            <summary>
            Initialise a rectangle with the specified width and height, centred on the origin
            </summary>
            <param name="width">The width (dimension in X) of the rectangle</param>
            <param name="height">The height (dimension in Y) of the rectangle</param>
        </member>
        <member name="M:Nucleus.Geometry.Rectangle.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initialise the bounds of this rectangle to the specified values
            </summary>
            <param name="xStart">The start value of the x-domain</param>
            <param name="xEnd">The end value of the x-domain</param>
            <param name="yStart">The start value of the y-domain</param>
            <param name="yEnd">The end value of the y-domain</param>
        </member>
        <member name="T:Nucleus.Geometry.IntRectangle">
            <summary>
            A rectangular two-dimensional interval defined by integer value bounds
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.IntRectangle.#ctor">
            <summary>
            Default constructor.  Initialise all bounds to 0.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.IntRectangle.#ctor(System.Int32)">
            <summary>
            Initialise all bounds to a given value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Nucleus.Geometry.IntRectangle.#ctor(System.Int32,System.Int32)">
            <summary>
            Initialise a rectangle with both start and end values
            set to the specified values in each dimension
            </summary>
            <param name="x">The value to initialise the first dimension bounds to</param>
            <param name="y">The value to initialise the second dimension bounds to</param>
        </member>
        <member name="M:Nucleus.Geometry.IntRectangle.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initialise the bounds of this rectangle to the specified values
            </summary>
            <param name="xStart">The start value of the x-domain</param>
            <param name="xEnd">The end value of the x-domain</param>
            <param name="yStart">The start value of the y-domain</param>
            <param name="yEnd">The end value of the y-domain</param>
        </member>
        <member name="M:Nucleus.Geometry.IntRectangle.GrowZone(Nucleus.Geometry.CompassDirection,System.Int32)">
            <summary>
            Create a new IntRectangle representing the area to be added if this
            rectangle were to grow by the specified distance in the specified
            direction.
            </summary>
            <param name="direction"></param>
            <param name="distance"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.IntRectangle.RandomPointOnEdge(Nucleus.Geometry.CompassDirection,System.Random,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Choose a random point on the outside edge of this rectangle
            </summary>
            <param name="edge"></param>
            <param name="rng"></param>
            <param name="endOffset"></param>
            <param name="i"></param>
            <param name="j"></param>
        </member>
        <member name="T:Nucleus.Geometry.Solid">
            <summary>
            Abstract base class for solids - full 3d geometries
            that completely enclose a volume.
            </summary>
        </member>
        <member name="T:Nucleus.Geometry.SurfaceCollection">
            <summary>
            A collection of surfaces
            </summary>
        </member>
        <member name="T:Nucleus.Geometry.Triangle">
            <summary>
            Static helper class containing common calculations
            to do with triangles
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Triangle.XYArea(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Calculate the signed area of a triangle on the XY plane
            </summary>
            <param name="v0">The first vertex of the triangle</param>
            <param name="v1">The second vertex of the triangle</param>
            <param name="v2">The third vertex of the triangle</param>
        </member>
        <member name="M:Nucleus.Geometry.Triangle.XYArea(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Calculate the signed area of a triangle on the XY plane
            </summary>
            <param name="x0">The x coordinate of the first vertex of the triangle</param>
            <param name="y0">The y coordinate of the first vertex of the triangle</param>
            <param name="x1">The x coordinate of the second vertex of the triangle</param>
            <param name="y1">The y coordinate of the second vertex of the triangle</param>
            <param name="x2">The x coordinate of the third vertex of the triangle</param>
            <param name="y2">The y coordinate of the first vertex of the triangle</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Triangle.BarycentricCoordinates(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double@,System.Double@)">
            <summary>
            Calculate the barycentric coordinates of a point with relation to
            a triangle on the XY plane.
            </summary>
            <param name="xP">The x coordinate of the point</param>
            <param name="yP">The y coordinate of the point</param>
            <param name="x0">The x coordinate of the first vertex of the triangle</param>
            <param name="y0">The y coordinate of the first vertex of the triangle</param>
            <param name="x1">The x coordinate of the second vertex of the triangle</param>
            <param name="y1">The y coordinate of the second vertex of the triangle</param>
            <param name="x2">The x coordinate of the third vertex of the triangle</param>
            <param name="y2">The y coordinate of the first vertex of the triangle</param>
            <param name="s">Output.  The barycentric s coordinate.</param>
            <param name="t">Output.  The barycentric t coordinate.</param>
        </member>
        <member name="M:Nucleus.Geometry.Triangle.BarycentricCoordinates(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,System.Double@,System.Double@)">
            <summary>
            Calculate the barycentric coordinates of a point with relation
            to a triangle
            </summary>
            <param name="p">The point to calculate coordinates for</param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="c"></param>
            <param name="s"></param>
            <param name="t"></param>
        </member>
        <member name="M:Nucleus.Geometry.Triangle.XYContainment(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Test whether a point lies within or on a triangle on the XY plane
            </summary>
            <param name="xP">The x coordinate of the point</param>
            <param name="yP">The y coordinate of the point</param>
            <param name="x0">The x coordinate of the first vertex of the triangle</param>
            <param name="y0">The y coordinate of the first vertex of the triangle</param>
            <param name="x1">The x coordinate of the second vertex of the triangle</param>
            <param name="y1">The y coordinate of the second vertex of the triangle</param>
            <param name="x2">The x coordinate of the third vertex of the triangle</param>
            <param name="y2">The y coordinate of the first vertex of the triangle</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Triangle.ZCoordinateOfPoint(System.Double,System.Double,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,System.Boolean)">
            <summary>
            Find the Z coordinate of a point on the XY plane projected onto
            a 3D triangle
            </summary>
            <param name="xP">The x coordinate of the point</param>
            <param name="yP">The y coordinate of the point</param>
            <param name="v0">The first vertex of the triangle</param>
            <param name="v1">The second vertex of the triangle</param>
            <param name="v2">The third vertex of the triangle</param>
            <param name="bound">If true (default) the point will be bounded
            to the triangle and if it lies outside double.NaN will be
            returned.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Triangle.PointFromBarycentric(System.Double,System.Double,System.Double,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Convert a point defined in Barycentric coordinates on a triangle to 
            cartesian coordinates in real space.
            </summary>
            <param name="s"></param>
            <param name="t"></param>
            <param name="u"></param>
            <param name="pt0"></param>
            <param name="pt1"></param>
            <param name="pt2"></param>
            <returns></returns>
        </member>
        <member name="F:Nucleus.Geometry.HexCellMap`1._Cells">
            <summary>
            The backing array of cells
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.HexCellMap`1.CellCount">
            <summary>
            Get the number of cells in this map
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.HexCellMap`1._Origin">
            <summary>
            Private backing field for Origin property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.HexCellMap`1.Origin">
            <summary>
            The origin of the map
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.HexCellMap`1._SizeX">
            <summary>
            Private backing field for SizeX property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.HexCellMap`1.SizeX">
            <summary>
            The number of cells in the X-direction
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.HexCellMap`1._SizeY">
            <summary>
            Private backing field for SizeY property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.HexCellMap`1.SizeY">
            <summary>
            The number of cells in the Y-direction
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.HexCellMap`1._CellSize">
            <summary>
            Private backing field for CellSize property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.HexCellMap`1.CellSize">
            <summary>
            The horizontal and vertical offset between cell centres
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.HexCellMap`1.Item(System.Int32)">
            <summary>
            Get or set the contents of the cell at the specified cell index
            </summary>
            <param name="cellIndex">The 1-dimensional cell index</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.HexCellMap`1.Exists(System.Int32)">
            <summary>
            Does a cell exist at the specified index?
            </summary>
            <param name="cellIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.HexCellMap`1.IndexAt(Nucleus.Geometry.Vector)">
            <summary>
            Get the index of the cell at the specified location
            </summary>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.HexCellMap`1.IndexAt(System.Double,System.Double)">
            <summary>
            Get the index of the cell at the specified x and y coordinates
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.HexCellMap`1.IndexAt(System.Int32,System.Int32)">
            <summary>
            Get the index of the cell at the specified i and j indices
            (aligned to the x and y axes respectively)
            </summary>
            <param name="columnIndex">The column index</param>
            <param name="rowIndex">The row index</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.HexCellMap`1.ColumnIndex(System.Int32)">
            <summary>
            Get the column index of the cell with the specified cell index
            </summary>
            <param name="cellIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.HexCellMap`1.RowIndex(System.Int32)">
            <summary>
            Get the row index of the cell with the specified cell index
            </summary>
            <param name="cellIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.HexCellMap`1.AdjacencyCount(System.Int32)">
            <summary>
            Get the maximum number of possible adjacent cells for the specified
            cellIndex.  Note that this is only the maximum possible number and
            does not guarantee that all adjacencyIndices up to this number will
            return a cell that exists - you should check for this.
            </summary>
            <param name="cellIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.HexCellMap`1.VertexCount(System.Int32)">
            <summary>
            Get the number of vertices posessed by the cell at the specifed index
            </summary>
            <param name="cellIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.HexCellMap`1.CellVertex(System.Int32,System.Int32)">
            <summary>
            Get the position of the specifed vertex of the specified cell
            </summary>
            <param name="cellIndex"></param>
            <param name="vertexIndex"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.ICellMap">
            <summary>
            A base interface for maps of cells
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.ICellMap.CellCount">
            <summary>
            Get the number of cells in this map
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.ICellMap.Exists(System.Int32)">
            <summary>
            Does a cell exist at the specified index?
            </summary>
            <param name="cellIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.ICellMap.GetCell(System.Int32)">
            <summary>
            Get the cell object at the specified index
            </summary>
            <param name="cellIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.ICellMap.IndexAt(Nucleus.Geometry.Vector)">
            <summary>
            Get the index of the cell at the specified location
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.ICellMap.AdjacencyCount(System.Int32)">
            <summary>
            Get the maximum number of possible adjacent cells for the specified
            cellIndex.  Note that this is only the maximum possible number and
            does not guarantee that all adjacencyIndices up to this number will
            return a cell that exists - you should check for this.
            </summary>
            <param name="cellIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.ICellMap.AdjacentCellIndex(System.Int32,System.Int32)">
            <summary>
            Get the cell index of the specified adjacent cell to the specified cell
            </summary>
            <param name="cellIndex">The index of the starting cell</param>
            <param name="adjacencyIndex">The adjacency index of the cell to retrieve</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.ICellMap.AdjacentCellIndex(System.Int32,Nucleus.Geometry.Vector)">
            <summary>
            Get the cell index of the cell adjacent to the cell with the specified
            index in the specified direction.
            </summary>
            <param name="cellIndex">The index of the starting cell</param>
            <param name="direction">The direction of the cell to retrieve</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.ICellMap.CellPosition(System.Int32)">
            <summary>
            Get the position of the specified cell
            </summary>
            <param name="cellIndex">The index of the cell to determine the position for</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.ICellMap.CellVertex(System.Int32,System.Int32)">
            <summary>
            Get the position of the specifed vertex of the specified cell
            </summary>
            <param name="cellIndex"></param>
            <param name="vertexIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.ICellMap.VertexCount(System.Int32)">
            <summary>
            Get the number of vertices posessed by the cell at the specifed index
            </summary>
            <param name="cellIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.ICellMap.CellsOrderedByDistance(Nucleus.Geometry.Vector,System.Double)">
            <summary>
            Get a list of the cells in this map within a given range of a given position,
            ordered by distance
            </summary>
            <param name="position"></param>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.ICellMap.SpawnNewGrid``1">
            <summary>
            Spawn a new grid of the same type and size but with a different
            generic type
            </summary>
            <typeparam name="E"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.ICellMap`1">
            <summary>
            A generic interface for maps of cells
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Nucleus.Geometry.ICellMap`1.Item(System.Int32)">
            <summary>
            Get or set the contents of the cell at the specified cell index
            </summary>
            <param name="cellIndex">The 1-dimensional cell index</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.ICellMapExtensions">
            <summary>
            Extension methods for the ICellMap interface
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.ICellMapExtensions.CellAt``1(Nucleus.Geometry.ICellMap{``0},Nucleus.Geometry.Vector)">
            <summary>
            Get the item in the cell at the specified location
            </summary>
            <typeparam name="T"></typeparam>
            <param name="map"></param>
            <param name="location">A point vector which lies within the cell to be retrieved.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.ICellMapExtensions.CellsAt``1(Nucleus.Geometry.ICellMap{``0},System.Collections.Generic.IList{Nucleus.Geometry.Vector})">
            <summary>
            Get the items in the cells at the specified locations
            </summary>
            <typeparam name="T"></typeparam>
            <param name="map"></param>
            <param name="locations"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.ICellMapExtensions.AdjacentCell``1(Nucleus.Geometry.ICellMap{``0},System.Int32,System.Int32)">
            <summary>
            Get the specified adjacent cell to the specified cell
            </summary>
            <param name="cellIndex">The index of the starting cell</param>
            <param name="adjacencyIndex">The adjacency index of the cell to retrieve</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.ICellMapExtensions.AdjacentCell``1(Nucleus.Geometry.ICellMap{``0},System.Int32,Nucleus.Geometry.Vector)">
            <summary>
            Get the cell adjacent to the cell with the specified
            index in the specified direction.
            </summary>
            <param name="cellIndex">The index of the starting cell</param>
            <param name="direction">The direction of the cell to retrieve</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.ICellMapExtensions.AdjacentCells``1(Nucleus.Geometry.ICellMap{``0},System.Int32)">
            <summary>
            Retrieve a list of all cells adjacent to the one with the specified index
            </summary>
            <typeparam name="T"></typeparam>
            <param name="map"></param>
            <param name="cellIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.ICellMapExtensions.CellBorder``1(Nucleus.Geometry.ICellMap{``0},System.Int32)">
            <summary>
            Get the polyline representing the border of the cell with the specified index
            </summary>
            <typeparam name="T"></typeparam>
            <param name="map"></param>
            <param name="cellIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.ICellMapExtensions.SetCell``1(Nucleus.Geometry.ICellMap{``0},System.Int32,``0)">
            <summary>
            Set a cell in this map.  This will back-register the map and index
            with the cell itself.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="map"></param>
            <param name="index"></param>
            <param name="cell"></param>
        </member>
        <member name="M:Nucleus.Geometry.ICellMapExtensions.SetAll``1(Nucleus.Geometry.ICellMap{``0},``0)">
            <summary>
            Set all cells in this map to the same value.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="map"></param>
            <param name="value"></param>
        </member>
        <member name="M:Nucleus.Geometry.ICellMapExtensions.InitialiseCells``1(Nucleus.Geometry.ICellMap{``0})">
            <summary>
            Populate this map with cells
            </summary>
            <typeparam name="T"></typeparam>
            <param name="map"></param>
        </member>
        <member name="M:Nucleus.Geometry.ICellMapExtensions.FieldOfView``2(Nucleus.Geometry.ICellMap{``1},Nucleus.Geometry.Vector,System.Double,System.Func{``1,System.Boolean},Nucleus.Geometry.ICellMap{``0},``0)">
            <summary>
            Generate a field of view within this cell map
            </summary>
            <param name="fromPoint"></param>
            <param name="maxRange"></param>
            <param name="transparencyCondition"></param>
            <param name="outGrid"></param>
            <param name="visibleValue">The value to set in the output grid to indicate visibility</param>
        </member>
        <member name="M:Nucleus.Geometry.ICellMapExtensions.GenerateDijkstraMap``1(Nucleus.Geometry.ICellMap{``0},System.Func{``0,System.Boolean},System.Func{``0,System.Boolean},System.Int32,System.Int32)">
            <summary>
            Generate a Dijkstra Map to aid AI navigation through this map
            </summary>
            <typeparam name="T"></typeparam>
            <param name="map"></param>
            <param name="startingValue"></param>
            <param name="targetCondition"></param>
            <param name="passCondition"></param>
            <param name="blockedValue"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.ICellMapExtensions.IterateDijkstraMap(Nucleus.Geometry.ICellMap{System.Int32},System.Int32)">
            <summary>
            Run one iteration of a dijkstra map update.  Each cell is set to the lowest
            adjacent value - 1.
            </summary>
            <param name="dMap"></param>
            <param name="blockedValue"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.IMapCell">
            <summary>
            Interface for objects which may be stored as map cells
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.IMapCell.Index">
            <summary>
            The index of the cell in its owning map
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.IMapCell.Map">
            <summary>
            The map to which this cell belongs
            </summary>
        </member>
        <member name="T:Nucleus.Geometry.IMapCellDataComponent">
            <summary>
            An interface for data components which may be attached to a map cell
            </summary>
        </member>
        <member name="T:Nucleus.Geometry.MapCell">
            <summary>
            A cell in an ICellMap which acts as a container for other objects
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.MapCell._Contents">
            <summary>
            Private backing member variable for the Contents property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.MapCell.Contents">
            <summary>
            The contents of this map cell
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.MapCell.Index">
            <summary>
            The index of the cell
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.MapCell.Map">
            <summary>
            The map to which the cell belongs
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.MapCell.Position">
            <summary>
            Get the position of this map cell
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.MapCell.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.MapCell.#ctor(System.Int32,Nucleus.Geometry.ICellMap)">
            <summary>
            Constructor
            </summary>
            <param name="index"></param>
            <param name="map"></param>
        </member>
        <member name="M:Nucleus.Geometry.MapCell.PlaceInCell(Nucleus.Model.Element)">
            <summary>
            Move the specified element to this cell.
            The element will be removed from any cell it occupies.
            TODO: Modify this for multi-cell entities?
            </summary>
            <param name="element"></param>
        </member>
        <member name="T:Nucleus.Geometry.MapCellExtensions">
            <summary>
            Extension methods for the MapCell class
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.MapCellExtensions.AdjacentCellInDirection``1(``0,Nucleus.Geometry.Vector)">
            <summary>
            Gets the adjacent cell (of the same type) in the specified direction
            </summary>
            <typeparam name="TMapCell"></typeparam>
            <param name="cell"></param>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.MapCellDataStore">
            <summary>
            Extensible storage mechanism for adding tagged data to MapCells
            </summary>
        </member>
        <member name="T:Nucleus.Geometry.ISimpleCurve">
            <summary>
            Interface for 'simple' curve types which are atomic
            and of only one span, such as line segments and arcs
            </summary>
        </member>
        <member name="T:Nucleus.Geometry.IWidePath">
            <summary>
            Interface for geometric objects which are linear and follow
            a spine curve but that have sufficient width on plan for the left and right
            edges to be represented by separate curves.  For example; roads, building
            wings, beam representations in GAs, etc.
            This interface provides attached extension functions to allow the generation
            of geometry representing the boundaries of a network of paths.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.IWidePath.Spine">
            <summary>
            The spine curve from which the outer curves are to be derived
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.IWidePath.LeftEdge">
            <summary>
            The left edge curve
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.IWidePath.RightEdge">
            <summary>
            The right edge curve
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.IWidePath.LeftOffset">
            <summary>
            The offset distance of the left edge from the spine
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.IWidePath.RightOffset">
            <summary>
            The offset distance of the right edge from the spine
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.IWidePath.LeftEndPinch">
            <summary>
            The 'pinch' distance applied to the left-hand edge ends
            in order to induce curvature in the left-hand edge curve
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.IWidePath.RightEndPinch">
            <summary>
            The 'pinch' distance applied to the right-hand edge ends
            in order to induce curvature in the right-hand edge curve
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.IWidePath.StartCapLeft">
            <summary>
            The curve capping the left side of the starting end of the path.
            Will usually be null.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.IWidePath.StartCapRight">
            <summary>
            The curve capping the right side of the starting end of the path.
            Will usually be null.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.IWidePath.EndCapLeft">
            <summary>
            The curve capping the left side of the end of the path.
            Will usually be null.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.IWidePath.EndCapRight">
            <summary>
            The curve capping the right side of the end of the path.
            Will usually be null.
            </summary>
        </member>
        <member name="T:Nucleus.Geometry.IWidePathExtensions">
            <summary>
            Extension methods for the IWidePath interface
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.IWidePathExtensions.GenerateInitialPathEdges(Nucleus.Geometry.IWidePath)">
            <summary>
            Generate initial (untrimmed) left and right edge curves for
            this path.
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:Nucleus.Geometry.IWidePathExtensions.CurveInitialPathEdges(Nucleus.Geometry.IWidePath)">
            <summary>
            Replace the initially generated path edges with arcs with offset ends to induce curvature in the
            outer edges.
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:Nucleus.Geometry.IWidePathExtensions.PointAt(Nucleus.Geometry.IWidePath,System.Double,System.Double)">
            <summary>
            Find the point on this path specified by the given parameters.
            </summary>
            <param name="path"></param>
            <param name="u">A normalised parameter along the path (where 0 = Start, 1 = End)</param>
            <param name="v">A normalised parameter across the path (where 0 = Left, 1 = Right)</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.IWidePathExtensions.PointsAt(Nucleus.Geometry.IWidePath,System.Double,System.Collections.Generic.IList{System.Double})">
            <summary>
            Find the points on this path specified by the given parameters.
            The left and right edges of the path must have been previously
            populated in order for this function to work correctly.
            </summary>
            <param name="path"></param>
            <param name="u">A normalised parameter along the path 
            (where 0 = Start, 1 = End)</param>
            <param name="v">A list of normalised parameters across the path 
            (where 0 = Left, 1 = Right)</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.IWidePathExtensions.PointsAt(Nucleus.Geometry.IWidePath,System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>
            Find the points on this path specified by the given parameters.
            The right and left edges of the path must have been previously
            populated in order for this function to return successfully.
            </summary>
            <param name="path"></param>
            <param name="u">A list of normalised parameters along the path 
            (where 0 = Start, 1 = End)</param>
            <param name="v">A list of normalised parameters across the path 
            (where 0 = Left, 1 = Right)</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.IWidePathExtensions.GetBoundaryCurve``1(``0)">
            <summary>
            Get a closed polycurve containing the edges of this section of the path.
            The edges of the path must have been generated first.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.IWidePathExtensions.GenerateNetworkPathEdges``1(System.Collections.Generic.IList{``0})">
            <summary>
            Generate the left and right edges of the paths in this network,
            automatically joining them at shared end nodes.  Nodes should have been
            generated for the network prior to calling this function.
            </summary>
            <typeparam name="TPath"></typeparam>
            <param name="paths"></param>
        </member>
        <member name="M:Nucleus.Geometry.IWidePathExtensions.ExtractNetworkPathNodes``1(System.Collections.Generic.IList{``0})">
            <summary>
            Extract from this collection of paths all of the unique nodes at the ends of the
            path spine geometry.
            </summary>
            <typeparam name="TPath"></typeparam>
            <param name="paths"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.IWidePathExtensions.GenerateNetworkPathNodes``1(System.Collections.Generic.IList{``0},Nucleus.Model.NodeGenerationParameters)">
            <summary>
            Generate nodes at the ends of the paths in this collection.
            It is not necessary for the geometry to be part of a Model for this
            function, nor will any newly created nodes be added automatically
            to the current model - this should be done subsequently if necessary.
            </summary>
            <typeparam name="TPath"></typeparam>
            <param name="paths"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.IWidePathExtensions.ExtractNetworkPathLeftEdges``1(System.Collections.Generic.IList{``0})">
            <summary>
            Extract all of the left edges from the path segments in this collection
            </summary>
            <typeparam name="TPath"></typeparam>
            <param name="paths"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.IWidePathExtensions.ExtractNetworkPathRightEdges``1(System.Collections.Generic.IList{``0})">
            <summary>
            Extract all of the left edges from the path segments in this collection
            </summary>
            <typeparam name="TPath"></typeparam>
            <param name="paths"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.IWidePathExtensions.TotalSpineLength``1(System.Collections.Generic.IList{``0})">
            <summary>
            Calculate the total length of the spines of all 
            in this collection.
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.IWidePathExtensions.DeadEndCount``1(System.Collections.Generic.IList{``0})">
            <summary>
            Count the number of dead-ends in the paths in this collection
            </summary>
            <typeparam name="TPath"></typeparam>
            <param name="paths"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.MeshEdgeLink">
            <summary>
            A class representing a mesh edge which stores references to
            the faces and vertices to which it is connected.
            Note that this is rather different in implementation to
            the temporary mesh edge structure
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.MeshEdgeLink._Start">
            <summary>
            Private backing field for Start property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.MeshEdgeLink.Start">
            <summary>
            The vertex at the start of this edge
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.MeshEdgeLink._End">
            <summary>
            Private backing field for End property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.MeshEdgeLink.End">
            <summary>
            The vertex at the end of this edge
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.MeshEdgeLink.StartPoint">
            <summary>
            Get the start point of this edge
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.MeshEdgeLink.EndPoint">
            <summary>
            Get the end point of this edge
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.MeshEdgeLink.Length">
            <summary>
            Get the length of this edge
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.MeshEdgeLink.LengthSquared">
            <summary>
            Get the squared length of this edge
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.MeshEdgeLink._Faces">
            <summary>
            Private backing field for Faces property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.MeshEdgeLink.Faces">
            <summary>
            The collection of faces that adjoin this edge
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.MeshEdgeLink.IsNaked">
            <summary>
            Is this a naked edge?  i.e. does it connect to a single face?  (or none)
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.MeshEdgeLink.#ctor">
            <summary>
            Initialise a new empty linked mesh edge
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.MeshEdgeLink.#ctor(Nucleus.Geometry.Vertex,Nucleus.Geometry.Vertex)">
            <summary>
            Initialise a new linked mesh edge between the two specified vertices
            </summary>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="M:Nucleus.Geometry.MeshEdgeLink.#ctor(Nucleus.Geometry.Vertex,Nucleus.Geometry.Vertex,Nucleus.Geometry.MeshFace)">
            <summary>
            Initialise a new linked mesh edge 
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <param name="face"></param>
        </member>
        <member name="T:Nucleus.Geometry.MeshEdgeLinkExtensions">
            <summary>
            Static extension methods related to the MeshEdgeLink class
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.MeshEdgeLinkExtensions.Naked(System.Collections.Generic.IList{Nucleus.Geometry.MeshEdgeLink})">
            <summary>
            Extract the subset of this list of edges that are naked - i.e. they
            are not shared between two or more faces.
            </summary>
            <param name="edges"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.RegularCellMap`1">
            <summary>
            Abstract base class for cell maps with a regular geometric arrangement
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Nucleus.Geometry.RegularCellMap`1.Item(System.Int32)">
            <summary>
            Get or set the contents of the cell at the specified cell index
            </summary>
            <param name="cellIndex">The 1-dimensional cell index</param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Geometry.RegularCellMap`1.CellCount">
            <summary>
            Get the number of cells in this map
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.RegularCellMap`1.Exists(System.Int32)">
            <summary>
            Does a cell exist at the specified index?
            </summary>
            <param name="cellIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.RegularCellMap`1.IndexAt(Nucleus.Geometry.Vector)">
            <summary>
            Get the index of the cell at the specified location
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.RegularCellMap`1.AdjacencyCount(System.Int32)">
            <summary>
            Get the maximum number of possible adjacent cells for the specified
            cellIndex.  Note that this is only the maximum possible number and
            does not guarantee that all adjacencyIndices up to this number will
            return a cell that exists - you should check for this.
            </summary>
            <param name="cellIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.RegularCellMap`1.AdjacentCellIndex(System.Int32,System.Int32)">
            <summary>
            Get the cell index of the specified adjacent cell to the specified cell
            </summary>
            <param name="cellIndex">The index of the starting cell</param>
            <param name="adjacencyIndex">The adjacency index of the cell to retrieve</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.RegularCellMap`1.AdjacentCellIndex(System.Int32,Nucleus.Geometry.Vector)">
            <summary>
            Get the cell index of the cell adjacent to the cell with the specified
            index in the specified direction.
            </summary>
            <param name="cellIndex">The index of the starting cell</param>
            <param name="direction">The direction of the cell to retrieve</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.RegularCellMap`1.CellPosition(System.Int32)">
            <summary>
            Get the position of the specified cell
            </summary>
            <param name="cellIndex">The index of the cell to determine the position for</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.RegularCellMap`1.CellVertex(System.Int32,System.Int32)">
            <summary>
            Get the position of the specifed vertex of the specified cell
            </summary>
            <param name="cellIndex"></param>
            <param name="vertexIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.RegularCellMap`1.VertexCount(System.Int32)">
            <summary>
            Get the number of vertices posessed by the cell at the specifed index
            </summary>
            <param name="cellIndex"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.SixVector">
            <summary>
            A vector in six dimensions.
            Represents a quantity in 6D space through X,Y,Z,XX,YY,ZZ components,
            where X,Y,Z are typically translational and XX, YY, ZZ are rotational
            about the respective axes.
            Primarily used to store support stiffnesses
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.SixVector.X">
            <summary>
            The vector's X component
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.SixVector.Y">
            <summary>
            The vector's Y component
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.SixVector.Z">
            <summary>
            The vector's Z component
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.SixVector.XX">
            <summary>
            The vector's XX component
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.SixVector.YY">
            <summary>
            The vector's YY component
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.SixVector.ZZ">
            <summary>
            The vector's ZZ component
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.SixVector.Item(System.Int32)">
            <summary>
            Get an indexed component of this six-vector.
            0 = X, 1 = Y, 2 = Z, 3 = XX, 4 = YY, 5 = ZZ
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Geometry.SixVector.Item(Nucleus.Geometry.Direction)">
            <summary>
            Get the component of this six-vector in the specified direction.
            </summary>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.SixVector.#ctor">
            <summary>
            Initialise a new SixVector with all components set to 0
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.SixVector.#ctor(System.Double,System.Double)">
            <summary>
            Initialise a new SixVector with the specified X, and Y
            components (and all others set to 0)
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:Nucleus.Geometry.SixVector.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Initialise a new SixVector with the specified X, Y and Z
            components (and all others set to 0)
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:Nucleus.Geometry.SixVector.#ctor(Nucleus.Geometry.Vector)">
            <summary>
            Initialise a new SixVector from a standard 3-dimensional vector
            </summary>
            <param name="vector"></param>
        </member>
        <member name="M:Nucleus.Geometry.SixVector.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initialise a new SixVector with the specified coordinates
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <param name="xx"></param>
            <param name="yy"></param>
            <param name="zz"></param>
        </member>
        <member name="M:Nucleus.Geometry.SixVector.IsValid">
            <summary>
            Is this six-vector valid?
            A vector is valid if all of its components are not NaN.
            </summary>
            <returns>True if all components are valid, else false.</returns>
        </member>
        <member name="M:Nucleus.Geometry.SixVector.Equals(Nucleus.Geometry.SixVector)">
            <summary>
            IEquatable implementation.
            Checks whether this six-vector is equal to another.
            </summary>
            <param name="other">Another vector to check</param>
            <returns>True if the components of the two vectors are equal, else false.</returns>
        </member>
        <member name="M:Nucleus.Geometry.SixVector.MergeMax(Nucleus.Geometry.SixVector)">
            <summary>
            Merge this six-vector with another.
            The highest value of each component will be taken
            for the merged vector.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.SixVector.IsZero">
            <summary>
            Are all components of this six-vector equal to zero?
            </summary>
            <returns>True if all components are zero, else false</returns>
        </member>
        <member name="M:Nucleus.Geometry.SixVector.WithX(System.Double)">
            <summary>
            Create a new SixVector copying all values from this one
            bar the new specified value of X.
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.SixVector.WithY(System.Double)">
            <summary>
            Create a new SixVector copying all values from this one
            bar the new specified value of Y.
            </summary>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.SixVector.WithZ(System.Double)">
            <summary>
            Create a new SixVector copying all values from this one
            bar the new specified value of Z.
            </summary>
            <param name="z"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.SixVector.WithXX(System.Double)">
            <summary>
            Create a new SixVector copying all values from this one
            bar the new specified value of XX.
            </summary>
            <param name="xx"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.SixVector.WithYY(System.Double)">
            <summary>
            Create a new SixVector copying all values from this one
            bar the new specified value of YY.
            </summary>
            <param name="yy"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.SixVector.WithZZ(System.Double)">
            <summary>
            Create a new SixVector copying all values from this one
            bar the new specified value of ZZ.
            </summary>
            <param name="zz"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.SixVector.With(Nucleus.Geometry.Direction,System.Double)">
            <summary>
            Create a new copy of this vector, but replacing the specified
            direction component with the given value
            </summary>
            <param name="direction">The direction of the axis to be modified.</param>
            <param name="value">The new value of the component</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.SixVector.With(System.Int32,System.Double)">
            <summary>
            Create a new copy of this vector, but replacing the specified
            direction component with the given value
            </summary>
            <param name="index">The index of the axis to be modified.
            From 0-5, indicating 0 = X, 1 = Y, 2 = Z, 3 = XX, 4 = YY
            and 5 = ZZ</param>
            <param name="value">The new value of the component</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.SixVector.FromTokensList(System.Collections.Generic.IList{System.String},System.Int32)">
            <summary>
            Create a vector from a sequential set of values in a list,
            starting at the specified index.  Out-of-bounds errors are automatically checked for.
            </summary>
            <param name="tokens"></param>
            <param name="startIndex"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.SquareCellMap`1">
            <summary>
            A data structure representing a map of regular square cells arranged in a orthogonal grid
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Nucleus.Geometry.SquareCellMap`1._Cells">
            <summary>
            The backing array of cells
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.SquareCellMap`1.CellCount">
            <summary>
            Get the number of cells in this map
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.SquareCellMap`1._Origin">
            <summary>
            Private backing field for Origin property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.SquareCellMap`1.Origin">
            <summary>
            The origin of the map
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.SquareCellMap`1._SizeX">
            <summary>
            Private backing field for SizeX property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.SquareCellMap`1.SizeX">
            <summary>
            The number of cells in the X-direction
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.SquareCellMap`1._SizeY">
            <summary>
            Private backing field for SizeY property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.SquareCellMap`1.SizeY">
            <summary>
            The number of cells in the Y-direction
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.SquareCellMap`1._CellSize">
            <summary>
            Private backing field for CellSize property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.SquareCellMap`1.CellSize">
            <summary>
            The edge dimension of each cell
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.SquareCellMap`1.Item(System.Int32)">
            <summary>
            Get or set the contents of the cell at the specified cell index
            </summary>
            <param name="cellIndex">The 1-dimensional cell index</param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Geometry.SquareCellMap`1.Item(System.Int32,System.Int32)">
            <summary>
            Get or set the contents of the cell at the specified column
            and row index.
            </summary>
            <param name="columnIndex">The column (x) index</param>
            <param name="rowIndex">The row (y) index</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.SquareCellMap`1.#ctor(System.Int32,System.Int32,System.Double)">
            <summary>
            Initialise a new Square cell map with the specified dimensions
            </summary>
            <param name="sizeX"></param>
            <param name="sizeY"></param>
            <param name="cellSize"></param>
        </member>
        <member name="M:Nucleus.Geometry.SquareCellMap`1.#ctor(Nucleus.Geometry.Vector,System.Int32,System.Int32,System.Double)">
            <summary>
            Initialise a new square cell map at the given origin with the specified dimensions
            </summary>
            <param name="origin"></param>
            <param name="sizeX"></param>
            <param name="sizeY"></param>
            <param name="cellSize"></param>
        </member>
        <member name="M:Nucleus.Geometry.SquareCellMap`1.GetCell(System.Int32)">
            <summary>
            Get the cell object at the specified index
            </summary>
            <param name="cellIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.SquareCellMap`1.Exists(System.Int32)">
            <summary>
            Does a cell exist at the specified index?
            </summary>
            <param name="cellIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.SquareCellMap`1.Exists(System.Int32,System.Int32)">
            <summary>
            Does a cell exist at the specified indices
            </summary>
            <param name="i"></param>
            <param name="j"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.SquareCellMap`1.IndexAt(Nucleus.Geometry.Vector)">
            <summary>
            Get the index of the cell at the specified location
            </summary>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.SquareCellMap`1.IndexAt(System.Double,System.Double)">
            <summary>
            Get the index of the cell at the specified x and y coordinates
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.SquareCellMap`1.IndexAt(System.Int32,System.Int32)">
            <summary>
            Get the index of the cell at the specified i and j indices
            (aligned to the x and y axes respectively)
            </summary>
            <param name="columnIndex">The column index</param>
            <param name="rowIndex">The row index</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.SquareCellMap`1.ColumnIndex(System.Int32)">
            <summary>
            Get the column index of the cell with the specified cell index
            </summary>
            <param name="cellIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.SquareCellMap`1.RowIndex(System.Int32)">
            <summary>
            Get the row index of the cell with the specified cell index
            </summary>
            <param name="cellIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.SquareCellMap`1.AdjacencyCount(System.Int32)">
            <summary>
            Get the maximum number of possible adjacent cells for the specified
            cellIndex.  Note that this is only the maximum possible number and
            does not guarantee that all adjacencyIndices up to this number will
            return a cell that exists - you should check for this.
            </summary>
            <param name="cellIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.SquareCellMap`1.AdjacentCellIndex(System.Int32,System.Int32)">
            <summary>
            Get the cell index of the specified adjacent cell to the specified cell
            </summary>
            <param name="cellIndex">The index of the starting cell</param>
            <param name="adjacencyIndex">The adjacency index of the cell to retrieve</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.SquareCellMap`1.AdjacentCellIndex(System.Int32,Nucleus.Geometry.Vector)">
            <summary>
            Get the cell index of the cell adjacent to the cell with the specified
            index in the specified direction.
            </summary>
            <param name="cellIndex">The index of the starting cell</param>
            <param name="direction">The direction of the cell to retrieve</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.SquareCellMap`1.CellPosition(System.Int32)">
            <summary>
            Get the position of the specified cell
            </summary>
            <param name="cellIndex">The index of the cell to determine the position for</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.SquareCellMap`1.VertexCount(System.Int32)">
            <summary>
            Get the number of vertices posessed by the cell at the specifed index
            </summary>
            <param name="cellIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.SquareCellMap`1.CellVertex(System.Int32,System.Int32)">
            <summary>
            Get the position of the specifed vertex of the specified cell
            </summary>
            <param name="cellIndex"></param>
            <param name="vertexIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.SquareCellMap`1.CellsOrderedByDistance(Nucleus.Geometry.Vector,System.Double)">
            <summary>
            Get a list of the cells in this map within a given range of a given position,
            ordered by distance
            </summary>
            <param name="position"></param>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.WidePathBasic">
            <summary>
            A basic wide path object that can be used to simply generate edge curves
            of a path segment.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.WidePathBasic._Spine">
            <summary>
            Private backing field for Spine Property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.WidePathBasic.Spine">
            <summary>
            The spine curve from which the outer curves are to be derived
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.WidePathBasic._LeftEdge">
            <summary>
            Private backing field for LeftEdge property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.WidePathBasic.LeftEdge">
            <summary>
            The left edge curve
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.WidePathBasic._RightEdge">
            <summary>
            Private backing field for RightEdge property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.WidePathBasic.RightEdge">
            <summary>
            The right edge curve
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.WidePathBasic._LeftOffset">
            <summary>
            Private backing field for LeftOffset property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.WidePathBasic.LeftOffset">
            <summary>
            The offset distance of the left edge from the spine
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.WidePathBasic._RightOffset">
            <summary>
            Private backing field for RightOffset property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.WidePathBasic.RightOffset">
            <summary>
            The offset distance of the right edge from the spine
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.WidePathBasic._StartCapLeft">
            <summary>
            Private backing field for StartCapLeft property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.WidePathBasic.StartCapLeft">
            <summary>
            The curve capping the left side of the starting end of the path.
            Will usually be null.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.WidePathBasic._StartCapRight">
            <summary>
            Private backing field for StartCapRight property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.WidePathBasic.StartCapRight">
            <summary>
            The curve capping the right side of the starting end of the path.
            Will usually be null.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.WidePathBasic._EndCapLeft">
            <summary>
            Private backing field for EndCapLeft property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.WidePathBasic.EndCapLeft">
            <summary>
            The curve capping the left side of the end of the path.
            Will usually be null.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.WidePathBasic._EndCapRight">
            <summary>
            Private backing field for EndCapRight property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.WidePathBasic.EndCapRight">
            <summary>
            The curve capping the right side of the end of the path.
            Will usually be null.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.WidePathBasic.GenerateForCurves(System.Collections.Generic.IList{Nucleus.Geometry.Curve},System.Double,System.Boolean)">
            <summary>
            Generate a set of WidePathBasic objects for the specified network of curves and with the specified width.
            Edges may also be optionally generated.
            </summary>
            <param name="curves"></param>
            <param name="width"></param>
            <param name="generateEdges"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.WidePathBasic.GenerateForCurves(System.Collections.Generic.IList{Nucleus.Geometry.Curve},System.Double,System.Double,System.Boolean)">
            <summary>
            Generate a set of WidePathBasic objects for the specified network of curves and with the specified width.
            Edges may also be optionally generated.
            </summary>
            <param name="curves"></param>
            <param name="width"></param>
            <param name="generateEdges"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.Cloud">
            <summary>
            A point cloud, consisting only of vertices with no connecting geometry.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Cloud._Vertices">
            <summary>
            Private backing field for Vertices property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Cloud.Vertices">
            <summary>
            The vertices of this cloud
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Cloud.#ctor(Nucleus.Geometry.GeometryAttributes)">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Cloud.#ctor(System.Collections.Generic.IEnumerable{Nucleus.Geometry.Vector},Nucleus.Geometry.GeometryAttributes)">
            <summary>
            Initialise a point cloud using the specified point locations
            </summary>
            <param name="points"></param>
        </member>
        <member name="M:Nucleus.Geometry.Cloud.#ctor(Nucleus.Geometry.Vector,Nucleus.Geometry.GeometryAttributes)">
            <summary>
            Initialise a point cloud containing a single point
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:Nucleus.Geometry.Cloud.Add(Nucleus.Geometry.Vector)">
            <summary>
            Add a point to this cloud.
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:Nucleus.Geometry.Cloud.Add(Nucleus.Geometry.Vertex)">
            <summary>
            Add a vertex to this cloud.
            If the specified vertex already belongs to another piece of geometry it will
            automatically be copied and the copy added to this cloud.
            </summary>
            <param name="vertex"></param>
        </member>
        <member name="T:Nucleus.Geometry.DerivedGeometryDictionary">
            <summary>
            A dictionary to store derived element geometry
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.DerivedGeometryDictionary._Owner">
            <summary>
            Private backing field for Owner property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.DerivedGeometryDictionary.Owner">
            <summary>
            The owning element of the derived geometry
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.DerivedGeometryDictionary.#ctor(Nucleus.Model.Element)">
            <summary>
            Initialise a DerivedGeometryDictionary owned by the specified element
            </summary>
            <param name="owner"></param>
        </member>
        <member name="T:Nucleus.Geometry.Direction">
            <summary>
            Six-axis dimensional direction, consisting of the standard three
            translational dimensions and rotations about those axes.
            Used to determine the application of directional loads.
            </summary>
        </member>
        <member name="T:Nucleus.Geometry.DirectionExtensions">
            <summary>
            Extension methods for the Direction enum
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.DirectionExtensions.IsTranslation(Nucleus.Geometry.Direction)">
            <summary>
            Does this value represent a translation along an axis?
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.DirectionExtensions.IsRotation(Nucleus.Geometry.Direction)">
            <summary>
            Does this value represent a rotation about an axis?
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.DirectionExtensions.Vector(Nucleus.Geometry.Direction)">
            <summary>
            The vector which describes the axis along
            or about which the direction applies.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.DirectionExtensions.FirstPerpendicular(Nucleus.Geometry.Direction)">
            <summary>
            Get the direction of the first direction perpendicular to this one
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.DirectionExtensions.SecondPerpendicular(Nucleus.Geometry.Direction)">
            <summary>
            Get the direction of the second direction perpendicular to this one
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.GeometryAttributes">
            <summary>
            An object which holds additional non-geometric attributes about how a
            piece of geometry should be displayed or organised.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.GeometryAttributes._LayerName">
            <summary>
            Private backing field for LayerName property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.GeometryAttributes.LayerName">
            <summary>
            The name of the layer (if any) on which this object should be displayed
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.GeometryAttributes._SourceID">
            <summary>
            Private backing field for SourceID property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.GeometryAttributes.SourceID">
            <summary>
            The ID of the source object from which this geometry was generated or
            to which it is otherwise linked.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.GeometryAttributes._Interactive">
            <summary>
            Private backing field for Interactive property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.GeometryAttributes.Interactive">
            <summary>
            Raise mouse interaction events with this geometry?
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.GeometryAttributes.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.GeometryAttributes.#ctor(System.String,System.String,Nucleus.Rendering.DisplayBrush,System.Double)">
            <summary>
            Initialise an attributes object with the specified data
            </summary>
            <param name="sourceID"></param>
            <param name="layerName"></param>
        </member>
        <member name="M:Nucleus.Geometry.GeometryAttributes.#ctor(Nucleus.Rendering.DisplayBrush,System.Double)">
            <summary>
            Brush constructor.  Initialises a new GeometryAttributes object with the specified display brush.
            </summary>
            <param name="brush"></param>
        </member>
        <member name="M:Nucleus.Geometry.GeometryAttributes.#ctor(Nucleus.Rendering.Colour,System.Double)">
            <summary>
            Initialises a new GeometryAttributes object with the Brush initialised as 
            a ColourBrush of the specified colour
            </summary>
            <param name="colour"></param>
        </member>
        <member name="T:Nucleus.Geometry.GeometryLayer">
            <summary>
            A collection of vertex geometry that acts equivalently to a layer in a CAD package
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.GeometryLayer._Name">
            <summary>
            Private backing field for the Name property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.GeometryLayer.Name">
            <summary>
            The name of the layer
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.GeometryLayer._Visible">
            <summary>
            Private backing field for the Visible property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.GeometryLayer.Visible">
            <summary>
            Whether or not this layer is visible and should be rendered
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.GeometryLayer._Brush">
            <summary>
            Private backing field for the Brush property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.GeometryLayer.Brush">
            <summary>
            The default brush to be used to display objects on this layer in
            the absense of any overriding display colour
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.GeometryLayer._Tag">
            <summary>
            Private backing field for the Tag property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.GeometryLayer.Tag">
            <summary>
            A general-purpose text tag on this layer, used to designate
            additional information, such as what the geometry on this layer
            represents
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.GeometryLayer.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.GeometryLayer.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">The name of the layer</param>
        </member>
        <member name="M:Nucleus.Geometry.GeometryLayer.#ctor(System.String,Nucleus.Rendering.DisplayBrush)">
            <summary>
            Name, brush constructor
            </summary>
            <param name="name">The name of the layer</param>
            <param name="brush">The default display brush of this layer</param>
        </member>
        <member name="T:Nucleus.Geometry.GeometryLayerTable">
            <summary>
            A table of geometry layer objects, keyed by name
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.GeometryLayerTable.BoundingBox">
            <summary>
            Get the bounding box of all geometry on all layers within this table
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.GeometryLayerTable.VisibleBoundingBox">
            <summary>
            Get the bounding box of all geometry on visible layers within this table
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.GeometryLayerTable._VertexTree">
            <summary>
            Private backing field for VertexTree property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.GeometryLayerTable.VertexTree">
            <summary>
            Get a Divided-Dimension Tree structure containing all vertices belonging to
            geometry in this table
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.GeometryLayerTable.LayerOf(Nucleus.Geometry.VertexGeometry)">
            <summary>
            Find and return the layer (if any) that the specified piece
            of geometry is on.
            </summary>
            <param name="geometry"></param>
            <returns>The layer the geometry is on, else null if no layer 
            containing the geometry can be found</returns>
        </member>
        <member name="M:Nucleus.Geometry.GeometryLayerTable.Contains(Nucleus.Geometry.VertexGeometry)">
            <summary>
            Determines whether or not the layers within this table contain the
            specified piece of geometry
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.GeometryLayerTable.GetOrCreate(System.String)">
            <summary>
            Get the layer with the specified name if it already exists or if
            not create and return a new layer in this table with the given name
            </summary>
            <param name="layerName"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.GeometryLayerTable.AllGeometry">
            <summary>
            Get all the geometry objects contained within this layer table as
            a single flat collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.GeometryLayerTable.AllVertices">
            <summary>
            Get all the vertices contained within all the geometry on all the
            layers in this table in a single flat collection.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.GeometryLayerTable.CreateVertexTree">
            <summary>
            Create a Divided-Dimension Tree for the vertices of all the geometry in this table
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.GeometryLayerTable.GeometryInBounds(Nucleus.Geometry.BoundingBox,System.Boolean,System.Boolean)">
            <summary>
            Get the geometry in this table that falls within the specified axis-aligned bounding box
            </summary>
            <param name="bounds">The bounding box to check</param>
            <param name="inclusive">If true, the output can include objects that lie partially within the bounds, else
            the geometry must be entirely contained by the box to be included</param>
            <param name="visibleLayersOnly">If true (default) only layers which are currently visible will be considered</param>
        </member>
        <member name="M:Nucleus.Geometry.GeometryLayerTable.RationalisePolyCurves">
            <summary>
            Convert any polycurves that consist only of line segments into polylines
            </summary>
        </member>
        <member name="T:Nucleus.Geometry.Intersect">
            <summary>
            A static class of helper functions to find the intersections 
            between geometries of various types
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.LineLineXY(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Find the intersection point, if one exists, for two infinite lines on the XY plane.
            For 3D, use the Axis class and ClosestPoint function instead.
            </summary>
            <param name="pt0">The origin point of the first line</param>
            <param name="v0">The direction of the first line</param>
            <param name="pt1">The origin point of the second line</param>
            <param name="v1">The direction of the second line</param>
            <returns>The XY intersection point, if one exists.  Else (the lines are null or parallel) Vector.Unset</returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.LineLineXY(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,System.Double@,System.Double@)">
            <summary>
            Find the intersection point, if one exists, for two infinite lines on the XY plane.
            For 3D, use the Axis class and ClosestPoint function instead.
            This version also provides the parameters on the two lines - i.e. the multiplication factor necessary
            to apply to the line direction vector to get to the intersection point from the line origin.
            </summary>
            <param name="pt0">The origin point of the first line</param>
            <param name="v0">The direction of the first line</param>
            <param name="pt1">The origin point of the second line</param>
            <param name="v1">The direction of the second line</param>
            <param name="t0">The parameter on the first line</param>
            <param name="t1">The parameter on the second line</param>
            <returns>The XY intersection point, if one exists.  Else (the lines are null or parallel) Vector.Unset</returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.LineLineXY(Nucleus.Geometry.Line,Nucleus.Geometry.Line,System.Boolean)">
            <summary>
            Find the intersection point, if one exists, for two lines on the XY plane.
            By default, the lines will be treated as extending to infinity, but may optionally
            be bounded to not return intersections outside the extents of the lines themselves.
            </summary>
            <param name="lineA">The first line</param>
            <param name="lineB">The second line</param>
            <param name="bounded">If true, intersections outside the bounds of the line segments specified will be ignored.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.LineLineXY(Nucleus.Geometry.Line,Nucleus.Geometry.Line,Nucleus.Maths.Interval)">
            <summary>
            Find the intersection point, if one exists, for two lines on the XY plane.
            By default, the lines will be treated as extending to infinity, but may optionally
            be bounded to not return intersections outside the extents of the lines themselves.
            </summary>
            <param name="lineA">The first line</param>
            <param name="lineB">The second line</param>
            <param name="bounds">The parameter-space range on each line where intersections are valid</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.LineCircleXY(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,System.Double)">
            <summary>
            Find the intersection points, if any exist, for an infinite line and a circle on the XY plane,
            given as an array of doubles representing multiplication factors which should be applied to the
            line direction vector.  There may be one, two or zero intersection points.
            </summary>
            <param name="lineOrigin">The origin point of the line</param>
            <param name="lineDir">The direction vector of the line</param>
            <param name="circleCentre">The centre point of the circle</param>
            <param name="radius">The radius of the circle</param>
            <returns>An array of doubles representing the line parameters of the intersection points</returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.LineCircleXY(Nucleus.Geometry.Line,Nucleus.Geometry.Circle,System.Boolean)">
            <summary>
            Find the intersection points, if any exist, for a line and a circle on the
            XY plane.  Note that for the purposes of calculation both are assumed to lie
            on the XY plane even if they do not.
            By default, the line is assumed to be infinite, however the calculation may optionally
            be bounded to exclude intersections outside of the bounds of the specified line segment
            </summary>
            <param name="line">The line.</param>
            <param name="circle">The circle.  This should lie on the XY plane for the calculation to be accurate.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.LineArcXY(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Arc,System.Boolean)">
            <summary>
            Find the intersection points, if any exist, for a line and an arc on the XY plane.
            By default, the line is assumed to be infinite, however the calculation may optionally 
            be bounded to exclude intersections beyond the ends of the specified line segment
            </summary>
            <param name="lineOrigin">The start point of the line</param>
            <param name="lineVect">The vector from the start of the line to its end</param>
            <param name="arc">The arc</param>
            <param name="lineBounded">Optional.  If true, intersections which lie outside of
            the extents of the line will be ignored.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.LineArcXY(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Arc,Nucleus.Maths.Interval)">
            <summary>
            Find the intersection points, if any exist, for a line and an arc on the XY plane.
            By default, the line is assumed to be infinite, however the calculation may optionally 
            be bounded to exclude intersections beyond the ends of the specified line segment
            </summary>
            <param name="lineOrigin">The start point of the line</param>
            <param name="lineVect">The vector from the start of the line to its end</param>
            <param name="arc">The arc</param>
            <param name="lineBounds">The range on the line, as a proportion of the line length, where intersections
            will be valid.  0 will represent the start of the line and 1 its end.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.LineArcXY(Nucleus.Geometry.Line,Nucleus.Geometry.Arc)">
            <summary>
            Find the intersection points, if any exist, for a line and an arc on the XY plane
            </summary>
            <param name="line">The line</param>
            <param name="arc">The arc</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.LineArcXY(Nucleus.Geometry.Line,Nucleus.Geometry.Arc,Nucleus.Maths.Interval)">
            <summary>
            Find the intersection points, if any exist, for a portion of a line and an arc on the XY plane
            </summary>
            <param name="line">The line</param>
            <param name="arc">The arc</param>
            <param name="lineBounds">The range on the line, as a proportion of the line length, where intersections
            will be valid.  0 will represent the start of the line and 1 its end.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.CurveLineXY(Nucleus.Geometry.Curve,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,System.Collections.Generic.IList{System.Double},System.Double,System.Double)">
            <summary>
            Find the intersection(s) between a curve and an infinite line on the XY plane
            </summary>
            <param name="curve"></param>
            <param name="lnPt"></param>
            <param name="lnDir"></param>
            <returns>The list of intersection parameters on the curve</returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.CircleCircleXY(Nucleus.Geometry.Vector,System.Double,Nucleus.Geometry.Vector,System.Double)">
            <summary>
            Find the intersection(s) between two circles on the XY plane.
            </summary>
            <param name="pt0">The centre point of the first circle</param>
            <param name="r0">The radius of the first circle</param>
            <param name="pt1">The centre point of the second circle</param>
            <param name="r1">The radius of the second circle</param>
            <returns>An array of intersection points, which may contain 0, 1 or 2 points.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.CircleCircleXY(Nucleus.Geometry.Circle,Nucleus.Geometry.Circle)">
            <summary>
            Find the intersections between two circles on the XY plane.
            The provided circles will be assumed to lie on the XY plane even if
            they do not.
            </summary>
            <param name="c0">The first circle on the XY plane</param>
            <param name="c1">The second circle on the XY plane</param>
            <returns>An array of intersection points, which may contain 0, 1 or 2 points.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.ArcArcXY(Nucleus.Geometry.Arc,Nucleus.Geometry.Arc)">
            <summary>
            Find the intersections between two arcs on the XY plane.
            The provided arcs will be assumed to lie on the XY plane even if
            they do not.
            </summary>
            <param name="arc0">The first arc on the XY plane</param>
            <param name="arc1">The second arc on the XY plane</param>
            <returns>An array of intersection points, which may contain 0, 1 or 2 points.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.ArcArcXY(Nucleus.Geometry.Arc,Nucleus.Geometry.Arc,Nucleus.Maths.Interval)">
            <summary>
            Find the intersections between two arcs on the XY plane.
            The provided arcs will be assumed to lie on the XY plane even if
            they do not.
            </summary>
            <param name="arc0">The first arc on the XY plane</param>
            <param name="arc1">The second arc on the XY plane</param>
            <returns>An array of intersection points, which may contain 0, 1 or 2 points.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.CurveCurveXY(Nucleus.Geometry.ISimpleCurve,Nucleus.Geometry.ISimpleCurve,System.Double)">
            <summary>
            Find the intersections between two simple curves on the XY plane.
            </summary>
            <param name="crv0">The first curve</param>
            <param name="crv1">The second curve</param>
            <param name="endStartTolerance">The tolerance distance from the end of the first curve 
            within which intersections with the second will be ignored.  Enables self-intersection checks without
            false positives from matching curve ends.</param>
            <returns>An array of intersection points, which may contain 0, 1 or 2 points.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.LinePlane(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Find the intersection between an infinite line and an infinite plane.
            Expressed as a parameter t, the multiple of the lineDirection away from the lineOrigin
            at which the intersection takes place.  If no intersection (i.e. the line is parallel
            to the plane) will return double.NaN.
            </summary>
            <param name="lineOrigin">A point on the line</param>
            <param name="lineDirection">A direction vector for the line</param>
            <param name="planeOrigin">A point on the plane</param>
            <param name="planeNormal">A direction vector perpendicular to the plane</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.LinePlane(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.CoordinateAxis,System.Double)">
            <summary>
            Find the intersection between an infinite line and an infinite plane normal to one
            of the primary global axes.
            Expressed as a parameter t, the multiple of the lineDirection away from the lineOrigin
            at which the intersection takes place.  If no intersection (i.e. the line is parallel
            to the plane) will return double.NaN.
            </summary>
            <param name="lineOrigin">A point on the line</param>
            <param name="lineDirection">A direction vector for the line</param>
            <param name="dimension">The dimensional axis normal to the plane 
            (for e.g. entering Dimension.Z would utilise a XY plane)</param>
            <param name="planePosition">The position of the plane in the specified dimension</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.LineXYPlane(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,System.Double)">
            <summary>
            Find the intersection between an infinite line and an infinite plane aligned
            parallel to the global XY axes.
            Expressed as a parameter t, the multiple of the lineDirection away from the lineOrigin
            at which the intersection takes place.  If no intersection (i.e. the line is parallel
            to the plane) will return double.NaN.
            </summary>
            <param name="lineOrigin">A point on the line</param>
            <param name="lineDirection">A direction vector for the line</param>
            <param name="x">The z-coordinate of the plane.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.LineXZPlane(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,System.Double)">
            <summary>
            Find the intersection between an infinite line and an infinite plane aligned
            parallel to the global XZ axes.
            Expressed as a parameter t, the multiple of the lineDirection away from the lineOrigin
            at which the intersection takes place.  If no intersection (i.e. the line is parallel
            to the plane) will return double.NaN.
            </summary>
            <param name="lineOrigin">A point on the line</param>
            <param name="lineDirection">A direction vector for the line</param>
            <param name="y">The y-coordinate of the plane.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.LineYZPlane(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,System.Double)">
            <summary>
            Find the intersection between an infinite line and an infinite plane aligned
            parallel to the global YZ axes.
            Expressed as a parameter t, the multiple of the lineDirection away from the lineOrigin
            at which the intersection takes place.  If no intersection (i.e. the line is parallel
            to the plane) will return double.NaN.
            </summary>
            <param name="lineOrigin">A point on the line</param>
            <param name="lineDirection">A direction vector for the line</param>
            <param name="x">The x-coordinate of the plane.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.RayTriangle(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Calculate the intersection between a ray and a triangle using the
            Möller–Trumbore algorithm.  See:
            https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm.
            Returns the parameter t, being the multiplication of the rayDirection from the rayOrigin.
            If there is no intersection between the ray and the triangle, double.NaN will be returned.
            </summary>
            <param name="rayOrigin">The origin point of the ray</param>
            <param name="rayDirection">The direction of the ray.</param>
            <param name="tri0">The first corner of the triangle</param>
            <param name="tri1">The second corner of the triangle</param>
            <param name="tri2">The third corner of the triangle</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.RayFace(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,System.Collections.Generic.IList{Nucleus.Geometry.Vertex})">
            <summary>
            Calculate the intersection between a ray and a mesh face.
            Returns the parameter t, being the multiplication of the rayDirection from the rayOrigin.
            If there is no intersection between the ray and the face, double.NaN will be returned.
            </summary>
            <param name="rayOrigin">The origin point of the ray.</param>
            <param name="rayDirection">The direction of the ray.</param>
            <param name="face">The mesh face.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.RayFace(Nucleus.Geometry.Axis,System.Collections.Generic.IList{Nucleus.Geometry.Vertex})">
            <summary>
            Calculate the intersection between a ray and a mesh face.
            Returns the parameter t, being the multiplication of the ray Direction from the ray Origin.
            If there is no intersection between the ray and the face, double.NaN will be returned.
            </summary>
            <param name="ray">The ray.</param>
            <param name="face">The mesh face.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.RayMesh(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Mesh)">
            <summary>
            Calculate the intersection between a ray and a mesh.
            Returns the parameter t, being the multiplication of the rayDirection from the rayOrigin.
            If there is no intersection between the ray and the triangle, double.NaN will be returned.
            </summary>
            <param name="rayOrigin">The origin point of the ray.</param>
            <param name="rayDirection">The direction of the ray.</param>
            <param name="mesh">The mesh.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.RayMesh(Nucleus.Geometry.Axis,Nucleus.Geometry.Mesh)">
            <summary>
            Calculate the intersection between a ray and a mesh.
            Returns the parameter t, being the multiplication of the ray Direction from the ray Origin.
            If there is no intersection between the ray and the triangle, double.NaN will be returned.
            </summary>
            <param name="ray">The ray</param>
            <param name="mesh">The mesh</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.RayLineSegmentXY(Nucleus.Geometry.Vector@,Nucleus.Geometry.Vector@,Nucleus.Geometry.Vector@,Nucleus.Geometry.Vector@)">
            <summary>
            Find the intersection point between a ray half-line and a line segment on the XY plane, if one exists
            </summary>
            <param name="rayStart">The ray start point</param>
            <param name="rayDir">The ray direction</param>
            <param name="segStart">The start of the line segment</param>
            <param name="segEnd">The end of the line segment</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.LineSegmentsXY(Nucleus.Geometry.Vector@,Nucleus.Geometry.Vector@,Nucleus.Geometry.Vector@,Nucleus.Geometry.Vector@)">
            <summary>
            Find the intersection point between two line segments on the XY plane, if one exists
            </summary>
            <param name="startA">The start of the first line segment</param>
            <param name="endA">The end of the first line segment</param>
            <param name="startB">The start of the second line segment</param>
            <param name="endB">The end of the second line segment</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.XRayLineSegmentXYCheck(Nucleus.Geometry.Vector@,Nucleus.Geometry.Vector@,Nucleus.Geometry.Vector@,System.Boolean@)">
            <summary>
            A quick check on whether a half-line starting at the specified point and travelling parallel to the X-axis
            will intersect the specified segment on the XY plane.  Used in planar containment testing.
            </summary>
            <param name="rayStart"></param>
            <param name="segStart"></param>
            <param name="segEnd"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.OffsetExtensionDistance(Nucleus.Geometry.Angle,System.Double,System.Double)">
            <summary>
            Calculate the distance by which an offset of a line might be extended until it intersects
            with another offset line at an angle to it.  
            </summary>
            <param name="angle">The angle between line B and line A</param>
            <param name="offsetA">The offset of line A</param>
            <param name="offsetB">The offset of line B</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.CurveInPolygonXY(Nucleus.Geometry.Curve,System.Collections.Generic.IList{Nucleus.Geometry.Vertex})">
            <summary>
            Find the section(s) of a polycurve which lie(s) inside the specified polygon
            </summary>
            <param name="pLine"></param>
            <param name="polygon"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.PolyCurveInPolygonXY(Nucleus.Geometry.PolyCurve,System.Collections.Generic.IList{Nucleus.Geometry.Vertex},Nucleus.Geometry.CurveCollection)">
            <summary>
            Find the section(s) of a polycurve which lie(s) inside the specified polygon
            </summary>
            <param name="pLine"></param>
            <param name="polygon"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.PolyLineInPolygonXY(Nucleus.Geometry.PolyLine,System.Collections.Generic.IList{Nucleus.Geometry.Vertex},Nucleus.Geometry.CurveCollection)">
            <summary>
            Find the section(s) of a polyline which lie(s) inside the specified polygon
            </summary>
            <param name="pLine"></param>
            <param name="polygon"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.ArcInPolygonXY(Nucleus.Geometry.Arc,System.Collections.Generic.IList{Nucleus.Geometry.Vertex},Nucleus.Geometry.CurveCollection)">
            <summary>
            Find the section(s) of an arc which lie(s) inside the specified polygon
            </summary>
            <param name="arc"></param>
            <param name="polygon"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.LineInPolygonXY(Nucleus.Geometry.Line,System.Collections.Generic.IList{Nucleus.Geometry.Vertex},Nucleus.Geometry.CurveCollection)">
            <summary>
            Find the section(s) of a line which lie(s) inside the specified polygon
            </summary>
            <param name="line"></param>
            <param name="polygon"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.PolygonOverlapXY``1(System.Collections.Generic.IList{Nucleus.Geometry.Vertex},System.Collections.Generic.IList{Nucleus.Geometry.Vertex},System.Collections.Generic.IList{Nucleus.Geometry.Vertex})">
            <summary>
            Find the overlapping region(s) between two polygons, represented as sets of vertices.
            Uses an algorithm similar to that presented in Efficient Clipping of Arbitrary Polygons
            by Gunter Greiner and Kai Hormann: http://davis.wpi.edu/~matt/courses/clipping/.
            The returned polygons will be composed of the vertices of the previous polygons plus additional
            ones at the intersection points.  Note that you may need to create copies of these if the
            pre-existing vertices already form part of a separate geometry object.
            </summary>
            <param name="polygonA">The set of vertices representing the first polygon</param>
            <param name="polygonB">The set of vertices representing the second polygon</param>
            <param name="allVertices">Optional.  The collection of vertices, to which any vertices created during this process should be added</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.Intersect.LineLineIntersection">
            <summary>
            A class for storing line-line intersection events
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Intersect.LineLineIntersection.Vertex">
            <summary>
            The intersection point itself
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Intersect.LineLineIntersection.At">
            <summary>
            The intersection parameter on A
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Intersect.LineLineIntersection.Bt">
            <summary>
            The intersection parameter on B
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Intersect.LineLineIntersection.Entry">
            <summary>
            Is this intersection an entry from A into B (or, if false, an exit)?
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.LineLineIntersection.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Intersect.LineLineIntersection.#ctor(Nucleus.Geometry.Vertex,System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="point"></param>
            <param name="at"></param>
            <param name="bt"></param>
        </member>
        <member name="T:Nucleus.Geometry.MeshEdge">
            <summary>
            Structure that represents an edge between two vertices in a mesh.
            A temporary construct used during certain mesh operations - does not
            form part of the core definition of a mesh geometry
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.MeshEdge.Start">
            <summary>
            The vertex at the start of this edge
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.MeshEdge.End">
            <summary>
            The vertex at the end of this edge
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.MeshEdge.StartPoint">
            <summary>
            Get the start point of this edge
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.MeshEdge.EndPoint">
            <summary>
            Get the end point of this edge
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.MeshEdge.MidPoint">
            <summary>
            Get the mid point of this edge
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.MeshEdge.Length">
            <summary>
            Get the length of this edge
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.MeshEdge.LengthSquared">
            <summary>
            Get the squared length of this edge
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.MeshEdge.#ctor(Nucleus.Geometry.Vertex,Nucleus.Geometry.Vertex)">
            <summary>
            Constructor, initialising an edge between the two specified vertices
            </summary>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="M:Nucleus.Geometry.MeshEdge.ToLine">
            <summary>
            Convert this edge to a line
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshEdge.op_Equality(Nucleus.Geometry.MeshEdge,Nucleus.Geometry.MeshEdge)">
            <summary>
            Tests whether the two edges are equal.
            Direction does not matter for two edges to be equal.
            </summary>
            <param name="edge1"></param>
            <param name="edge2"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshEdge.op_Inequality(Nucleus.Geometry.MeshEdge,Nucleus.Geometry.MeshEdge)">
            <summary>
            Tests whether the two edges are not equal.
            Direction does not matter for two edges to be equal.
            </summary>
            <param name="edge1"></param>
            <param name="edge2"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.PlanarRegion">
            <summary>
            A planar surface described by a perimeter boundary curve and (optionally)
            a set of 'cut out' perimeter voids.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.PlanarRegion._Perimeter">
            <summary>
            Private backing field for Perimeter property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.PlanarRegion.Perimeter">
            <summary>
            The outer perimeter boundary curve of this surface
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.PlanarRegion._Voids">
            <summary>
            Private backing field for Voids property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.PlanarRegion.Voids">
            <summary>
            The collection of curves that describe the boundaries of void regions
            'cut out' of this surface
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.PlanarRegion.HasVoids">
            <summary>
            Does this surface have any voids defined?
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.PlanarRegion._Plane">
            <summary>
            Private backing field for Plane property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.PlanarRegion.Plane">
            <summary>
            The plane of this surface.
            This may be null if the definition is not valid.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.PlanarRegion.Vertices">
            <summary>
            The collection of vertices which are used to define the geometry of this shape.
            Different shapes will provide different means of editing this collection.
            DO NOT directly modify the collection returned from this property unless you are
            sure you know what you are doing.
            For PlanarSurfaces, this will generate a combined collection of all definition curve
            vertices.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.PlanarRegion.#ctor">
            <summary>
            Default constructor.  Initialises a new PlanarSurface with no geometry.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.PlanarRegion.#ctor(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.GeometryAttributes)">
            <summary>
            Initialises a new quadrangular PlanarRegion with the specified corner points.
            The four points specified should all lie on the same plane for the resulting surface to be valid.
            </summary>
            <param name="pt0"></param>
            <param name="pt1"></param>
            <param name="pt2"></param>
            <param name="pt3"></param>
            <param name="attributes"></param>
        </member>
        <member name="M:Nucleus.Geometry.PlanarRegion.#ctor(Nucleus.Geometry.Vector[])">
            <summary>
            Initialises a new PlanarRegion with the specified edge vertices.
            There should be a minimum of three points given and all should lie on the same
            plane for the resulting surface to be valid.
            </summary>
            <param name="pts"></param>
        </member>
        <member name="M:Nucleus.Geometry.PlanarRegion.#ctor(Nucleus.Geometry.Curve,Nucleus.Geometry.GeometryAttributes)">
            <summary>
            Initialises a new PlanarSurface with the specified perimeter curve.
            </summary>
            <param name="perimeter"></param>
        </member>
        <member name="M:Nucleus.Geometry.PlanarRegion.#ctor(Nucleus.Geometry.Curve,Nucleus.Geometry.CurveCollection,Nucleus.Geometry.GeometryAttributes)">
            <summary>
            Initialises a new PlanarSurface with the specified perimeter and void curves.
            </summary>
            <param name="perimeter"></param>
            <param name="voids"></param>
        </member>
        <member name="M:Nucleus.Geometry.PlanarRegion.CalculateArea(Nucleus.Geometry.Vector@)">
            <summary>
            Calculate the area of this region
            </summary>
            <param name="centroid"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PlanarRegion.ContainsXY(Nucleus.Geometry.Vector)">
            <summary>
            Does the specified point fall within this region?
            </summary>
            <param name="pt">The point to test</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PlanarRegion.SplitByLineXY(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,System.Double)">
            <summary>
            Split this region into two (or more) sub-regions along a straight line
            </summary>
            <param name="splitPt">A point on the splitting line</param>
            <param name="splitDir">The direction of the line</param>
            <param name="splitWidth">Optional.  The width of the split.</param>
            <returns>The resultant list of regions.  If the line does not bisect
            this region and the region could not be split, this collection will contain
            only the original region.</returns>
        </member>
        <member name="T:Nucleus.Geometry.Point">
            <summary>
            A point geometry object, consisting only of a single vertex.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Point._Vertex">
            <summary>
            Private backing field for Vertex property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Point.Vertex">
            <summary>
            The single vertex that represents the geometry of this Point
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Point.IsValid">
            <summary>
            Is this point geometry valid?
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Point.Position">
            <summary>
            Get the position vector of this Point
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Point.#ctor">
            <summary>
            Default parameterless constructor
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Point.#ctor(Nucleus.Geometry.GeometryAttributes)">
            <summary>
            Protected parameterless constructor
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Point.#ctor(Nucleus.Geometry.Vertex,Nucleus.Geometry.GeometryAttributes)">
            <summary>
            Vertex constructor.   Initialises this Point object with the specified vertex.
            </summary>
            <param name="vertex"></param>
        </member>
        <member name="M:Nucleus.Geometry.Point.#ctor(Nucleus.Geometry.Vector,Nucleus.Geometry.GeometryAttributes)">
            <summary>
            Position vector constructor.
            Creates a Point object at the specified position.
            </summary>
            <param name="position"></param>
        </member>
        <member name="M:Nucleus.Geometry.Point.#ctor(System.Double,System.Double,System.Double,Nucleus.Geometry.GeometryAttributes)">
            <summary>
            Coordinates constructor.
            Creates a Point object at the specified coordinates.
            </summary>
            <param name="position"></param>
        </member>
        <member name="T:Nucleus.Geometry.Label">
            <summary>
            A geometry object representing a text label
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Label._Text">
            <summary>
            Private backing field for Text property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Label.Text">
            <summary>
            The text to be displayed by this label
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Label._TextBinding">
            <summary>
            Private backing field for the TextBinding property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Label.TextBinding">
            <summary>
            Optional binding for the label's Text property.
            Allows for a source object and path to be specified
            from which the value of the Text property will be retrieved,
            overriding the locally defined value.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Label._TextSize">
            <summary>
            Private backing field for TextHeight property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Label.TextSize">
            <summary>
            The display height of characters in the label 
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Label._HorizontalSetOut">
            <summary>
            Private backing field for HorizontalSetOut property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Label.HorizontalSetOut">
            <summary>
            The horizontal set-out of the text relative to the specified position
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Label._VerticalSetOut">
            <summary>
            Private backing field for VerticalSetOut property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Label.VerticalSetOut">
            <summary>
            The vertical set-out of the text relative to the specified position
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Label.#ctor">
            <summary>
            Default constructor.  Initialises a new Label with no data
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Label.#ctor(Nucleus.Geometry.Vector,System.String,System.Double,Nucleus.Geometry.VerticalSetOut,Nucleus.Geometry.HorizontalSetOut,Nucleus.Geometry.GeometryAttributes)">
            <summary>
            Initialises a new label with the specified position and text
            </summary>
            <param name="position">The position the text will start</param>
            <param name="text">The text</param>
            <param name="textSize">The height of the text</param>
        </member>
        <member name="M:Nucleus.Geometry.Label.#ctor(Nucleus.Geometry.Vector,Nucleus.Base.PathBinding,System.Double,Nucleus.Geometry.VerticalSetOut,Nucleus.Geometry.HorizontalSetOut,Nucleus.Geometry.GeometryAttributes)">
            <summary>
            Initialises a new label with a bound text value
            </summary>
            <param name="position"></param>
            <param name="textBinding"></param>
            <param name="textSize"></param>
            <param name="verticalSetOut"></param>
            <param name="horizontalSetOut"></param>
            <param name="attributes"></param>
        </member>
        <member name="T:Nucleus.Geometry.VertexRule">
            <summary>
            Abstract base class for rules which are applied to vertices in
            order to define their position by reference to some other object
            and/or criteria.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.VertexRule.ApplyRule(Nucleus.Geometry.Vertex)">
            <summary>
            Apply this rule to the vertex.  This may result in the specified vertex being
            moved or deleted.
            </summary>
            <param name="toVertex">The vertex that the rule is to be applied to.</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.WeightedVertex">
            <summary>
            A subclass of Vertex which in addition to the normal
            vertex functionality allows for this vertex to be assigned a 'weight'
            value to be used during certain geometric calculations (e.g. Voronoi cell generation)
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.WeightedVertex._Weighting">
            <summary>
            Private backing field for Weighting property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.WeightedVertex.Weighting">
            <summary>
            The weighting of this vertex
            </summary>
        </member>
        <member name="T:Nucleus.Geometry.Angle">
            <summary>
            An angle expressed in radians.
            Represented by an immutable struct wrapping a double value.
            Implicit converters to and from the double type are provided,
            so this type can be used as though it were an ordinary double.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Angle.Undefined">
            <summary>
            An undefined, invalid angle
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Angle.Zero">
            <summary>
            A zero angle
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Angle.Right">
            <summary>
            A right angle, PI/2 (or 90 degrees)
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Angle.Straight">
            <summary>
            A straignt angle, PI (or 180 degrees)
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Angle.Complete">
            <summary>
            A complete angle, 2*PI (or 360 degrees)
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Angle.Multi">
            <summary>
            An angle value representing multiple angles together
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Angle.Radians">
            <summary>
            The angle expressed in radians
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Angle.Degrees">
            <summary>
            Get the angle expressed in degrees
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Angle.IsAcute">
            <summary>
            Is this an acute angle - i.e. is it lower than PI/2 (90 degrees)?
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Angle.IsObtuse">
            <summary>
            Is this an obtuse angle - i.e is it greater than PI/2 (90 degrees) but
            lower than PI (180 degrees)?
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Angle.IsReflex">
            <summary>
            Is this a reflex angle - i.e. is it greater than PI (180 degrees)?
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Angle.IsUndefined">
            <summary>
            Is this angle undefined (i.e. is it's Radians value NaN?)
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Angle.IsMulti">
            <summary>
            Does this value represent multiple different angles?
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Angle.IsTiny">
            <summary>
            Is this angle so small it can be safely treated as 0?
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Angle.#ctor(System.Double)">
            <summary>
            Initialises the angle to the specified radians value.
            </summary>
            <param name="radians">The value of the angle in radians</param>
        </member>
        <member name="M:Nucleus.Geometry.Angle.#ctor(Nucleus.Geometry.Angle)">
            <summary>
            Initialises the angle as a copy of another
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Nucleus.Geometry.Angle.#ctor(System.String)">
            <summary>
            Initialise the angle from a text string.
            Valid input values are numeric strings which may optionally
            end with 'π' or '°' to denote values specified in multiples
            of PI or degrees respectively.
            </summary>
            <param name="description"></param>
        </member>
        <member name="M:Nucleus.Geometry.Angle.Normalize">
            <summary>
            Normalize this angle to between -PI and +PI
            </summary>
            <returns>A normalised copy of this angle</returns>
        </member>
        <member name="M:Nucleus.Geometry.Angle.NormalizeTo2PI">
            <summary>
            Normalise this angle to between 0 and 2*PI
            </summary>
            <returns>A normalised copy of this angle</returns>
        </member>
        <member name="M:Nucleus.Geometry.Angle.Direction">
            <summary>
            Get a unit vector describing the direction of this angle on the
            XY plane.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Angle.Explement">
            <summary>
            Get the Explement of this angle.  This is the angle which,
            when summed with this angle, adds up to a complete angle.
            This will be either positive or negative to match the sign
            of the angle.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Angle.Sin">
            <summary>
            Get the sine of this angle
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Angle.Cos">
            <summary>
            Get the cosine of this angle
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Angle.Tan">
            <summary>
            Get the tangent of this angle
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Angle.Abs">
            <summary>
            Return the absolute (i.e. unsigned) value of this angle
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Angle.Sign">
            <summary>
            Gets the sign of the angle, expressed as +1 for positive numbers
            and -1 for negative ones.  Zero is treated as being positive in this
            instance.
            </summary>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nucleus.Geometry.Angle.ToSign(System.Int32)" -->
        <member name="M:Nucleus.Geometry.Angle.FromDegrees(System.Double)">
            <summary>
            Create an angle from a value expressed in degrees
            </summary>
            <param name="degrees"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Angle.MetersPerDegreeLatitude(Nucleus.Geometry.Angle)">
            <summary>
            Calculate the equivalent number of meters per degree of latitude at the
            specified reference latitude, taking account of the elliptical nature of
            the Earth.  Should be accurate to within 1m per degree anywhere on the Earth.  
            Based on this article: 
            https://knowledge.safe.com/articles/725/calculating-accurate-length-in-meters-for-lat-long.html
            </summary>
            <param name="rLatitude">The reference latitude at which the conversion is to take place</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Angle.MetersPerDegreeLongitude(Nucleus.Geometry.Angle)">
            <summary>
            Calculate the equivalent number of meters per degree of longitude at the
            specified reference latitude, taking account of the elliptical nature of
            the Earth.  Should be accurate to within 1m per degree anywhere on the Earth.  
            Based on this article: 
            https://knowledge.safe.com/articles/725/calculating-accurate-length-in-meters-for-lat-long.html
            </summary>
            <param name="rLatitude">The reference latitude at which the conversion is to take place</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Angle.op_Implicit(Nucleus.Geometry.Angle)~System.Double">
            <summary>
            Implicit conversion to a double
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Nucleus.Geometry.Angle.op_Implicit(System.Double)~Nucleus.Geometry.Angle">
            <summary>
            Implicit conversion from a double
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:Nucleus.Geometry.IShapePosition">
            <summary>
            Interface for objects which describe a position on a shape
            </summary>
        </member>
        <member name="T:Nucleus.Geometry.IShapePosition`1">
            <summary>
            Generic version of the IShapePosition interface.
            Allows the type of shape the position is applicable to
            to be defined.
            </summary>
            <typeparam name="TShape"></typeparam>
        </member>
        <member name="M:Nucleus.Geometry.IShapePosition`1.PointOn(`0)">
            <summary>
            Get the point on the shape that this object
            describes as a Vector
            </summary>
            <param name="shape"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.Mesh">
            <summary>
            A type of surface represented by a mesh of vertices and triangular or quadrangular faces
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Mesh.IsValid">
            <summary>
            Is this mesh valid?
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Mesh._Vertices">
            <summary>
            Private backing field for Vertices collection
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Mesh.Vertices">
            <summary>
            The collection of vertices which are used to define the geometry of this shape.
            The mesh may contain as many vertices as you like, with the connecting topology
            described by the Faces collection.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Mesh._Faces">
            <summary>
            Private backing field for Faces property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Mesh.Faces">
            <summary>
            The collection of faces which describe the topology of the mesh.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Mesh.FaceCount">
            <summary>
            Get the total number of faces in the mesh
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.#ctor(System.Collections.Generic.IList{Nucleus.Geometry.Vector})">
            <summary>
            Initialise a mesh with the specified set of vertex locations
            </summary>
            <param name="points"></param>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.#ctor(System.Collections.Generic.IList{Nucleus.Model.Node},System.Boolean)">
            <summary>
            Initialise a mesh with the specified set of nodes.
            </summary>
            <param name="nodes">The collection of nodes.  Vertices will
            be created at the node locations and bound to the nodes.</param>
            <param name="addFace">If true, a face will be added to the mesh joining all of the
            vertices.</param>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.#ctor(Nucleus.Geometry.VertexCollection,Nucleus.Geometry.MeshFaceCollection)">
            <summary>
            Initialise a mesh with the specified vertices and faces.
            The vertices used should not already form part of any other geometry definition.
            </summary>
            <param name="verts"></param>
            <param name="faces"></param>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.AddVertex(Nucleus.Geometry.Vector)">
            <summary>
            Add a new vertex to this mesh
            </summary>
            <param name="position"></param>
            <returns>The index of the new vertex</returns>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.AddFace(System.Int32,System.Int32,System.Int32)">
            <summary>
            Add a new triangular face to this mesh.
            The vertex indices provided should reference valid vertices
            already added to this mesh.
            </summary>
            <param name="v0">The first vertex index</param>
            <param name="v1">The second vertex index</param>
            <param name="v2">The third vertex index</param>
            <returns>The index of the new face</returns>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.AddFace(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Add a new quadrangular face to this mesh.
            The vertex indices provided should reference valid vertices
            already added to this mesh.
            </summary>
            <param name="v0">The first vertex index</param>
            <param name="v1">The second vertex index</param>
            <param name="v2">The third vertex index</param>
            <param name="v3">The fourth vertex index</param>
            <returns>The index of the new face</returns>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.AddFace(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Add a new face to this mesh.
            The vertex indices provided should reference valid vertices
            already added to this mesh.
            </summary>
            <param name="vertexIndices">The vertex indices which the 
            face should join</param>
            <returns>The index of the new face</returns>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.CalculateArea">
            <summary>
            Calculate the surface area of this mesh's faces.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.CalculateArea(Nucleus.Geometry.Vector@)">
            <summary>
            Calculate the surface area of this mesh's faces.
            NOTE: CENTROID CALCULATION NOT CURRENTLY IMPLEMENTED
            </summary>
            <param name="centroid"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.FlipNormals">
            <summary>
            Invert the direction of all the face normals in this mesh by reversing
            the order of vertices in all faces.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.AlignNormals(Nucleus.Geometry.Vector)">
            <summary>
            Re-order the vertices in the faces of this mesh if necessary so that the
            face normals are aligned as closely as possible with the specified
            vector.
            </summary>
            <param name="alignTo">The vector to align the normals with</param>
            <returns>True if any face was flipped, false if all remained as-was.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.AssignVertexNumbers(System.Int32)">
            <summary>
            Assign numbers to the vertices in this mesh based on their position in the collection.
            The vertex Number property will be written to and may be overwritten if a previous value
            has been stored there.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.GenerateEdgeLinks">
            <summary>
            Generate a list of the links between edges in this mesh
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.GenerateDivisionEdges">
            <summary>
            Generate a set of division edges for use in face subdivision
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.Refined(System.Double)">
            <summary>
            Returns a subdivided refinement of 
            </summary>
            <param name="maxEdgeLength"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.LocalCoordinateSystem(System.Int32,System.Double,System.Double,Nucleus.Geometry.Angle,Nucleus.Geometry.Angle)">
            <summary>
            Get the local coordinate system of a point on the mesh
            </summary>
            <param name="i">The face index</param>
            <param name="u"></param>
            <param name="v"></param>
            <param name="orientation"></param>
            <param name="xLimit"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.ProjectPoint(Nucleus.Geometry.Vector)">
            <summary>
            Project the specified point onto this mesh along the global
            z-axis, returning all z-coordinates 
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.ToOBJ">
            <summary>
            Write this mesh to a string in OBJ format
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.ToOBJ(Nucleus.Base.FilePath)">
            <summary>
            Write this mesh to a file in OBJ format
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.ToOBJ(System.IO.Stream)">
            <summary>
            Write this mesh to a stream in OBJ format
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.ToOBJ(System.IO.TextWriter)">
            <summary>
            Write this mesh to a stream in OBJ format
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.FromOBJ(System.String)">
            <summary>
            Load mesh geometry in Wavefront OBJ format from a string.
            The new geometry will be added to any existing already in this mesh.
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.FromOBJ(System.IO.Stream)">
            <summary>
            Load mesh geometry in Wavefront OBJ format from a stream.
            The new geometry will be added to any existing already in this mesh.
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.FromOBJ(System.IO.TextReader)">
            <summary>
            Load mesh geometry in Wavefront OBJ format.
            The new geometry will be added to any existing already in this mesh.
            </summary>
            <param name="reader"></param>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.DelaunayTriangulationXY(Nucleus.Geometry.VertexCollection,Nucleus.Geometry.MeshFaceCollection,Nucleus.Geometry.BoundingBox,System.Boolean,Nucleus.Geometry.VertexCollection)">
            <summary>
            Generate a set of mesh faces that represent a delaunay triangulation in the XY plane of the
            specified set of vertices.
            Based on the algorithm described here: http://paulbourke.net/papers/triangulate/
            </summary>
            <param name="vertices">The vertices to mesh between</param>
            <param name="faces">Optional.  The face collection to which to add the triangles.
            If null or ommitted, a new MeshFaceCollection will be created.</param>
            <param name="bounds">The bounding box that contains the triangulation.  Should encompass all vertices
            and, for later voronoi generation, any bounding geometry.  If null, the bounding box of the vertices
            themselves will be used.</param>
            <param name="clean">Clean up construction Super Triangle.  If true, any remaining fragments of the
            initial generating supertriangle will be removed from the output face list.  Set this to false
            if planning on using this mesh for subsequent voronoi generation so that the edge cells can be extended.</param>
            <param name="outerVerts">Optional.  If input and non-null, this collection will be populated with the exterior vertices - those connected
            to the original supertriangle.  If 'clean' is false, this will instead return the supertriangle vertices.</param>
        </member>
        <member name="M:Nucleus.Geometry.Mesh.VoronoiFromDelaunay(Nucleus.Geometry.VertexCollection,Nucleus.Geometry.MeshFaceCollection,System.Boolean)">
            <summary>
            Convert a set of mesh faces generated via delaunay triangulation into its dual -
            the voronoi diagram of the vertices.
            </summary>
            <param name="triangles"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.MeshFace">
            <summary>
            Mesh face representation.  Describes a face which connects three or more
            vertices in a mesh.  The face is defined as a series of vertex indices in the
            parent mesh.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.MeshFace._GUID">
            <summary>
            Internal backing member for GUID property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.MeshFace.GUID">
            <summary>
            The GUID of this object, which can be used to uniquely identify it. 
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.MeshFace.IsValid">
            <summary>
            Is this mesh face definition valid?
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.MeshFace.IsTri">
            <summary>
            Is this mesh face triangular?
            i.e. does it have three vertices?
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.MeshFace.IsQuad">
            <summary>
            Is this mesh face quadrangular?
            i.e. does it have four vertices?
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.MeshFace.XYCircumcentre">
            <summary>
            Get the circumcentre of the first three vertices of this face on the XY plane
            </summary>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Geometry.MeshFace.Normal">
            <summary>
            Get the normal vector of this face
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.#ctor(Nucleus.Geometry.Vertex,Nucleus.Geometry.Vertex,Nucleus.Geometry.Vertex)">
            <summary>
            Initialise a triangular mesh face between the three specified vertices
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="v3"></param>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.#ctor(Nucleus.Geometry.Vertex,Nucleus.Geometry.Vertex,Nucleus.Geometry.Vertex,Nucleus.Geometry.Vertex)">
            <summary>
            Initialise a quadrangular mesh face between the four specified vertices
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="v3"></param>
            <param name="v4"></param>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.#ctor(Nucleus.Geometry.MeshEdge,Nucleus.Geometry.Vertex)">
            <summary>
            Initialise a triangular mesh face between an edge and a vertex
            </summary>
            <param name="edge"></param>
            <param name="v"></param>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.#ctor(System.Collections.Generic.IList{Nucleus.Geometry.Vertex})">
            <summary>
            Initialise a MeshFace containing the specified set of vertices
            </summary>
            <param name="vertices">A set of vertices to use to build this face.</param>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.Set(Nucleus.Geometry.Vertex,Nucleus.Geometry.Vertex,Nucleus.Geometry.Vertex)">
            <summary>
            Set the vertices of this face
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="v3"></param>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.Set(Nucleus.Geometry.Vertex,Nucleus.Geometry.Vertex,Nucleus.Geometry.Vertex,Nucleus.Geometry.Vertex)">
            <summary>
            Set the vertices of this face
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="v3"></param>
            <param name="v4"></param>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.Set(System.Collections.Generic.IList{Nucleus.Geometry.Vertex})">
            <summary>
            Set the vertices of this face
            </summary>
            <param name="vertices"></param>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.GetEdgeVector(System.Int32)">
            <summary>
            Get the vector describing the path along the edge
            starting with the vertex at the specified index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.GetEdge(System.Int32)">
            <summary>
            Get the edge of this face at the specified index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.GetEdges">
            <summary>
            Get all edges of this face
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.GetEdgeLink(System.Int32)">
            <summary>
            Get the edge link of this face at the specified index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.GetEdgeNumberKey(System.Int32)">
            <summary>
            Generate a short string description of this edge in the format
            "[Lowest Vertex Number]:[Highest Vertex Number]".  This can be used
            as a key to check for shared edges easily.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.EnsureEdgeLinkGeneration(System.Int32,System.Collections.Generic.Dictionary{System.String,Nucleus.Geometry.MeshEdgeLink})">
            <summary>
            Ensure that the edge link at the specified index has been included in the specified dictionary
            </summary>
            <param name="index">The edge index</param>
            <param name="linkDictionary"></param>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.EnsureEdgeLinkGeneration(System.Collections.Generic.Dictionary{System.String,Nucleus.Geometry.MeshEdgeLink})">
            <summary>
            Ensure that edge links for this face have been included in the specified dictionary
            </summary>
            <param name="linkDictionary"></param>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.ClosestPoint(Nucleus.Geometry.Vector)">
            <summary>
            Find the closest point on this mesh face to a test point, expressed as a
            vector in 3d space.  This may be a position on the face or it may
            be an edge of the face depending on the relative location
            of the test point.
            </summary>
            <param name="toPoint">The test point to find the closest point to</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.ClosestEdge(Nucleus.Geometry.Vector)">
            <summary>
            Find the index of the closest edge in this mesh face to the specified point
            </summary>
            <param name="toPoint">The point to check against</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.DistanceToEdgeSquared(System.Int32,Nucleus.Geometry.Vector)">
            <summary>
            Calculate the square of the distance from the specified position to the edge at the specified index
            </summary>
            <param name="index">The edge index to test against</param>
            <param name="point">The point to test</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.EdgeLengthSquared(System.Int32)">
            <summary>
            Get the squared length of the edge at the specified index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.EdgeLength(System.Int32)">
            <summary>
            Get the length of the edge at the specified index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.LongestEdge">
            <summary>
            Get the index of the longest edge of this face
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.ShortetEdge">
            <summary>
            Get the index of the shortest edge of this face
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.LongestEdgeLengthSquared">
            <summary>
            Get the squared length of the longest edge of this face
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.LongestEdgeLength">
            <summary>
            Get the length of the longest edge of this face
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.IsSharedEdge(System.Int32,Nucleus.Geometry.MeshFace,System.Int32@)">
            <summary>
            Is the edge at the specified index shared with the specified other face?
            </summary>
            <param name="index">The edge index</param>
            <param name="withFace">The face to check against</param>
            <param name="otherEdgeIndex">The index of the shared edge on the other face</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.IsSharedEdge(System.Int32,Nucleus.Geometry.MeshFace)">
            <summary>
            Is the edge at the specified index shared with the specified other face?
            </summary>
            <param name="index">The edge index</param>
            <param name="withFace">The face to check against</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.SharedEdgeIndex(Nucleus.Geometry.MeshFace,System.Int32@)">
            <summary>
            Find the index of the edge of this face which is shared with.
            If the result is -1, no shared edge could be found.
            </summary>
            <param name="withFace">The face to check against</param>
            <param name="otherEdgeIndex">The index of the shared edge 
            on the other face</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.ExtractPoints">
            <summary>
            Extract the position vectors of all vertices in this face to
            an array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.GetBoundary">
            <summary>
            Get the curve that describes the boundary of this face
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.CalculateXYCircumcentre">
            <summary>
            Find the circumcentre of the first three vertices of this face on the XY plane
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.WeightedVoronoiPoints(System.Collections.Generic.Dictionary{Nucleus.Geometry.Vertex,Nucleus.Geometry.MeshFace})">
            <summary>
            DOES NOT WORK!  DO NOT USE!
            </summary>
            <param name="cells"></param>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.XYCircumcircleContainmentQuickCheck(Nucleus.Geometry.Vertex)">
            <summary>
            Tests whether a point lies in the circumcircle of this face.  Used during delaunay
            triangulation on the XY plane.
            Currently works only for triangle faces which are counterclockwise on XY plane.
            Hence declared internal until it can be made more robust.
            </summary>
            <param name="point">The position vector to test</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.ContainsAnyVertex(Nucleus.Geometry.VertexCollection)">
            <summary>
            Does this face contain any vertex in the specified list of vertices?
            </summary>
            <param name="other">The other mesh face to test against</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.SharedVertexCount(System.Collections.Generic.IEnumerable{Nucleus.Geometry.Vertex})">
            <summary>
            Count the number of vertices in the specified collection that
            also form part of this face
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.SharedEdgeLengthSquared(Nucleus.Geometry.MeshFace)">
            <summary>
            Find the length of the first found edge shared with the specified other face.
            If no shared edge exists, will return 0.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.SharedEdgeSquareness(Nucleus.Geometry.MeshFace)">
            <summary>
            Calculate the 'squareness' of the resultant face if this
            face were to be joined with another one.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.SumOfDotProductsOfEdgesNotIn(Nucleus.Geometry.MeshFace)">
            <summary>
            Calculate the sum of dot products of adjacent edges of this face
            which are not shared with the specified connected face.
            Used in determining face 'squareness' for face quadrangulation.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.SortVerticesAntiClockwise(Nucleus.Geometry.Vector)">
            <summary>
            Sort the vertices of this face counter-clockwise around the specified point
            in plan (i.e. in the XY plane).  This will essentially align this face 'upwards'.
            Note that this will only work in the case of convex polygons where the ordering
            of vertices is not important.
            </summary>
            <param name="aroundPt"></param>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.SortVerticesAntiClockwise">
            <summary>
            Sort the vertices of this face counter-clockwise about the circumcentre
            of the first three vertices of the face in the XY plane.  This will essentially
            align this face 'upwards'.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.IsClockwiseXY">
            <summary>
            Is this face clockwise in the XY plane?
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.MergeWith(Nucleus.Geometry.MeshFace)">
            <summary>
            Merge this mesh face together with another, adjacent one
            to form a single larger face
            </summary>
            <param name="other">The mesh face to merge with this one.
            Must share two vertices and one edge with this face and be in the same orientation.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.CalculateArea">
            <summary>
            Calculate the surface area of this face using the half cross-product formula.
            For quad and n-gon faces, the face will be treated as a triangle fan around the first vertex
            (i.e. it is assumed to be non-reentrant).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.CalculateNormal">
            <summary>
            Calculate the normal vector for this face
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.FlipNormal">
            <summary>
            Re-order the vertices in this face so that the face normal
            faces in the opposite direction.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.AlignNormal(Nucleus.Geometry.Vector)">
            <summary>
            Re-order the vertices in this face if necessary so that the
            face normal is aligned as closely as possible with the specified
            vector.
            </summary>
            <param name="alignTo">The vector to align the normal with</param>
            <returns>True if the face was flipped, false if it remained as-was.</returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.GetPlane">
            <summary>
            Calculate and return the plane defined by the first three vertices of this
            face.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.ProjectPoint(Nucleus.Geometry.Vector)">
            <summary>
            Project a point along the global Z-axis onto this mesh face.
            Returns the Z-coordinate of the projected point or double.NaN
            if the point does not lie within the triangle on the XY plane.
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.ToIndexArray">
            <summary>
            Convert this mesh face into an array of integers
            representing the indices of the vertices in this face.
            The 'Number' property of the face vertices should
            have been populated prior to calling this function (for
            e.g. via the AssingVertexIndices function on VertexCollection)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.Refine(System.Collections.Generic.IList{Nucleus.Meshing.MeshDivisionEdge},Nucleus.Geometry.MeshFaceCollection)">
            <summary>
            Refine and subdivide this face based on the specified set of pre-divided edges
            </summary>
            <param name="edges"></param>
            <param name="addTo"></param>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.OppositeEdgeIndices">
            <summary>
            Generate an array which indicates, for each edge around this
            face, which is designated the 'opposite' edge.
            In the case of quads and n-gons with an even number of sides,
            this is the edge offset by Count/2 places.
            In the case of tris or faces with odd numbers of sides, the shortest,
            side is skipped and has no opposite.  This is indicated in the result
            with a value of -1.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.RefinementVertex(Nucleus.Meshing.MeshDivisionEdge,Nucleus.Meshing.MeshDivisionEdge,Nucleus.Geometry.Vector,System.Int32)">
            <summary>
            Generate a new vertex 
            </summary>
            <param name="edge1"></param>
            <param name="edge2"></param>
            <param name="midPt"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFace.MedialAxisPoints">
            <summary>
            Calculate the branch points of the medial axis skeleton within
            this face, returned as an array of points
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.MeshFaceCollection">
            <summary>
            A collection of mesh face objects
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.MeshFaceCollection.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.MeshFaceCollection.#ctor(System.Collections.Generic.IEnumerable{Nucleus.Geometry.MeshFace})">
            <summary>
            Initialise this collection with the specified set of faces
            </summary>
            <param name="faces"></param>
        </member>
        <member name="M:Nucleus.Geometry.MeshFaceCollection.#ctor(Nucleus.Geometry.MeshFace)">
            <summary>
            Initialise this collection containing the specified face
            </summary>
            <param name="face"></param>
        </member>
        <member name="M:Nucleus.Geometry.MeshFaceCollection.RemoveAllWithVertices(Nucleus.Geometry.VertexCollection)">
            <summary>
            Remove from this collection all faces which contain any vertices
            shared with the specified vertex collection
            </summary>
            <param name="vertices"></param>
        </member>
        <member name="M:Nucleus.Geometry.MeshFaceCollection.AllWithVertices(Nucleus.Geometry.VertexCollection)">
            <summary>
            Get all mesh faces in this collection that contain any vertices
            shared with the specified vertex collection
            </summary>
            <param name="vertices"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFaceCollection.ExtractFaceBoundaries">
            <summary>
            Extract the boundary curves of each mesh face in this collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFaceCollection.ExtractVertices">
            <summary>
            Extract all vertices belonging to the faces in this collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFaceCollection.TrimToPolygonXY(System.Collections.Generic.IList{Nucleus.Geometry.Vertex},System.Collections.Generic.IList{Nucleus.Geometry.Vertex})">
            <summary>
            Trim this collection of faces to only those which fit within the specified boundary polygon
            on the XY plane
            </summary>
            <param name="boundary"></param>
            <param name="vertices">Optional.  The collection of vertices to which new vertices created during
            this process should be added.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFaceCollection.CullOutsideXY(System.Collections.Generic.IList{Nucleus.Geometry.Vector})">
            <summary>
            Remove from this collection any faces whose circumcentre falls outside the specified boundary on the XY plane
            </summary>
            <param name="boundary"></param>
        </member>
        <member name="M:Nucleus.Geometry.MeshFaceCollection.CullOutsideXY(Nucleus.Geometry.Curve)">
            <summary>
            Remove from this collection any faces whose circumcentre falls outside the specified boundary on the XY plane
            </summary>
            <param name="boundary"></param>
        </member>
        <member name="M:Nucleus.Geometry.MeshFaceCollection.CullInsideXY(System.Collections.Generic.IList{Nucleus.Geometry.Vector})">
            <summary>
            Remove from this collection any faces whose circumcentre falls inside the specified boundary on the XY plane
            </summary>
            <param name="boundary"></param>
        </member>
        <member name="M:Nucleus.Geometry.MeshFaceCollection.FaceContainingXY(Nucleus.Geometry.Vector)">
            <summary>
            Find and return the first face in this collection that encloses the specified
            point in the XY plane.
            </summary>
            <param name="point">The point to test for</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFaceCollection.Quadrangulate">
            <summary>
            Quadrangulate this mesh by merging adjacent tris into quads.
            The algorithm will prioritise merging the longest edges first
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.MeshFaceCollection.ExtractAllEdges">
            <summary>
            Extract all edges from the faces in this collection.
            This may include duplicates where edges are shared between
            faces.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFaceCollection.ExtractNakedEdges">
            <summary>
            Extract all naked edges from the faces in this collection.
            Shared edges will be automatically
            removed.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFaceCollection.ExtractUniqueEdges">
            <summary>
            Extract all naked edges from the faces in this collection.
            Shared edges will be automatically
            removed.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.MeshFaceCollection.Refine(System.Double)">
            <summary>
            Refine and subdivide the faces in this collection to
            reduce the maximum edge length below the specified 
            </summary>
            <param name="maxEdgeLength"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.Surface">
            <summary>
            Abstract base class for surfaces - infinitely thin membrane geometries
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Surface.FaceCount">
            <summary>
            Get the number of faces (or, subsurfaces) that this surface posesses
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Surface.CalculateArea(Nucleus.Geometry.Vector@)">
            <summary>
            Calculate the surface area (and centroid) of this surface
            </summary>
            <param name="centroid"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Surface.CalculateArea">
            <summary>
            Calculate the surface area of this surface
            </summary>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nucleus.Geometry.Surface.LocalCoordinateSystem(System.Int32,System.Double,System.Double,Nucleus.Geometry.Angle,Nucleus.Geometry.Angle)" -->
        <member name="M:Nucleus.Geometry.Surface.LocalCoordinateSystem(System.Int32,System.Double,System.Double,Nucleus.Geometry.Angle)">
            <summary>
            Evaluate the local coordinate system of this surface.
            By convention, the z-axis of the local coordinate system will point normal to the
            surafce and the x-axis will be orientated as closely as possible to global X, unless
            the x-axis lies within a certain angular limit of z, in which case the global Y axis
            will be used instead.
            </summary>
            <param name="i">The index of the face on which to evaluate the local coordinate system</param>
            <param name="u">A normalised parameter defining the first coordinate of a point on this surface.
            Note that parameter-space is not necessarily uniform and does not equate to a normalised length.
            0 = span start, 1 = span end.</param>
            /// <param name="v">A normalised parameter defining the first coordinate of a point on this surface.
            Note that parameter-space is not necessarily uniform and does not equate to a normalised length.
            0 = span start, 1 = span end.</param>
            <param name="orientation">The orientation angle.  The rotation of the X and Y axes of the coordinate 
            system around the Z axis, relative to default reference orientation.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Surface.LocalCoordinateSystem(Nucleus.Geometry.Angle)">
            <summary>
            Evaluate the local coordinate system of this surface.
            By convention, the z-axis of the local coordinate system will point normal to the
            surafce and the x-axis will be orientated as closely as possible to global X, unless
            the x-axis lies within a certain angular limit of z, in which case the global Y axis
            will be used instead.
            </summary>
            <param name="orientation">The orientation angle.  The rotation of the X and Y axes of the coordinate 
            system around the Z axis, relative to default reference orientation.</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.Tolerance">
            <summary>
            Static class containing mutable tolerance values
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Tolerance.Distance">
            <summary>
            The current geometric tolerance used to determine coincidence
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Tolerance.Angle">
            <summary>
            The angle tolerance used for facetting arcs
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Tolerance.Layer">
            <summary>
            The current tolerance value used to determine level inclusivity
            </summary>
        </member>
        <member name="T:Nucleus.Geometry.Arc">
            <summary>
            A planar arc of constant radius described by three points.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Arc._Vertices">
            <summary>
            Private backing field for the Vertices property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Arc.Vertices">
            <summary>
            The collection of vertices which are used to define the geometry of this shape.
            The first vertex defines the start point of the arc.  The second describes a point on
            the arc.  The third describes the end of the arc in the case of an open arc, or a distinct
            third point somewhere on the circle if the arc is closed.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Arc._Circle">
            <summary>
            Private backing member for Circle property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Arc.Circle">
            <summary>
            The full circle that this arc forms part of
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Arc.IsClockwise">
            <summary>
            Does this arc run clockwise or anticlockwise, with reference to the Circle
            derived from its vertices?
            Note that this is relative to the plane said circle lies on, the normal of which
            may be orientated differently to the global coordinate system.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Arc.RadianMeasure">
            <summary>
            The angle subtended by this arc
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Arc.Closed">
            <summary>
            Is this Arc closed?  (i.e. does it represent a circle?)
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Arc.IsValid">
            <summary>
            Is this Arc valid?
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Arc.SegmentCount">
            <summary>
            The number of segments in this curve.
            For valid arcs, this is always 1.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Arc.PointOnArc">
            <summary>
            Gets or sets the position of the third mid-vertex on the arc between start and end points.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Arc.#ctor">
            <summary>
            Default constructor.  Initialises an invalid arc with no geometry.
            Will not be valid.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Arc.#ctor(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.GeometryAttributes)">
            <summary>
            Initialise an arc from three points
            </summary>
            <param name="startPt">The start point</param>
            <param name="ptOnArc">A point that lies somewhere on the arc</param>
            <param name="endPt">The end point</param>
        </member>
        <member name="M:Nucleus.Geometry.Arc.#ctor(Nucleus.Geometry.Arc)">
            <summary>
            Creates an arc which is a copy of an existing one
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Nucleus.Geometry.Arc.#ctor(Nucleus.Geometry.Circle,Nucleus.Geometry.GeometryAttributes)">
            <summary>
            Initialise an arc that forms a complete circle
            </summary>
            <param name="circle"></param>
        </member>
        <member name="M:Nucleus.Geometry.Arc.#ctor(Nucleus.Geometry.Circle,Nucleus.Geometry.Angle,Nucleus.Geometry.Angle,Nucleus.Geometry.GeometryAttributes)">
            <summary>
            Initialise an arc defined between start and end angles on a circle
            </summary>
            <param name="circle"></param>
            <param name="startAngle"></param>
            <param name="endAngle"></param>
        </member>
        <member name="M:Nucleus.Geometry.Arc.CalculateLength">
            <summary>
            Calculate and return the length of this arc
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Arc.PointAt(System.Double)">
            <summary>
            Evaluate a point on this curve defined by a parameter t
            </summary>
            <param name="t">A normalised parameter defining a point along this curve.
            Note that parameter-space is not necessarily uniform and does not equate to a normalised length.
            0 = curve start, 1 = curve end.
            For open curves, parameters outside the range 0-1 will be invalid.
            For closed curves, parameters outside this range will 'wrap'.</param>
            <returns>The vector coordinates describing a point on the curve at the specified parameter,
            if the curve definition and parameter are valid.  Else, an unset vector.</returns>
            <remarks>The base implementation treats the curve as being defined as a polyline, with straight lines
            between vertices.</remarks>
        </member>
        <member name="M:Nucleus.Geometry.Arc.PointAt(System.Int32,System.Double)">
            <summary>
            Evaluate a point defined by a parameter within a specified span.
            </summary>
            <param name="span">The index of the span.  Valid range 0 to SegmentCount - 1</param>
            <param name="tSpan">A normalised parameter defining a point along this span of this curve.
            Note that parameter-space is not necessarily uniform and does not equate to a normalised length.
            0 = span start, 1 = span end.
            </param>
            <returns>The vector coordinates describing a point on the curve span at the specified parameter,
            if the curve definition and parameter are valid.  Else, null.</returns>
            <remarks>The base implementation treats the curve as being defined as a polyline, with straight lines
            between vertices.</remarks>
        </member>
        <member name="M:Nucleus.Geometry.Arc.ParameterAt(System.Double)">
            <summary>
            Get the curve parameter at the specified length along this curve.
            If the returned parameter falls outside the range 0-1, the specified
            length does not fall within the domain of the curve.
            </summary>
            <param name="length">The distance along the curve from the start of the curve to the point in question</param>
            <returns>A curve parameter</returns>
        </member>
        <member name="M:Nucleus.Geometry.Arc.TangentAt(System.Double)">
            <summary>
            Evaluate the tangent unit vector of a point on this curve defined by a parameter t
            </summary>
            <param name="t">A normalised parameter defining a point along this curve.
            Note that parameter-space is not necessarily uniform and does not equate to a normalised length.
            0 = curve start, 1 = curve end.
            For open curves, parameters outside the range 0-1 will be invalid.
            For closed curves, parameters outside this range will 'wrap'.</param>
            <returns>The tangent unit vector of the curve at the specified parameter</returns>
            <remarks>The base implementation treats the curve as being defined as a polyline, with straight lines
            between vertices.</remarks>
        </member>
        <member name="M:Nucleus.Geometry.Arc.IsClockwiseIn(Nucleus.Geometry.CylindricalCoordinateSystem)">
            <summary>
            Is this arc clockwise with respect to the specified coordinate system?
            The coordinate system specified should have its origin at the centre of
            this arc's circle.
            </summary>
            <param name="cSystem"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Arc.IsClockwiseXY">
            <summary>
            Is this curve clockwise in the XY plane?
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Arc.SectorIxx(System.Double,System.Double)">
            <summary>
            The area moment of inertia of a filled circular sector or angle theta in radians and radius r with respect to an axis through the centroid of the circle
            Used in the calculation of enclosed area second moments of area
            </summary>
            <param name="theta">The sector angle in radians in the range 0 to 2*PI</param>
            <param name="radius"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Nucleus.Geometry.Arc.Offset(System.Double,System.Boolean,System.Boolean)">
            <summary>
            Offset this curve on the XY plane.
            </summary>
            <param name="distances">The offset distance.
            Positive numbers will result in the offset curve being to the right-hand 
            side, looking along the curve.  Negative numbers to the left.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Arc.OffsetInwards(System.Double@,System.Boolean,System.Boolean)">
            <summary>
            Offset this curve on the XY plane, automatically determining (where possible)
            the direction of offset which will result in the curve being offset within itself.
            Note that it will not be possible to accurately predict this for all curves.
            </summary>
            <param name="distances">The offset distance.
            Positive numbers will result in the offset curve being to the right-hand 
            side, looking along the curve.  Negative numbers to the left.  This will be
            automatically inverted (in-place) if the curve is anticlockwise so that
            positive numbers entered will result in an offset inwards and negative numbers outwards.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Arc.Offset(System.Collections.Generic.IList{System.Double},System.Boolean,System.Boolean)">
            <summary>
            Offset this curve on the XY plane by varying distances for
            each span.
            </summary>
            <param name="distances">The offset distance.
            Positive numbers will result in the offset curve being to the right-hand 
            side, looking along the curve.  Negative numbers to the left.</param>
            <param name="tidy">If true (default) collapsed segments will be removed.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Arc.ClosestParameter(Nucleus.Geometry.Vector)">
            <summary>
            Find the closest point on this arc to a test point, expressed as a
            parameter value from 0-1.  This may be a position on the arc or it may
            be the start (0) or end (1) of the arc depending on the relative location
            of the test point.
            </summary>
            <param name="toPoint"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Arc.ClosestPoint(Nucleus.Geometry.Vector)">
            <summary>
            Find the closest point on this arc to a test point, expressed as a
            vector in 3d space.  This may be a position on the arc or it may
            be the start or end of the arc depending on the relative location
            of the test point.
            </summary>
            <param name="toPoint"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Arc.ClosestArcParameter(Nucleus.Geometry.Angle)">
            <summary>
            Get the point on the arc closest to the specified angle, described
            as a parameter value from 0-1.  This may be a point on the arc (if the
            angle lies within the necessary range) or it may be the start or end
            of the arc if the angle lies outside that range.
            </summary>
            <param name="angle">The angle on the arc's circle</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Arc.IsInAngleRange(Nucleus.Geometry.Vector)">
            <summary>
            Is the specified point within the angle range of this arc's sector?
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Arc.IsInAngleRange(Nucleus.Geometry.Vector,Nucleus.Maths.Interval)">
            <summary>
            Is the specified point within the specified subset of the
            angle range of this arc's sector?
            </summary>
            <param name="point"></param>
            <param name="arcBounds">The </param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Arc.ParameterAt(Nucleus.Geometry.Vertex)">
            <summary>
            Get the curve parameter at the specified vertex
            </summary>
            <param name="vertex">The vertex.  Must be a defining vertex of this curve.</param>
            <returns>A curve parameter</returns>
        </member>
        <member name="M:Nucleus.Geometry.Arc.Extract(Nucleus.Maths.Interval)">
            <summary>
            Extract a portion of this curve as a new curve
            </summary>
            <param name="subDomain">The subdomain of this curve to
            be extracted as a new curve</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Arc.ToSimpleCurves">
            <summary>
            Decompose this curve down to simple primitive curve types such
            as line and arc segments.  Arcs are already 'simple' and so this
            will just return a list containing this arc.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Arc.StartTangentEnd(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Attempt to create a new Arc defined by a start point, start tangent and end point.
            This function may return an Arc, a Line (in the case that the tangent vector directly
            leads to the end point) or null if the start and end point are coincident.
            </summary>
            <param name="startPt"></param>
            <param name="startTangent"></param>
            <param name="endPt"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.Axis">
            <summary>
            An infinite straight line defined by an origin point and direction.
            Immutable geometric primitive.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Axis.Origin">
            <summary>
            Position vector describing a point on this axis.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Axis.Direction">
            <summary>
            Direction vector describing the direction of this axis.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Axis.IsValid">
            <summary>
            Is this axis definition valid?
            An axis is valid provided origin and direction vectors 
            are valid and it has a non-zero direction vector.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Axis.#ctor(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Constructor, creating an axis defined by an origin point and direction vector
            </summary>
            <param name="origin">The origin point of the axis</param>
            <param name="direction">The direction vector of the axis</param>
        </member>
        <member name="M:Nucleus.Geometry.Axis.IntersectPlane(Nucleus.Geometry.Plane)">
            <summary>
            Find the position along this axis, as a multiplication factor of the direction vector
            where this axis crosses a plane.
            </summary>
            <param name="plane">The plane to find the intersection point with.</param>
            <returns>The factor that it is necessary to multiply the direction factor by and add to the origin in order to
            obtain the intersection point, if an intersection point exists.
            Use PointAt to resolve this to a vector if required.
            If the Axis is parallel to the plane and there is no intersection then double.NaN will be returned instead.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Axis.Closest(Nucleus.Geometry.Vector)">
            <summary>
            Find the position along this axis that is closest to the specified point.
            Expressed as a multiplication factor of the direction vector from the origin.
            </summary>
            <param name="point">The test point.</param>
            <returns>The parameter, t, on this axis that describes
            the point on this axis closest to the test point.  Expressed as
            a multiplication factor of the direction vector from the origin.
            Use PointAt to evaluate this as a vector if required.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Axis.ClosestParameter(Nucleus.Geometry.Axis,System.Double@)">
            <summary>
            Find the position along this axis that is closest to the specified
            other axis.
            Expressed as a multiplication factor of the direction vector from the origin.
            </summary>
            <param name="other"></param>
            <param name="t">OUTPUT.  The parameter on the other axis.</param>
            <returns>The parameter on this axis describing the closest point to the other axis.
            Use PointAt to resolve this into a vector if required.</returns>
            <remarks>Algorithm based on http://geomalgorithms.com/a07-_distance.html </remarks>
        </member>
        <member name="M:Nucleus.Geometry.Axis.ClosestParameter(Nucleus.Geometry.Axis)">
            <summary>
            Find the position along this axis that is closest to the specified
            other axis.
            Expressed as a multiplication factor of the direction vector from the origin.
            </summary>
            <param name="other"></param>
            <returns>The parameter on this axis describing the closest point to the other axis.
            Use PointAt to resolve this into a vector if required.</returns>
            <remarks>Algorithm based on http://geomalgorithms.com/a07-_distance.html </remarks>
        </member>
        <member name="M:Nucleus.Geometry.Axis.PointAt(System.Double)">
            <summary>
            Find the position along this axis described by a parameter
            representing a multiplication of the direction vector from the
            origin point.
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Axis.ParameterAt(System.Double)">
            <summary>
            Find the parameter value at a certain length along this
            axis.  If the direction vector of this ray is unitized,
            the length and parameter will be the same.
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Axis.LeavesBounds(Nucleus.Geometry.BoundingBox)">
            <summary>
            Determine the parameter at which this ray exits the specified bounding box.  This assumes that the ray origin lies
            within the box to begin with and simply checks the three infinite planes on the relevant sides of the box.
            </summary>
            <param name="bounds"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Axis.ClosestPoint(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Utility function to find the closest point between two axes
            expressed by starting positions and vectors.
            If the two axes do not directly intersect, the closest point on
            the first axis will be returned.
            </summary>
            <param name="pt0">The origin of the first axis</param>
            <param name="v0">The direction of the first axis</param>
            <param name="pt1">The origin of the second axis</param>
            <param name="v1">The direction of the second axis</param>
            <returns>The closest point on the first axis to the second.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Axis.ClosestParameter(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Find the position along an infinite axis expressed by an origin point and
            direction which is closest to a point, expressed as a multiplication factor of that
            direction vector from that origin.
            </summary>
            <param name="origin">The origin point of the axis</param>
            <param name="direction">The direction vector of the axis</param>
            <param name="point">The point to find the closest distance to</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Axis.ClosestPoint(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Find the position along an infinite axis expressed by an origin point and
            direction which is closest to a point, expressed as a point
            </summary>
            <param name="origin">The origin point of the axis</param>
            <param name="direction">The direction vector of the axis</param>
            <param name="point">The point to find the closest distance to</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.BoundingBox">
            <summary>
            An axis-aligned bounding box representing a region in space
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.BoundingBox._MinX">
            <summary>
            Private backing field for MinX property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.BoundingBox.MinX">
            <summary>
            The minimum x-coordinate
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.BoundingBox._MaxX">
            <summary>
            Private backing field for MaxX property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.BoundingBox.MaxX">
            <summary>
            The maximum x-coordinate
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.BoundingBox._MinY">
            <summary>
            Private backing field for MinY property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.BoundingBox.MinY">
            <summary>
            The minimum y-coordinate
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.BoundingBox._MaxY">
            <summary>
            Private backing field for MaxY property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.BoundingBox.MaxY">
            <summary>
            The maximum y-coordinate
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.BoundingBox._MinZ">
            <summary>
            Private backing field for MinZ property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.BoundingBox.MinZ">
            <summary>
            The minimum z-coordinate
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.BoundingBox._MaxZ">
            <summary>
            Private backing field for MaxZ property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.BoundingBox.MaxZ">
            <summary>
            The maximum z-coordinate
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.BoundingBox.MidX">
            <summary>
            Get the mid-point of the box in the X-axis
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.BoundingBox.MidY">
            <summary>
            Get the mid-point of the box in the Y-axis
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.BoundingBox.MidZ">
            <summary>
            Get the mid-point of the box in the Z-axis
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.BoundingBox.MidPoint">
            <summary>
            Get the mid-point vector of the box
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.BoundingBox.SizeX">
            <summary>
            The size of this box in the x-axis
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.BoundingBox.SizeY">
            <summary>
            The size of this box in the y-axis
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.BoundingBox.SizeZ">
            <summary>
            The size of this box in the z-axis
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.BoundingBox.SizeVector">
            <summary>
            Get a 3D vector that represents the size of this bounding box
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.BoundingBox.X">
            <summary>
            The interval of the values this box occupies in the X-Axis
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.BoundingBox.Y">
            <summary>
            The interval of the values this box occupies in the Y-Axis
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.BoundingBox.Z">
            <summary>
            The interval of values this box occupies in the Z-Axis
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.BoundingBox.Min">
            <summary>
            Get or set the vector representing the minimum corner of
            this bounding box.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.BoundingBox.Max">
            <summary>
            Get or set the vector representing the maximum corner of
            this bounding box.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.BoundingBox.Mid">
            <summary>
            Get the vector representing the mid-point, or volume centre of
            this bounding box.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.BoundingBox.MaxSize">
            <summary>
            The largest dimensional size of this bounding box
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.#ctor">
            <summary>
            Default constructor.  Initialises a bounding box of zero dimension at the origin.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initialise a bounding box to the specified set of minimum and maximum values
            </summary>
            <param name="minX"></param>
            <param name="maxX"></param>
            <param name="minY"></param>
            <param name="maxY"></param>
            <param name="minZ"></param>
            <param name="maxZ"></param>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Initialise a bounding box as a singularity at the specified coordinates
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.#ctor(Nucleus.Geometry.Vector)">
            <summary>
            Initialise a bounding box as a singularity at the specified points
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.#ctor(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Initialse a bounding box between the specified corner points
            </summary>
            <param name="pt0"></param>
            <param name="pt1"></param>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.#ctor(Nucleus.Geometry.Vector,System.Double)">
            <summary>
            Initialise a bounding box containing a sphere of a given radius around a point
            </summary>
            <param name="pt"></param>
            <param name="radius"></param>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.#ctor(System.Collections.Generic.IEnumerable{Nucleus.Geometry.IPosition})">
            <summary>
            Constructor to fit a bounding box around a set of points.
            </summary>
            <param name="points">The points to fit the bounding box around</param>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.#ctor(System.Collections.Generic.IEnumerable{Nucleus.Model.IElement})">
            <summary>
            Constructor to fit a bounding box around a collection of elements
            </summary>
            <param name="elements"></param>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.#ctor(System.Collections.Generic.IEnumerable{Nucleus.Geometry.VertexGeometry})">
            <summary>
            Constructor to fit a bounding box around a collection of geometry
            </summary>
            <param name="geometry"></param>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.#ctor(Nucleus.Geometry.BoundingBox)">
            <summary>
            Initialise a bounding box as a copy of another
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.Fit(Nucleus.Geometry.Vector)">
            <summary>
            Fit this bounding box around a single point
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.Fit(System.Collections.Generic.IEnumerable{Nucleus.Geometry.IPosition})">
            <summary>
            Fit this bounding box around a collection of positional
            objects
            </summary>
            <param name="points"></param>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.Fit(System.Collections.Generic.IList{Nucleus.Geometry.Vertex})">
            <summary>
            Fit this bounding box around a collection of vertices
            </summary>
            <param name="vertices"></param>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.Fit(System.Collections.Generic.IEnumerable{Nucleus.Model.IElement})">
            <summary>
            Fit this bounding box around a collection of elements
            </summary>
            <param name="elements"></param>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.Fit(System.Collections.Generic.IEnumerable{Nucleus.Geometry.VertexGeometry})">
            <summary>
            Fit this bounding box around a collection of elements
            </summary>
            <param name="geometry"></param>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.Fit(Nucleus.Model.IElement)">
            <summary>
            Fit this bounding box around an element
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.Fit(Nucleus.Geometry.VertexGeometry)">
            <summary>
            Fit this bounding box around a shape
            </summary>
            <param name="shape"></param>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.Include(System.Collections.Generic.IEnumerable{Nucleus.Geometry.IPosition})">
            <summary>
            Expand this bounding box to include the positions of the
            specified set of positional objects
            </summary>
            <param name="points"></param>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.Include(System.Collections.Generic.IEnumerable{Nucleus.Model.IElement})">
            <summary>
            Expand this bounding box to include the positions of the 
            specified set of elements
            </summary>
            <param name="elements"></param>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.Include(System.Collections.Generic.IEnumerable{Nucleus.Geometry.VertexGeometry})">
            <summary>
            Expand this bounding box to include the specified set
            of geometry.
            </summary>
            <param name="geometry"></param>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.Include(Nucleus.Geometry.Vector)">
            <summary>
            Expand the bounding box to include the specified point, if necessary
            </summary>
            <param name="pt"></param>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.Include(Nucleus.Geometry.Vector@)">
            <summary>
            Expand the bounding box to include the specified point, if necessary
            </summary>
            <param name="pt"></param>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.Include(Nucleus.Geometry.BoundingBox)">
            <summary>
            Expand this bounding box to contain another, if necessary.
            </summary>
            <param name="other">The box to be included.  If any part
            of the box falls outside of this one, this box will be expanded
            to the relevant limits of the other.  May be null.</param>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.Include(Nucleus.Model.IElement)">
            <summary>
            Expand this bounding box to include the specified element
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.Include(Nucleus.Geometry.VertexGeometry)">
            <summary>
            Expand this bounding box to contain the specified geometry, if
            necessary.
            </summary>
            <param name="geometry"></param>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.RandomPointInside(System.Random)">
            <summary>
            Generate a random point inside this bounding box
            </summary>
            <param name="rng">The random number generator used to generate the point</param>
            <returns>A new vector at a random position somewhere inside this box</returns>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.RandomPointsInside(System.Random,System.Int32)">
            <summary>
            Generate a set of random points inside this bounding box
            </summary>
            <param name="rng">The random number generator used to generate the point coordinates</param>
            <param name="number">The number of points to generate</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.MinInDimension(Nucleus.Geometry.CoordinateAxis)">
            <summary>
            Get the minimum value in the specified dimension
            </summary>
            <param name="dimension"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.MaxInDimension(Nucleus.Geometry.CoordinateAxis)">
            <summary>
            Get the maximum value in the specified dimension
            </summary>
            <param name="dimension"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.IntervalInDimension(Nucleus.Geometry.CoordinateAxis)">
            <summary>
            Get the interval of values in the specified dimension
            </summary>
            <param name="dimension"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.Contains(Nucleus.Geometry.Vector)">
            <summary>
            Does this bounding box contain the specified point?
            </summary>
            <param name="point">The point to test for containment</param>
            <returns>True if the point falls inside, or is on the surface of, 
            this box</returns>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.Contains(Nucleus.Geometry.BoundingBox)">
            <summary>
            Does this bounding box entirely contain the specified other bounding box?
            To test for partial containment use the Overlaps function instead
            </summary>
            <param name="box"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.Contains(Nucleus.Geometry.VertexGeometry)">
            <summary>
            Does this bounding box entirely contain the specified geometry?
            To test for partial containment use the Overlaps function instead
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.Overlaps(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Check whether the specified box region overlaps this box.
            </summary>
            <param name="minX"></param>
            <param name="maxX"></param>
            <param name="minY"></param>
            <param name="maxY"></param>
            <param name="minZ"></param>
            <param name="maxZ"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.Overlaps(Nucleus.Geometry.BoundingBox)">
            <summary>
            Check whether the specified other bounding box overlaps this one
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.Overlaps(Nucleus.Geometry.VertexGeometry)">
            <summary>
            Does this bounding box overlap that of the specified geometry object?
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.Expand(System.Double)">
            <summary>
            Expand this bounding box in all directions by the specified amount
            </summary>
            <param name="distance"></param>
        </member>
        <member name="M:Nucleus.Geometry.BoundingBox.Scale(System.Double)">
            <summary>
            Scale this bounding box by a factor in all directions about its own
            centroid
            </summary>
            <param name="factor"></param>
        </member>
        <member name="T:Nucleus.Geometry.CartesianCoordinateSystem">
            <summary>
            Represents a cartesian coordinate system
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.CartesianCoordinateSystem.Global">
            <summary>
            The default, global coordinate system.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.CartesianCoordinateSystem.Origin">
            <summary>
            The origin point of the coordinate system
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.CartesianCoordinateSystem.X">
            <summary>
            The unit vector defining the local X-axis
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.CartesianCoordinateSystem.Y">
            <summary>
            The unit vector defining the local Y-axis
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.CartesianCoordinateSystem.Z">
            <summary>
            The unit vector defining the local Z-axis
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.CartesianCoordinateSystem.#ctor">
            <summary>
            Default constructor.  Coordinate system is initialised matching the global coordinate system.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.CartesianCoordinateSystem.#ctor(Nucleus.Geometry.Vector)">
            <summary>
            Constructor creating a globally-aligned coordinate system with its origin at the specified point
            </summary>
            <param name="origin">The origin point of the coordinate system</param>
        </member>
        <member name="M:Nucleus.Geometry.CartesianCoordinateSystem.#ctor(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Constructor creating a coordinate system defined by an origin point and a z-axis vector.
            The X- and Y-axes will be generated perpendicular to the z-axis and with the x-axis orientated
            as closely as possible to the global x-axis (unless the specified z-axis already lies in that axis,
            in which case it will be aligned as closely as possible to the global z).
            </summary>
            <param name="origin">The origin point of the plane</param>
            <param name="zAxis">The coordinate system z-axis
            Should be a unit vector if consistent scaling is required.</param>
        </member>
        <member name="M:Nucleus.Geometry.CartesianCoordinateSystem.#ctor(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Constructor creating a coordinate system defined by an origin and two vectors on the XY plane.
            </summary>
            <param name="origin">The origin point of the plane</param>
            <param name="xAxis">The x-axis.</param>
            <param name="xyVector">A second vector that lies on the plane but that is not coincident with the first.</param>
        </member>
        <member name="M:Nucleus.Geometry.CartesianCoordinateSystem.#ctor(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Constructor explicitly specifying all axes.
            The data is not validated.
            </summary>
            <param name="origin"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:Nucleus.Geometry.CartesianCoordinateSystem.#ctor(Nucleus.Geometry.Vector[])">
            <summary>
            Constructor specifying all axes as a single vector array containing
            Origin, X, Y, Z in that order.
            Allows data to be populated via a static function in a subclass constructor.
            </summary>
            <param name="vectors"></param>
        </member>
        <member name="M:Nucleus.Geometry.CartesianCoordinateSystem.#ctor(Nucleus.Geometry.CartesianCoordinateSystem)">
            <summary>
            Duplication constructor
            </summary>
            <param name="other">Another coordinate system to copy values from</param>
        </member>
        <member name="M:Nucleus.Geometry.CartesianCoordinateSystem.#ctor(Nucleus.Geometry.CartesianCoordinateSystem,Nucleus.Geometry.Vector)">
            <summary>
            Constructor to duplicate a coordinate system while changing its origin to
            a new position
            </summary>
            <param name="other">Another coordinate system to copy axis directions from</param>
            <param name="newOrigin">The origin point of the new coordinate system</param>
        </member>
        <member name="M:Nucleus.Geometry.CartesianCoordinateSystem.GlobalToLocal(Nucleus.Geometry.Vector,System.Boolean)">
            <summary>
            Convert a vector defined in the global coordinate system into 
            one defined in local coordinates of this coordinate system.
            </summary>
            <param name="vector">A vector in the global coordinate system.</param>
            <param name="direction"></param>
            <returns>A vector in local coordinates</returns>
        </member>
        <member name="M:Nucleus.Geometry.CartesianCoordinateSystem.LocalToGlobal(Nucleus.Geometry.Vector,System.Boolean)">
            <summary>
            Convert a vector defined in the local coordinate system into
            one defined in global coordinates
            </summary>
            <param name="vector">A vector in the local coordinate system.</param>
            <param name="direction">If true, this vector represents a direction rather than a point
            and will not be offset by the origin.</param>
            <returns>A vector in global coordinates</returns>
        </member>
        <member name="M:Nucleus.Geometry.CartesianCoordinateSystem.GetAxisVector(Nucleus.Geometry.Direction)">
            <summary>
            Get the axis vector relevant to the specified local axis
            </summary>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.CartesianCoordinateSystem.LocalToGlobal(System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
            Convert a set of coordinates defined in the local coordinate system
            into one defined in global coordinates
            </summary>
            <param name="x">The first coordinate.</param>
            <param name="y">The second coordinate.</param>
            <param name="z">The third coordinate.</param>
            <returns>A vector representing a position in the global cartesian coordinate system.</returns>
        </member>
        <member name="M:Nucleus.Geometry.CartesianCoordinateSystem.LocalToGlobal(System.Collections.Generic.IList{Nucleus.Geometry.Vector})">
            <summary>
            Convert a set of points defined in the local coordinate system
            to a set of points defined in the global one
            </summary>
            <param name="vectors"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.CartesianCoordinateSystem.XYPlane">
            <summary>
            Extract the XY plane from this coordinate system
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.CartesianCoordinateSystem.YZPlane">
            <summary>
            Extract the YZ plane from this coordinate system
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.CartesianCoordinateSystem.XZPlane">
            <summary>
            Extract the XZ plane form this coordinate system
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.CartesianCoordinateSystem.ReverseXY">
            <summary>
            Invert the directions of the X and Y axes, keeping Z the same
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.CartesianCoordinateSystem.FromXAndZ(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Construct a cartesian coordinate system from X and Z axis vectors
            </summary>
            <param name="origin"></param>
            <param name="xAxis"></param>
            <param name="zAxis"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.CartesianCoordinateSystem.FromXAxis(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Construct a cartesian coordinate system from an X axis, using the global Z axis
            </summary>
            <param name="origin"></param>
            <param name="xAxis"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.Curve">
            <summary>
            Base class for curves.
            Curves are 1-Dimensional geometries defined by a set of ordered vertices. 
            </summary>
            <typeparam name="TVertex"></typeparam>
            <remarks>This class implements a default set of interrogation methods, which will treat
            this curve as a polyline of straight segments between vertices.
            While most curve functionality is implemented on the relevent subclass, any new curve types
            should also take care to also add support to the relevent functions within the Intersect
            helper class and any relevant conversion classes in dependent libraries.</remarks>
        </member>
        <member name="P:Nucleus.Geometry.Curve.Closed">
            <summary>
            Whether this curve is closed.
            If true, the end of the curve is treated as being the same as the start point.
            Default (for most curve types) is false.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Nucleus.Geometry.Curve.SegmentCount" -->
        <member name="P:Nucleus.Geometry.Curve.Domain">
            <summary>
            Get the parameter-space domain of this curve
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Curve.Start">
            <summary>
            Get the vertex at the start of the curve (if there is one)
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Curve.End">
            <summary>
            Get the vertex at the end of the curve (if there is one)
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Curve.StartPoint">
            <summary>
            Get the start point of this curve
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Curve.EndPoint">
            <summary>
            Get the end point of this curve
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Curve.Length">
            <summary>
            Get the length of this curve
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Curve.PointAt(System.Double)">
            <summary>
            Evaluate a point on this curve defined by a parameter t
            </summary>
            <param name="t">A normalised parameter defining a point along this curve.
            Note that parameter-space is not necessarily uniform and does not equate to a normalised length.
            0 = curve start, 1 = curve end.
            For open curves, parameters outside the range 0-1 will be invalid.
            For closed curves, parameters outside this range will 'wrap'.</param>
            <returns>The vector coordinates describing a point on the curve at the specified parameter,
            if the curve definition and parameter are valid.  Else, an unset vector.</returns>
            <remarks>The base implementation treats the curve as being defined as a polyline, with straight lines
            between vertices.</remarks>
        </member>
        <member name="M:Nucleus.Geometry.Curve.PointsAt(System.Collections.Generic.IList{System.Double})">
            <summary>
            Evaluate a set of points along this curve defined by a set of parameters
            </summary>
            <param name="t">A set of normalised parameters defining points along this curve.
            Note that parameter-space is not necessarily uniform and does not equate to a normalised length.
            0 = curve start, 1 = curve end.
            For open curves, parameters outside the range 0-1 will be invalid.
            For closed curves, parameters outside this range will 'wrap'.</param>
            <returns>The vector coordinates describing a point on the curve at the specified parameter,
            if the curve definition and parameter are valid.  Else, an unset vector.</returns>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.PointAt(System.Int32,System.Double)">
            <summary>
            Evaluate a point defined by a parameter within a specified span.
            </summary>
            <param name="span">The index of the span.  Valid range 0 to SegmentCount - 1</param>
            <param name="tSpan">A normalised parameter defining a point along this span of this curve.
            Note that parameter-space is not necessarily uniform and does not equate to a normalised length.
            0 = span start, 1 = span end.
            </param>
            <returns>The vector coordinates describing a point on the curve span at the specified parameter,
            if the curve definition and parameter are valid.  Else, null.</returns>
            <remarks>The base implementation treats the curve as being defined as a polyline, with straight lines
            between vertices.</remarks>
        </member>
        <member name="M:Nucleus.Geometry.Curve.PointAtLength(System.Double,System.Boolean)">
            <summary>
            Evaluate a point on this curve a specified distance from the start or end.
            </summary>
            <param name="length">The length along the curve</param>
            <param name="fromEnd">If true, the length will be measured from the end
            of the curve.  If false (default) it will be measured from the start.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.ParameterAt(Nucleus.Geometry.Vertex)">
            <summary>
            Get the curve parameter at the specified vertex
            </summary>
            <param name="vertex">The vertex.  Must be a defining vertex of this curve.</param>
            <returns>A curve parameter</returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.ParameterAtVertexIndex(System.Int32)">
            <summary>
            Get the curve parameter at the vertex at the specified index
            </summary>
            <param name="vertexIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.ParameterAt(System.Double)">
            <summary>
            Get the curve parameter at the specified length along this curve.
            If the returned parameter falls outside the range 0-1, the specified
            length does not fall within the domain of the curve.
            </summary>
            <param name="length">The distance along the curve from the start of the curve to the point in question</param>
            <returns>A curve parameter</returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.ParametersAtSpacing(System.Double,System.Double,System.Int32)">
            <summary>
            Returns a set of parameters evenly spaced along the curve with a specified spacing
            </summary>
            <param name="spacing">The distance between points</param>
            <param name="firstOffset">The distance of the first point from the start of the curve.</param>
            <param name="countLimit">Optional.  The maximum number of parameters to be produced.
            If set to 0 or below, the number of possible returned parameters is unlimited.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.ParametersAtDivisions(System.Int32,System.Double)">
            <summary>
            Returns a set of parameters at equidistant points along this curve produced by dividing the
            curve into equal length segments.
            </summary>
            <param name="divisions">The number of equal segments to divide the curve into.</param>
            <param name="proportionOfDivision">The position of the point within each segment, as a
            proportion of the segment length.
            Between 0-1, where for e.g. 0 is at the start of each segment, 0.5 is in the middle
            and so on.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.LengthAt(System.Double)">
            <summary>
            Calculate the length along the curve of the specified parameter
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.LengthOf(Nucleus.Maths.Interval)">
            <summary>
            Calculate the length of a section of this curve defined
            by a parameter interval
            </summary>
            <param name="t">The curve parameter interval the length of which is to be measured.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.FilterBelowLength(System.Collections.Generic.IList{Nucleus.Maths.Interval},System.Double)">
            <summary>
            Filter out from the specified list of domain intervals on this curve any which have a length
            lower than the specified limit.
            </summary>
            <param name="intervals"></param>
            <param name="limit"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.SubdomainByCentre(System.Double,System.Double)">
            <summary>
            Get a curve parameter subdomain specified by the mid-point parameter
            of the subdomain and the length of the subdomain along the curve.
            </summary>
            <param name="tMid">The curve parameter at the mid-point of the specified subdomain</param>
            <param name="length">The length of the subdomain (i.e. the domain will start and end
            half of this distance from tMid) </param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.TangentAt(Nucleus.Geometry.Vertex)">
            <summary>
            Evaluate the tangent unit vector at the specified vertex of this
            curve.
            </summary>
            <param name="vertex">The vertex.  
            Must be a defining vertex of this curve.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.TangentAt(Nucleus.Model.Node)">
            <summary>
            Evaluate the tangent unit vector at the specified node, which is
            attached to a vertex of this curve.
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.TangentAt(System.Double)">
            <summary>
            Evaluate the tangent unit vector of a point on this curve defined by a parameter t
            </summary>
            <param name="t">A normalised parameter defining a point along this curve.
            Note that parameter-space is not necessarily uniform and does not equate to a normalised length.
            0 = curve start, 1 = curve end.
            For open curves, parameters outside the range 0-1 will be invalid.
            For closed curves, parameters outside this range will 'wrap'.</param>
            <returns>The tangent unit vector of the curve at the specified parameter</returns>
            <remarks>The base implementation treats the curve as being defined as a polyline, with straight lines
            between vertices.</remarks>
        </member>
        <member name="M:Nucleus.Geometry.Curve.TangentAt(System.Int32,System.Double)">
            <summary>
            Evaluate the tangent unit vector of a point defined by a parameter within a specified span.
            </summary>
            <param name="span">The index of the span.  Valid range 0 to SegmentCount - 1</param>
            <param name="tSpan">A normalised parameter defining a point along this span of this curve.
            Note that parameter-space is not necessarily uniform and does not equate to a normalised length.
            0 = span start, 1 = span end.
            </param>
            <returns>The unit vector describing the tangent of a point on the curve span at the specified parameter,
            if the curve definition and parameter are valid.  Else, null.</returns>
            <remarks>The base implementation treats the curve as being defined as a polyline, with straight lines
            between vertices.</remarks>
        </member>
        <member name="M:Nucleus.Geometry.Curve.CheckSegmentTangents(Nucleus.Geometry.Curve)">
            <summary>
            Compare this curve to another by span tangencies.
            Returns true only if the two curves have the same number of spans
            and the curve tangencies at the mid-point of each span are facing
            within 90 degrees of one another.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.LocalCoordinateSystem(System.Double,Nucleus.Geometry.Angle)">
            <summary>
            Evaluate the local coordinate system at a position along this curve.
            By convention, the x-axis of the local coordinate system will point along the
            curve and the z-axis will be orientated as closely as possible to global Z, unless
            the x-axis lies within a certain angular limit of z, in which case the global X axis
            will be used instead.
            </summary>
            <param name="t">A normalised parameter defining a point along this curve.
            Note that parameter-space is not necessarily uniform and does not equate to a normalised length.
            0 = span start, 1 = span end.</param>
            <param name="orientation">The orientation angle.  The rotation of the Y and Z axes of the coordinate 
            system around the X axis, relative to default reference orientation.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.LocalCoordinateSystem(System.Double,Nucleus.Geometry.Angle,Nucleus.Geometry.Angle)">
            <summary>
            Evaluate the local coordinate system at a position along this curve.
            By convention, the x-axis of the local coordinate system will point along the
            curve and the z-axis will be orientated as closely as possible to global Z, unless
            the x-axis lies within a certain angular limit of z, in which case the global X axis
            will be used instead.
            </summary>
            <param name="tSpan">A normalised parameter defining a point along this curve.
            Note that parameter-space is not necessarily uniform and does not equate to a normalised length.
            0 = span start, 1 = span end.</param>
            <param name="orientation">The orientation angle.  The rotation of the Y and Z axes of the coordinate 
            system around the X axis, relative to default reference orientation.</param>
            <param name="zLimit">The angular limit within which if the local X and global Z approach each other,
            local Z will be aligned towards global X rather than global Z.  By default, this is 1 degree.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.LocalCoordinateSystem(System.Int32,System.Double,Nucleus.Geometry.Angle)">
            <summary>
            Evaluate the local coordinate system at a position along this curve.
            By convention, the x-axis of the local coordinate system will point along the
            curve and the z-axis will be orientated as closely as possible to global Z, unless
            the x-axis lies within one degree of z, in which case the global X axis
            will be used instead.
            </summary>
            <param name="tSpan">A normalised parameter defining a point along this span of this curve.
            Note that parameter-space is not necessarily uniform and does not equate to a normalised length.
            0 = span start, 1 = span end.</param>
            <param name="orientation">The orientation angle.  The rotation of the Y and Z axes of the coordinate 
            system around the X axis, relative to default reference orientation.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.LocalCoordinateSystem(System.Int32,System.Double,Nucleus.Geometry.Angle,Nucleus.Geometry.Angle)">
            <summary>
            Evaluate the local coordinate system at a position along this curve.
            By convention, the x-axis of the local coordinate system will point along the
            curve and the z-axis will be orientated as closely as possible to global Z, unless
            the x-axis lies within a certain angular limit of z, in which case the global X axis
            will be used instead.
            </summary>
            <param name="span">The index of the span.  Valid range 0 to SegmentCount - 1</param>
            <param name="tSpan">A normalised parameter defining a point along this span of this curve.
            Note that parameter-space is not necessarily uniform and does not equate to a normalised length.
            0 = span start, 1 = span end.</param>
            <param name="orientation">The orientation angle.  The rotation of the Y and Z axes of the coordinate 
            system around the X axis, relative to default reference orientation.</param>
            <param name="zLimit">The angular limit within which if the local X and global Z approach each other,
            local Z will be aligned towards global X rather than global Z.  By default, this is 1 degree.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.ClosestParameter(Nucleus.Geometry.Vector)">
            <summary>
            Find the closest point on this curve to a test point, expressed as a
            parameter value from 0-1.  This may be a position on the curve or it may
            be the start (0) or end (1) of the curve depending on the relative location
            of the test point.
            </summary>
            <param name="toPoint">The test point to find the closest point to</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.ClosestPoint(Nucleus.Geometry.Vector)">
            <summary>
            Find the closest point on this curve to a test point, expressed as a
            vector in 3d space.  This may be a position on the curve or it may
            be the start or end of the curve depending on the relative location
            of the test point.
            </summary>
            <param name="toPoint">The test point to find the closest point to</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.OverlapWith(Nucleus.Geometry.Curve)">
            <summary>
            Find the region of this curve (expressed as a parameter interval) which
            overlaps with another curve, determined by projecting the start and end 
            points of said curve onto this one.
            </summary>
            <param name="other">Another curve.  For the most meaningful results,
            should run roughly parallel to this one.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.OverlapWith(Nucleus.Geometry.Curve,Nucleus.Maths.Interval)">
            <summary>
            Find the region of this curve (expressed as a parameter interval) which
            overlaps with a region of another curve, determined by projecting the
            start and end of the specified domain on the other curve onto this one.
            </summary>
            <param name="other">Another curve.  For the most meaningful results,
            should run roughly parallel to this one.</param>
            <param name="domainOnOther">The region of the other curve to overlap
            with this curve.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.DistanceToSquared(Nucleus.Geometry.Vector)">
            <summary>
            Calculate the shortest distance squared from this curve to the specified point
            </summary>
            <param name="point">The test point to find the distance to</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.DistanceTo(Nucleus.Geometry.Vector)">
            <summary>
            Calculate the shortest distance from this curve to the specified point
            </summary>
            <param name="point">The test point to find the distance to</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.SegmentStart(System.Int32)">
            <summary>
            Get the vertex (if any) which defines the start of the specified segment.
            </summary>
            <param name="index">The segment index.  Valid range 0 to SegmentCount - 1</param>
            <returns>The start vertex of the given segment, if it exists.  Else null.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.SegmentEnd(System.Int32)">
            <summary>
            Get the vertex (if any) which defines the end of the specified segment.
            </summary>
            <param name="index">The segment index.  Valid range 0 to SegmentCount - 1</param>
            <returns>The end vertex of the given segment, if it exists.  Else null.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.Facet(Nucleus.Geometry.Angle)">
            <summary>
            Produce a set of points which represents a facetted version of this curve
            </summary>
            <param name="tolerance">The maximum angular deviation between the curve and the 
            facetted geometry.  If zero, the tolerance is taken as infinite and curves will
            not be facetted between kinks.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.FacetCSystems(Nucleus.Geometry.Angle,Nucleus.Geometry.Angle)">
            <summary>
            Produce a set of coordinate systems along the curve which can be used to generate a solid representation
            of an element around this curve.
            </summary>
            <param name="tolerance">The maximum angular deviation between the curve and the 
            facetted geometry.  If zero, the tolerance is taken as infinite and curves will
            not be facetted between kinks.</param>
            <param name="orientation">The orientation angle.  The rotation of the Y and Z axes of the coordinate 
            system around the X axis, relative to default reference orientation.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.Divide(System.Int32)">
            <summary>
            Divide up this curve into the specified number of equal-length
            segments and return the positions between those segments.
            </summary>
            <param name="divisions"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.Plane(System.Double)">
            <summary>
            Calculate the plane this curve lies on, if it is planar.
            Returns null if the curve is non-planar within the specified tolerance 
            or if its geometry is not sufficient to describe a plane (i.e. it is a line).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.FacetCSystems(Nucleus.Geometry.Angle,Nucleus.Geometry.Angle,Nucleus.Geometry.Angle)">
            <summary>
            Produce a set of coordinate systems along the curve which can be used to generate a solid representation
            of an element around this curve.
            </summary>
            <param name="tolerance">The maximum angular deviation between the curve and the 
            facetted geometry.  If zero, the tolerance is taken as infinite and curves will
            not be facetted between kinks.</param>
            <param name="orientation">The orientation angle.  The rotation of the Y and Z axes of the coordinate 
            system around the X axis, relative to default reference orientation.</param>
            <param name="zLimit">The angular limit within which if the local X and global Z approach each other,
            local Z will be aligned towards global X rather than global Z.  By default, this is 1 degree.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.CalculateSegmentLength(System.Int32)">
            <summary>
            Calculate the length of the segment specified by the index
            </summary>
            <param name="index">The segment index.  Valid range 0 to SegmentCount - 1</param>
            <returns>The length of the segment, or Double.NaN if the segment isnot valid.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.CalculateLength">
            <summary>
            Calculate the length of this curve
            </summary>
            <returns>The calculated length of </returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.CalculateEnclosedArea(Nucleus.Geometry.Plane)">
            <summary>
            Calculate the area enclosed by this curve, were the start and end points to be 
            joined by a straight line segment.
            A plane may optionally be specified, otherwise by default the projected area on 
            the XY plane will be used.
            </summary>
            <param name="onPlane">The plane to use to calculate the area.
            If not specified, the XY plane will be used.</param>
            <returns>The signed area enclosed by this curve on the specified plane,
            as a double.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.CalculateEnclosedArea(Nucleus.Geometry.Vector@,Nucleus.Geometry.Plane)">
            <summary>
            Calculate the area enclosed by this curve, were the start and end points to be 
            joined by a straight line segment.
            A plane may optionally be specified, otherwise by default the projected area on 
            the XY plane will be used.
            </summary>
            <param name="centroid">Output.  The centroid of the enclosed area.</param>
            <param name="onPlane">The plane to use to calculate the area.
            If not specified, the XY plane will be used.</param>
            <returns>The signed area enclosed by this curve on the specified plane,
            as a double.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.CalculateEnclosedArea(Nucleus.Geometry.Vector@,Nucleus.Geometry.CurveCollection,Nucleus.Geometry.Plane)">
            <summary>
            Calculate the combined area enclosed by this curve, were the start and end points to be
            joined by a straight line segment, but excluding areas bounded by a specified set of void curves.
            A plane may optionally be specified, otherwise by default the projected area on the XY plane will
            be used.
            </summary>
            <param name="centroid">Output.  The centroid of the enclosed area.</param>
            <param name="voids">A collection of curves which represent the boundaries of void spaces
            within the perimeter of this curve.  Voids must be co-planar with and wholly within the
            bounds of this curve for the calculation to be accurate.  May be null.</param>
            <param name="onPlane">The plane to use to calculate the area.
            If not specified, the XY plane will be used.</param>
            <returns>The signed area enclosed by this curve on the specified plane, as a double.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.CalculateEnclosedIxx(Nucleus.Geometry.Plane)">
            <summary>
            Calculate the second moment of area enclosed by this curve on a the XY plane about the
            X-axis, were the start and end points joined by a straight line segment.
            A coordinate system may be specified, otherwise by default the global XY plane and
            X-axis will be used.
            </summary>
            <param name="onPlane">The coordinate system in which the second moment of area is
            to be calculated.  The second moment of area will be calculated on the XY plane and
            about the X-axis of this system.</param>
            <returns>The signed second moment of area enclosed by this curve, as a
            double.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.CalculateEnclosedIxx(Nucleus.Geometry.CurveCollection,Nucleus.Geometry.Plane)">
            <summary>
            Calculate the second moment of area enclosed by this curve on a the XY plane about the
            X-axis, were the start and end points joined by a straight line segment, excluding
            the void regions specififed as boundaries.
            A coordinate system may be specified, otherwise by default the global XY plane and
            X-axis will be used.
            </summary>
            <param name="voids">A collection of curves which represent the boundaries of void spaces
            within the perimeter of this curve.  Voids must be co-planar with and wholly within the
            bounds of this curve for the calculation to be accurate.  May be null.</param>
            <param name="onPlane">The coordinate system in which the second moment of area is
            to be calculated.  The second moment of area will be calculated on the XY plane and
            about the X-axis of this system.</param>
            <returns>The signed second moment of area enclosed by this curve, as a
            double.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.CalculateEnclosedIyy(Nucleus.Geometry.CurveCollection)">
            <summary>
            Calculate the second moment of area enclosed by this curve on a the XY plane about the
            Y-axis, were the start and end points joined by a straight line segment, excluding
            the void regions specififed as boundaries.
            </summary>
            <param name="voids">Optional.  A collection of curves which represent the boundaries of void spaces
            within the perimeter of this curve.  Voids must be co-planar with and wholly within the
            bounds of this curve for the calculation to be accurate.  May be null.</param>
            <returns>The signed second moment of area enclosed by this curve, as a
            double.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.EnclosesXY(Nucleus.Geometry.Vector)">
            <summary>
            Check whether the specified point lies within the area enclosed by this curve
            on the XY plane
            </summary>
            <param name="point"></param>
            <returns></returns>
            <remarks>TODO: Implement more refined checks on arcs</remarks>
        </member>
        <member name="M:Nucleus.Geometry.Curve.Offset(System.Double,System.Boolean,System.Boolean)">
            <summary>
            Offset this curve on the XY plane.
            </summary>
            <param name="distances">The offset distance.
            Positive numbers will result in the offset curve being to the right-hand 
            side, looking along the curve.  Negative numbers to the left.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.Offset(System.Collections.Generic.IList{System.Double},System.Boolean,System.Boolean)">
            <summary>
            Offset this curve on the XY plane by varying distances for
            each span.
            </summary>
            <param name="distances">The offset distances for each span, in order.
            Positive numbers will result in the offset curve being to the right-hand 
            side, looking along the curve.  Negative numbers to the left.</param>
            <param name="tidy">If true (default) collapsed segments will be removed.</param>
            <param name="copyAttributes">If true (default) the attributes of this curve will be copied
            to the offset one.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.OffsetInwards(System.Double@,System.Boolean,System.Boolean)">
            <summary>
            Offset this curve on the XY plane, automatically determining (where possible)
            the direction of offset which will result in the curve being offset within itself.
            Note that it will not be possible to accurately predict this for all curves.
            </summary>
            <param name="distances">The offset distance.
            Positive numbers will result in the offset curve being to the right-hand 
            side, looking along the curve.  Negative numbers to the left.  This will be
            automatically inverted (in-place) if the curve is anticlockwise so that
            positive numbers entered will result in an offset inwards and negative numbers outwards.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.OffsetInwards(System.Collections.Generic.IList{System.Double},System.Boolean,System.Boolean)">
            <summary>
            Offset this curve on the XY plane by varying distances for each span, 
            automatically determining (where possible)
            the direction of offset which will result in the curve being offset within itself.
            Note that it will not be possible to accurately predict this for all curves.
            </summary>
            <param name="distances">The offset distances for each span, in order.
            Positive numbers will result in the offset curve being to the right-hand 
            side, looking along the curve.  Negative numbers to the left.  This will be
            automatically inverted (in-place) if the curve is anticlockwise so that
            positive numbers entered will result in an offset inwards and negative numbers outwards.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.IsClockwiseXY">
            <summary>
            Is this curve clockwise in the XY plane?
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.ToSimpleCurves">
            <summary>
            Decompose this curve down to simple primitive curve types such
            as line and arc segments.  This may return a list containing only
            itself if the curve is already a simple type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.ToPolyCurve">
            <summary>
            Get a polycurve version of this curve.  If the curve is already a
            polycurve then this will return a reference to the initial object,
            otherwise a new polycurve will be created that contains the original
            curve.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.IsSelfIntersectingXY">
            <summary>
            Does this curve self-intersect on the XY plane?
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.Explode(System.Boolean)">
            <summary>
            'Explode' this curve into a collection of its constituent
            segments as individual curves.
            </summary>
            <param name="recursive">If true (default), any sub-curves of
            this curve which themselves have sub-curves will also be exploded
            and added to the collection.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.Extract(Nucleus.Maths.Interval)">
            <summary>
            Extract a subset of this curve within the specified domain
            as a new curve.
            </summary>
            <param name="subDomain">The subdomain of this curve to be extracted</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.GetOtherEnd(Nucleus.Geometry.Vertex)">
            <summary>
            On entering either the start or end vertex of this curve,
            the other will be returned.
            </summary>
            <param name="curveEnd"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.Trim(Nucleus.Geometry.Vertex,System.Double)">
            <summary>
            Reduce the length of this curve, trimming from the specifed end vertex
            by the specified value
            </summary>
            <param name="lineEnd">The vertex at the end of this curve
            to trim back.  The entered value should be either the
            start or end vertex of this line.</param>
            <param name="length">The length to cut back from the curve end</param>
            <returns>True if successful, false if not.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.TrimStart(System.Double)">
            <summary>
            Reduce the length of this curve from the start
            by the specified value
            </summary>
            <param name="length">The length to cut back from the curve end</param>
            <returns>True if successful, false if not.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.TrimEnd(System.Double)">
            <summary>
            Reduce the length of this curve from the end
            by the specified value
            </summary>
            <param name="length">The length to cut back from the curve end</param>
            <returns>True if successful, false if not.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.Reverse">
            <summary>
            Reverse the direction of this curve
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Curve.Join(Nucleus.Geometry.Curve,Nucleus.Geometry.Curve)">
            <summary>
            Join two curves to create a polycurve.  The start of the endCurve should be coincident
            with the end of the startCurve.
            If one or other (or both) of the curves is already a polycurve, the other curve(s) will
            be added to that PolyCurve rather than creating a new one.
            </summary>
            <param name="startCurve"></param>
            <param name="endCurve"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.Connect(Nucleus.Geometry.Vertex,Nucleus.Geometry.Vector)">
            <summary>
            Connect the specified curve end vertex to the specified point with a straight line
            segment to be joined with the original curve.
            </summary>
            <param name="curveEnd"></param>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.ExtendToLineXY(Nucleus.Geometry.Vertex,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Extend (or trim) the end of a curve to lie at the intersection between the current
            curve and a line on the XY plane.
            </summary>
            <param name="curveEnd">The curve end to modify</param>
            <param name="lineOrigin">A point which lies on the line</param>
            <param name="lineDir">The direction vector of the line</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.MatchEnds(Nucleus.Geometry.Vertex,Nucleus.Geometry.Vertex,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Match the end positions of two curves by repositioning vertices
            to either extend or trim the curve ends to a common intersection
            point, if possible.
            The input vertices must be the first or last vertices of curves, else
            the matching will fail.
            </summary>
            <param name="crvEnd0">The end vertex of the first curve to be modified.</param>
            <param name="crvEnd1">The end vertex of the second curve to be modified.</param>
            <param name="detectMismatches">Optional.  If true, additional checking will be
            performed and only matches where both ends are extended or both ends are trimmed
            will be permitted.</param>
            <returns>True if the curve ends could be successfully matched, else false.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.MatchEnds(Nucleus.Geometry.Vertex,Nucleus.Geometry.Vector,Nucleus.Geometry.Vertex,Nucleus.Geometry.Vector,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Match curve ends by intersecting a straight line from the specified end vertices
            with the specified tangents
            </summary>
            <param name="crvEnd0">The curve end vertex of the first curve</param>
            <param name="tan0">The end tangency of the first curve</param>
            <param name="crvEnd1">The curve end vertex of the second curve</param>
            <param name="tan1">The end tangency of the second curve</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.MatchEnds(Nucleus.Geometry.Vertex,Nucleus.Geometry.Vector,Nucleus.Geometry.Vertex,Nucleus.Geometry.Arc)">
            <summary>
            Match curve ends by intersecting a straight line and an arc as closely as possible
            </summary>
            <param name="crvEnd0"></param>
            <param name="tan0"></param>
            <param name="crvEnd1"></param>
            <param name="arc1"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.MatchEnds(Nucleus.Geometry.Vertex,Nucleus.Geometry.Arc,Nucleus.Geometry.Vertex,Nucleus.Geometry.Arc)">
            <summary>
            Match curve ends by intersecting two arcs as closely as possible.
            The arcs must be coplanar for this to function correctly.
            </summary>
            <param name="crvEnd0"></param>
            <param name="arc0"></param>
            <param name="crvEnd1"></param>
            <param name="arc1"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Curve.IsExtension(System.Double,Nucleus.Geometry.Vertex)">
            <summary>
            Is the specified parameter change at the specified end vertex an extension
            or a contraction of the curve?
            </summary>
            <param name="t"></param>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.CurveExtensions">
            <summary>
            Static class containing helper extension methods for collections of curves
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.CurveExtensions.OffsetAll(System.Collections.Generic.IList{Nucleus.Geometry.Curve},System.Double)">
            <summary>
            Offset all curves in this collection on the XY plane by the specified distance
            </summary>
            <param name="curves"></param>
            <param name="distance">The offset distance</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.CurveExtensions.OffsetAllInwards(System.Collections.Generic.IList{Nucleus.Geometry.Curve},System.Double)">
            <summary>
            Offset all curves in this collection on the XY plane, automatically determining
            for closed curves (where possible) the direction of offset that will result in the offset
            curve being inside the starting curve.  Note that determining this may not be possible for
            all curves.
            </summary>
            <param name="curves"></param>
            <param name="distance"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.CurveExtensions.ExplodeAll(System.Collections.Generic.IList{Nucleus.Geometry.Curve},System.Boolean)">
            <summary>
            'Explode' these curves into individual curve segments
            </summary>
            <param name="curves"></param>
            <param name="recursive"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.CurveExtensions.JoinCurves(System.Collections.Generic.IList{Nucleus.Geometry.Curve})">
            <summary>
            Join as many curves as possible in this collection which have matching ends
            into PolyCurves.  Returns the collection of curves post joining.
            </summary>
            <param name="curves"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.CurveExtensions.JoinOrderedCurves(System.Collections.Generic.IList{Nucleus.Geometry.Curve},Nucleus.Geometry.CurveCollection)">
            <summary>
            Join together a sequential set of curves where their end points
            lie within tolerance of one another.  Where multiple curves can be
            joined they will be brought together as PolyCurves, otherwise they
            will be added directly to the result collection.
            </summary>
            <param name="curves"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.CurveExtensions.TangentsAt``1(System.Collections.Generic.IList{``0},System.Double)">
            <summary>
            Extract an array of all the tangencies of the curves in
            this collection at the specified parameter location.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="curves"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.CurveExtensions.Reversed``1(``0)">
            <summary>
            Returns a reversed duplicate of this curve.
            </summary>
            <typeparam name="TCurve"></typeparam>
            <param name="curve"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.CurveCollection">
            <summary>
            A collection of curve objects
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.CurveCollection.TotalEnclosedArea(Nucleus.Geometry.Plane)">
            <summary>
            Calculate the combined enclosed area of all curves within this collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.CurveCollection.TotalLength">
            <summary>
            The total length of all curves within this collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.CurveCollection.GetLongest">
            <summary>
            Get the curve in this collection with the greatest length
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.CurveCollection.ClosestCurve(Nucleus.Geometry.Vector,System.Double@,System.Double@,Nucleus.Geometry.Vector@)">
            <summary>
            Find the closest curve to a given point within this collection
            </summary>
            <param name="toPoint">The point to test from</param>
            <param name="minDist">Output.  The minimum curve-point distance found.</param>
            <param name="tClosest">Output.  The parameter of the closest point on the closest curve.</param>
            <param name="closestPt">Output.  The closest point on the closest curve.</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.CylindricalCoordinateSystem">
            <summary>
            Represents a cylindrical coordinate system defined by an origin,
            longitudinal axis and a polar axis lying in the reference plane, and
            positions are defined by radius, rotation around the longitudinal axis
            from the polar one and a distance from the reference plane, or r, theta
            and z respectively.
            Positive values of theta represent anticlockwise rotations around the
            longitudinal axis.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.CylindricalCoordinateSystem.Default">
            <summary>
            The default cylindrical coordinate system.
            The origin is at the global origin.
            The longitudinal axis is set to the global z-axis
            The polar axis is set to the global x-axis.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.CylindricalCoordinateSystem.Origin">
            <summary>
            The origin point of the coordinate system
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.CylindricalCoordinateSystem.L">
            <summary>
            The unit vector defining the longitudinal axis
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.CylindricalCoordinateSystem.A">
            <summary>
            The unit vector defining the polar axis on the reference plane
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.CylindricalCoordinateSystem.#ctor">
            <summary>
            Default constructor.  Creates a cylindrical coordinate system with the
            longitudinal axis aligned along the global z-axis and the polar axis
            aligned along the global x-axis, with its origin at the global origin.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.CylindricalCoordinateSystem.#ctor(Nucleus.Geometry.Vector)">
            <summary>
            Origin constructor.  Creates a cylindrical coordinate system with the 
            longitudinal axis aligned along the global z-axis and the polar axis
            aligned along the global x-axis, with its origin at the specified point.
            </summary>
            <param name="origin">The origin point</param>
        </member>
        <member name="M:Nucleus.Geometry.CylindricalCoordinateSystem.#ctor(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Create a cylindrical coordinate system defined by an origin point and 
            the longitudinal axis.  The polar axis will be aligned towards the global X-axis.
            </summary>
            <param name="origin"></param>
            <param name="lAxis"></param>
        </member>
        <member name="M:Nucleus.Geometry.CylindricalCoordinateSystem.#ctor(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Angle)">
            <summary>
            Create a cylindrical coordinate system defined by an origin point, the
            longitudinal axis and a rotation angle by which the polar axis is to be
            oriented from the global x-axis.
            </summary>
            <param name="origin"></param>
            <param name="lAxis"></param>
            <param name="aRotation"></param>
        </member>
        <member name="M:Nucleus.Geometry.CylindricalCoordinateSystem.#ctor(Nucleus.Geometry.CartesianCoordinateSystem)">
            <summary>
            Plane constructor.  Creates a cylindrical coordinate system by specifying
            the reference plane.  The longitudinal axis will be taken as the local
            z-axis of the plane, the polar as the local x and the origin set to the
            plane's origin.
            </summary>
            <param name="plane"></param>
        </member>
        <member name="M:Nucleus.Geometry.CylindricalCoordinateSystem.#ctor(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Origin, polar axis, plane vector constructor.  Creates a cylindrical coordinate
            system from an origin point and two vectors lying on the reference plane.
            </summary>
            <param name="origin">The origin point</param>
            <param name="aAxis">The polar axis vector</param>
            <param name="onPlane">Another vector which lies on the reference plane
            but that is not coincident with the polar axis vector</param>
        </member>
        <member name="M:Nucleus.Geometry.CylindricalCoordinateSystem.#ctor(Nucleus.Geometry.CylindricalCoordinateSystem)">
            <summary>
            Duplication constructor.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Nucleus.Geometry.CylindricalCoordinateSystem.#ctor(Nucleus.Geometry.CylindricalCoordinateSystem,Nucleus.Geometry.Vector)">
            <summary>
            Duplication constructor, moving the origin of the coordinat system to a new position
            </summary>
            <param name="other"></param>
            <param name="origin"></param>
        </member>
        <member name="M:Nucleus.Geometry.CylindricalCoordinateSystem.#ctor(Nucleus.Geometry.Vector[])">
            <summary>
            Constructor specifying all axes as a single vector array containing
            Origin, L, A in that order.
            Allows data to be populated via a static function in a subclass constructor.
            </summary>
            <param name="vectors"></param>
        </member>
        <member name="M:Nucleus.Geometry.CylindricalCoordinateSystem.GlobalToLocal(Nucleus.Geometry.Vector,System.Boolean)">
            <summary>
            Convert a vector defined in the global coordinate system into 
            one defined in local coordinates of this coordinate system,
            where X = radius, Y = theta, Z = z
            </summary>
            <param name="vector">A cartesian vector in the global coordinate system.</param>
            <param name="direction">If true, this vector represents a direction rather than a point
            and will be transformed without reference to the origin.</param>
            <returns>A vector in local coordinates, where X = radius, Y = theta, Z = z</returns>
        </member>
        <member name="M:Nucleus.Geometry.CylindricalCoordinateSystem.LocalToGlobal(Nucleus.Geometry.Vector,System.Boolean)">
            <summary>
            Convert a vector defined in the local coordinate system into
            one defined in global coordinates
            </summary>
            <param name="vector">A vector in the local coordinate system,
            where X = radius and Y = theta.</param>
            <param name="direction">If true, this vector represents a direction rather than a point
            and will be transformed without reference to the origin.</param>
            <returns>A vector in global cartesian coordinates</returns>
        </member>
        <member name="M:Nucleus.Geometry.CylindricalCoordinateSystem.LocalToGlobal(System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
            Convert a set of coordinates defined in the local coordinate system
            into one defined in global coordinates
            </summary>
            <param name="r">The radial distance to the point on the reference plane</param>
            <param name="theta">The rotation from the polar axis, A</param>
            <param name="z">The distance from the reference plane</param>
            <param name="direction">If true, this vector represents a direction rather than a point
            and will be transformed without reference to the origin.</param>
            <returns>A vector representing a position in the global cartesian coordinate system.</returns>
        </member>
        <member name="M:Nucleus.Geometry.CylindricalCoordinateSystem.Azimuth(Nucleus.Geometry.Vector)">
            <summary>
            Calculate the azimuth angle of the given point.
            This is the angle necessary for the polar axis to be rotated
            about the longitudinal one in order to be pointing in the direction
            of the specified point.
            </summary>
            <param name="point">The point to test</param>
            <returns>The azimuth angle, in degrees</returns>
        </member>
        <member name="T:Nucleus.Geometry.CoordinateAxis">
            <summary>
            An enum representing one of the standard three dimensions
            </summary>
        </member>
        <member name="T:Nucleus.Geometry.Circle">
            <summary>
            Immutable geometric primitive representing a planar region within a
            set radius of an origin point.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Circle.Radius">
            <summary>
            The radius of the circle
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Circle.Circumference">
            <summary>
            The circumference of the circle
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Circle.Area">
            <summary>
            The area enclosed by this circle on its own plane
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Circle.#ctor(System.Double)">
            <summary>
            Radius constructor
            Creates a disk centred on the origin on the global XY plane
            </summary>
            <param name="radius">The radius of the circle</param>
        </member>
        <member name="M:Nucleus.Geometry.Circle.#ctor(System.Double,Nucleus.Geometry.CylindricalCoordinateSystem)">
            <summary>
            Radius, coordinatesystem constructor.
            Creates a circle lying on the reference plane and centred on the origin
            of the specified coordinate system.
            </summary>
            <param name="radius">The radius of the circle</param>
            <param name="cSystem">The coordinate system on which the circle will be placed</param>
        </member>
        <member name="M:Nucleus.Geometry.Circle.#ctor(System.Double,Nucleus.Geometry.CylindricalCoordinateSystem,Nucleus.Geometry.Vector)">
            <summary>
            Radius, coordinatesystem, origin constructor.
            Creates a circle orientated to the given coordinate system but with a new origin
            </summary>
            <param name="radius">The radius of the circle</param>
            <param name="cSystem">The coordinate system on which the circle will be placed</param>
        </member>
        <member name="M:Nucleus.Geometry.Circle.#ctor(System.Double,Nucleus.Geometry.CartesianCoordinateSystem)">
            <summary>
            Radius, Coordinate System constructor.
            Creates a circle on the XY plane of the given coordinate system with the specified radius.
            </summary>
            <param name="radius"></param>
            <param name="cSystem"></param>
        </member>
        <member name="M:Nucleus.Geometry.Circle.#ctor(Nucleus.Geometry.Circle)">
            <summary>
            Duplication constructor.
            Create a copy of the other circle.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Nucleus.Geometry.Circle.#ctor(Nucleus.Geometry.Circle,Nucleus.Geometry.Vector)">
            <summary>
            Dupication constructor.
            Create a copy of the other circle, moving its centroid to the specified point
            </summary>
            <param name="other"></param>
            <param name="origin"></param>
        </member>
        <member name="M:Nucleus.Geometry.Circle.#ctor(System.Double,Nucleus.Geometry.Vector)">
            <summary>
            Create a Disk of the specified radius about the specified centrepoint.
            The disk will be oriented to the global XY plane.
            </summary>
            <param name="radius">The radius of the circle</param>
            <param name="centre">The centre point of the circle</param>
        </member>
        <member name="M:Nucleus.Geometry.Circle.#ctor(System.Double,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Create a Disk of the specified radius about the specified centrepoint
            lying on a plane perpendicular to the given normal direction
            </summary>
            <param name="radius">The radius of the circle</param>
            <param name="centre">The centrepoint of the circle</param>
            <param name="normal">The normal vector to the plane the circle lies on</param>
        </member>
        <member name="M:Nucleus.Geometry.Circle.#ctor(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Initialise a circle from three points.  The positions specified must all be different.
            </summary>
            <param name="pt0">The first point on the circle.  Will be used as the 'start' point
            of the circle as well.</param>
            <param name="pt1">The second point on the circle</param>
            <param name="pt2">The third point on the circle</param>
        </member>
        <member name="M:Nucleus.Geometry.Circle.#ctor(Nucleus.Geometry.Vector@,Nucleus.Geometry.Vector@,Nucleus.Geometry.Vector@,System.Double)">
            <summary>
            Initialise a circle from three points
            Internal version that allows the radius to be calculated only once.
            </summary>
            <param name="pt0"></param>
            <param name="pt1"></param>
            <param name="pt2"></param>
        </member>
        <member name="M:Nucleus.Geometry.Circle.Calculate3PtCSystem(Nucleus.Geometry.Vector@,Nucleus.Geometry.Vector@,Nucleus.Geometry.Vector@,System.Double@)">
            <summary>
            Calculate the data needed for initialising a circle from 3 points
            </summary>
            <param name="pt0"></param>
            <param name="pt1"></param>
            <param name="pt2"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Circle.Closest(Nucleus.Geometry.Vector)">
            <summary>
            Find the closest point on this circle to the specified test point.
            Expressed as a circle parameter which is itself a rotation angle
            counter-clockwise around the circle.
            </summary>
            <param name="toPoint">The point to test.</param>
            <returns>The closest position as an angle</returns>
        </member>
        <member name="M:Nucleus.Geometry.Circle.ClosestPoint(Nucleus.Geometry.Vector)">
            <summary>
            Find the closest point on this circle to the specified test point.
            Expressed as a position vector.
            </summary>
            <param name="toPoint">The point to test.</param>
            <returns>The closest position as a Vector</returns>
        </member>
        <member name="M:Nucleus.Geometry.Circle.IsInside(Nucleus.Geometry.Vector)">
            <summary>
            Does the (projection of the) specified point lie within this circle?
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Circle.PointAt(System.Double)">
            <summary>
            Find the position on the circle at the specified angular parameter
            </summary>
            <param name="t">An angle around the circle, in Radians</param>
            <param name="t">An angle (anti-clockwise) around the circle, in Radians</param>
            <returns>The point on the circle at the specified parameter</returns>
        </member>
        <member name="M:Nucleus.Geometry.Circle.Divide(System.Int32)">
            <summary>
            Divide this circle into a number of equal-length segments and return
            the division points between those segments.
            </summary>
            <param name="divisions">The number of segments to divide the circle into</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Circle.Divide(System.Int32,Nucleus.Geometry.Angle,Nucleus.Geometry.Angle)">
            <summary>
            Divide an arc segment of this circle into a number of equal-length segments
            and return the division points between those segments
            </summary>
            <param name="divisions"></param>
            <param name="arcStart"></param>
            <param name="arcEnd"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nucleus.Geometry.Circle.PointAt(Nucleus.Geometry.Angle)" -->
        <member name="M:Nucleus.Geometry.Circle.TangentAt(System.Double)">
            <summary>
            Find the unit tangent vector to the circle at the specified angular
            parameter
            </summary>
            <param name="t">An angle (anti-clockwise) around the circle, in Radians</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Circle.TangentAt(Nucleus.Geometry.Angle)">
            <summary>
            Find the unit tangent vector to the circle at the specified angular
            parameter
            </summary>
            <param name="t">An angle (anti-clockwise) around the circle, in Radians</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Circle.TangentAxisAt(Nucleus.Geometry.Angle)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Circle.Plane">
            <summary>
            Get the plane on which this circle lies
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Circle.Move(Nucleus.Geometry.Vector)">
            <summary>
            Create a copy of this circle, moved along the specified translation vector
            </summary>
            <param name="translation"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Circle.Transform(Nucleus.Geometry.Transform)">
            <summary>
            Create a transformed copy of this circle
            !!!TEMPORARY IMPLEMENTATION THAT ONLY WORKS FOR SIMPLE UNIFORM SCALING!!!
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Circle.MaximumShiftWhileCovering(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Calculate the maximum distance this circle could be moved in the specified
            direction while still keeping the specfied point within the circle.
            Returned as a distance along the direction vector.
            </summary>
            <param name="point">A point.  Must lie within the circle.</param>
            <param name="direction">A vector in the direction of movement.</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.ICoordinateSystem">
            <summary>
            Interface for objects that define a local coordinate system.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.ICoordinateSystem.GlobalToLocal(Nucleus.Geometry.Vector,System.Boolean)">
            <summary>
            Convert a vector defined in the global coordinate system into 
            one defined in local coordinates of this coordinate system.
            </summary>
            <param name="vector">A vector in the global coordinate system.</param>
            <param name="direction">If true, this vector represents a direction rather than a point
            and will be transformed without reference to the origin.</param>
            <returns>A vector in local coordinates</returns>
        </member>
        <member name="M:Nucleus.Geometry.ICoordinateSystem.LocalToGlobal(Nucleus.Geometry.Vector,System.Boolean)">
            <summary>
            Convert a vector defined in the local coordinate system into
            one defined in global coordinates
            </summary>
            <param name="vector">A vector in the local coordinate system.</param>
            <param name="direction">If true, this vector represents a direction rather than a point
            and will be transformed without reference to the origin.</param>
            <returns>A vector in global coordinates</returns>
        </member>
        <member name="M:Nucleus.Geometry.ICoordinateSystem.LocalToGlobal(System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
            Convert a set of coordinates defined in the local coordinate system
            into one defined in global coordinates
            </summary>
            <param name="c0">The first coordinate.</param>
            <param name="c1">The second coordinate.</param>
            <param name="c2">The third coordinate.</param>
            <param name="direction">If true, this vector represents a direction rather than a point
            and will be transformed without reference to the origin.</param>
            <returns>A vector representing a position in the global cartesian coordinate system.</returns>
        </member>
        <member name="T:Nucleus.Geometry.ICoordinateSystemExtensions">
            <summary>
            Extension methods for objects which implement the ICoordinateSystem interface
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.ICoordinateSystemExtensions.DirectionVector(Nucleus.Geometry.ICoordinateSystem,Nucleus.Geometry.Direction)">
            <summary>
            Get the global direction vector of the specified local direction
            </summary>
            <param name="cSys"></param>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.IPosition">
            <summary>
            Interface for entities which occupy a position in space
            represented by a vector - nodes, vertices etc.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.IPosition.Position">
            <summary>
            Get the position vector of this object
            </summary>
        </member>
        <member name="T:Nucleus.Geometry.IPositionExtensions">
            <summary>
            Extension methods for IPosition objects
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.IPositionExtensions.DistanceTo(Nucleus.Geometry.IPosition,Nucleus.Geometry.IPosition)">
            <summary>
            Find the distance between the position of this object and the
            position of another IPosition-implementing object
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.IPositionExtensions.DistanceToSquared(Nucleus.Geometry.IPosition,Nucleus.Geometry.IPosition)">
            <summary>
            Find the squared distance between the position of this object and
            the position of another IPosition-implementing object.
            This operation will be more efficient that the DistanceTo alternative
            as it does not involve a (slow) square-root operation.
            </summary>
            <param name="thisIPos"></param>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.IPositionExtensions.DistanceTo(Nucleus.Geometry.IPosition,Nucleus.Geometry.Vector)">
            <summary>
            Find the distance between the position of this object and the
            position of another IPosition-implementing object
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.IPositionExtensions.DistanceToSquared(Nucleus.Geometry.IPosition,Nucleus.Geometry.Vector)">
            <summary>
            Find the squared distance between the position of this object and
            the position of another IPosition-implementing object.
            This operation will be more efficient that the DistanceTo alternative
            as it does not involve a (slow) square-root operation.
            </summary>
            <param name="thisIPos"></param>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.IPositionExtensions.PolygonContainmentXY``1(System.Collections.Generic.IList{``0},Nucleus.Geometry.Vector)">
            <summary>
            Check for containment of a point within a polygon with these vertices on the XY plane
            </summary>
            <param name="point">The point to test for containment</param>
            <returns>True if the point is inside (or on) the polygon, else false.</returns>
        </member>
        <member name="M:Nucleus.Geometry.IPositionExtensions.AveragePoint``1(System.Collections.Generic.IList{``0})">
            <summary>
            Find the averate position vector of a this collection of points
            </summary>
            <typeparam name="T"></typeparam>
            <param name="points"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.IPositionExtensions.PolygonEdgePointAt``1(System.Collections.Generic.IList{``0},System.Double)">
            <summary>
            Get a point along the edge of the polygon represented by this set of points,
            denoted by a parameter matching the indices of the edge points.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="points"></param>
            <param name="t">The parameter from which to extract the point.  Note that
            this is not unitised to the length of the polygon edge but instead corresponds to
            the vertex indices - i.e. 0-1 will be between the first and second indices,
            1-2 will be between the second and third and so on.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.IPositionExtensions.CleanTinyEdges``1(System.Collections.Generic.IList{``0},System.Double)">
            <summary>
            Remove from this list of points any which are within tolerance of the preceeding point
            </summary>
            <typeparam name="T"></typeparam>
            <param name="polygon"></param>
            <param name="tolerance">The limit within which points will be removed</param>
        </member>
        <member name="M:Nucleus.Geometry.IPositionExtensions.FindFurthest``1(System.Collections.Generic.IEnumerable{``0},Nucleus.Geometry.Vector)">
            <summary>
            Find the furthest object in this set from the specified position
            </summary>
            <typeparam name="T"></typeparam>
            <param name="positions"></param>
            <param name="fromThis"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.IPositionExtensions.FindFurthestInDirection``1(System.Collections.Generic.IEnumerable{``0},Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Find the closest object in this set to the specified position that lies in the specified direction
            </summary>
            <typeparam name="T"></typeparam>
            <param name="positions"></param>
            <param name="toPoint"></param>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.IPositionExtensions.FindClosest``1(System.Collections.Generic.IEnumerable{``0},Nucleus.Geometry.IPosition)">
            <summary>
            Find the closest object in this enumerable to the specified position
            </summary>
            <typeparam name="T"></typeparam>
            <param name="positions"></param>
            <param name="toThis"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.IPositionExtensions.FindClosestInDirection``1(System.Collections.Generic.IEnumerable{``0},Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Find the closest object in this set to the specified position that lies in the specified direction
            </summary>
            <typeparam name="T"></typeparam>
            <param name="positions"></param>
            <param name="toPoint"></param>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.IPositionExtensions.ClosestDistanceSquared``1(System.Collections.Generic.IEnumerable{``0},Nucleus.Geometry.IPosition)">
            <summary>
            Find the distance to the closest object in this enumerable to the specified position
            </summary>
            <typeparam name="T"></typeparam>
            <param name="positions"></param>
            <param name="toThis"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.IPositionExtensions.VectorToNext``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Get the vector from the position at the specified index to the
            position after it in this list
            </summary>
            <param name="v"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.Line">
            <summary>
            A straight line between two points.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Line.Closed">
            <summary>
            Whether this curve is closed.
            If true, the end of the curve is treated as being the same as the start point.
            Lines cannot be closed, so this will always return false.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Line._Vertices">
            <summary>
            Private backing field for Vertices property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Line.Vertices">
            <summary>
            The collection of vertices which are used to define the geometry of this shape.
            The line will be defined as a straight line in between the first and last vertices
            in this collection.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Line.SegmentCount">
            <summary>
            Get the number of segments that this curve posesses.
            Segments are stretches of the curve that can be evaluated independantly 
            of the rest of the curve.
            Valid lines have one segment.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Line.MidPoint">
            <summary>
            Get the mid-point of the line
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Line.Direction">
            <summary>
            Get a unit vector in the direction of the line from start to end
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Line.#ctor">
            <summary>
            Default constructor.  Initialises an empty line with
            no geometry.  The line will not be valid until its vertices
            are populated.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Line.#ctor(Nucleus.Geometry.Line)">
            <summary>
            Creates a new line with the same geometry as another.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Nucleus.Geometry.Line.#ctor(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.GeometryAttributes)">
            <summary>
            Constructor to create a new line between two points
            </summary>
            <param name="startPoint">The start point of the line</param>
            <param name="endPoint">The end point of the line</param>
        </member>
        <member name="M:Nucleus.Geometry.Line.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,Nucleus.Geometry.GeometryAttributes)">
            <summary>
            Constructor to create a new line between two sets of coordinates
            </summary>
            <param name="x0">The x coordinate of the line start</param>
            <param name="y0">The y coordinate of the line start</param>
            <param name="z0">The z coordinate of the line start</param>
            <param name="x1">The x coordinate of the line end</param>
            <param name="y1">The y coordinate of the line end</param>
            <param name="z1">The z coordinate of the line end</param>
        </member>
        <member name="M:Nucleus.Geometry.Line.#ctor(System.Double,System.Double,System.Double,System.Double,Nucleus.Geometry.GeometryAttributes)">
            <summary>
            Constructor to create a new line between two sets of coordinates
            on the XY plane.
            </summary>
            <param name="x0">The x coordinate of the line start</param>
            <param name="y0">The y coordinate of the line start</param>
            <param name="x1">The x coordinate of the line end</param>
            <param name="y1">The y coordinate of the line end</param>
        </member>
        <member name="M:Nucleus.Geometry.Line.#ctor(Nucleus.Geometry.Vertex,Nucleus.Geometry.Vertex)">
            <summary>
            Constructor to create a new line between two vertices
            </summary>
            <param name="startVertex">The start vertex of the line.  This should not be shared with any other geometry.</param>
            <param name="endVertex">The end vertex of the line.  This should not be shared with any other geometry.Thi</param>
        </member>
        <member name="M:Nucleus.Geometry.Line.#ctor(Nucleus.Model.Node,Nucleus.Model.Node)">
            <summary>
            Initialises a new line between two nodes.
            </summary>
            <param name="startNode">The node at the beginning of the line</param>
            <param name="endNode">The node at the end of the line</param>
        </member>
        <member name="M:Nucleus.Geometry.Line.SegmentEnd(System.Int32)">
            <summary>
            Get the vertex (if any) which defines the end of the specified segment.
            </summary>
            <param name="index">The segment index.  Valid range 0 to SegmentCount</param>
            <returns>The end vertex of the given segment, if it exists.  Else null.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Line.CalculateLength">
            <summary>
            Calculate the length of the line
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Line.CalculateEnclosedArea(Nucleus.Geometry.Vector@,Nucleus.Geometry.Plane)">
            <summary>
            Calculate the area enclosed by this line.
            This is an easy calculation because it's zero.
            </summary>
            <param name="centroid"></param>
            <param name="onPlane"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Line.Set(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Set this line to run between the specified start and end points.
            Will modify the positions of the start and end vertices of this line.
            </summary>
            <param name="startPt"></param>
            <param name="endPt"></param>
        </member>
        <member name="M:Nucleus.Geometry.Line.PointAtLength(System.Double,System.Boolean)">
            <summary>
            Evaluate a point on this curve a specified distance from the start or end.
            </summary>
            <param name="length">The length along the curve</param>
            <param name="fromEnd">If true, the length will be measured from the end
            of the curve.  If false (default) it will be measured from the start.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Line.ParameterAt(System.Double)">
            <summary>
            Get the curve parameter at the specified length along this curve.
            If the returned parameter falls outside the range 0-1, the specified
            length does not fall within the domain of the curve.
            </summary>
            <param name="length">The distance along the curve from the start of the curve to the point in question</param>
            <returns>A curve parameter</returns>
        </member>
        <member name="M:Nucleus.Geometry.Line.Divide(System.Int32)">
            <summary>
            Generate a set of evenly-spaced points along this line
            by dividing it into the specified number of segments.
            The resulting number of points will be divisions + 1
            </summary>
            <param name="divisions"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Line.ClosestParameter(Nucleus.Geometry.Vector)">
            <summary>
            Find the closest point on this line to a test point, expressed as
            a parameter from 0-1 (Start-End)
            </summary>
            <param name="toPoint">The test point</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Line.ClosestPoint(Nucleus.Geometry.Vector)">
            <summary>
            Find the closest point on this line to a test point
            </summary>
            <param name="toPoint">The test point</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Line.Offset(System.Double,System.Boolean,System.Boolean)">
            <summary>
            Offset this curve on the XY plane
            </summary>
            <param name="distances">The offset distance.
            Positive numbers will result in the offset curve being to the right-hand 
            side, looking along the curve.  Negative numbers to the left.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Line.Offset(System.Collections.Generic.IList{System.Double},System.Boolean,System.Boolean)">
            <summary>
            Offset this curve on the XY plane by varying distances for
            each span.
            </summary>
            <param name="distances">The offset distance.
            Positive numbers will result in the offset curve being to the right-hand 
            side, looking along the curve.  Negative numbers to the left.</param>
            <param name="tidy">If true (default) collapsed segments will be removed.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Line.ExtendToLine(Nucleus.Geometry.Line)">
            <summary>
            Extend this line to meet (as closely as possible) another.
            The start or end vertex of this line (whichever will result in the smallest
            overall movement) will be moved to meet the other at the closest point.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Line.EnclosesXY(Nucleus.Geometry.Vector)">
            <summary>
            Check whether the specified point lies within the area enclosed by this curve
            on the XY plane
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Line.Extract(Nucleus.Maths.Interval)">
            <summary>
            Extract a portion of this curve as a new curve
            </summary>
            <param name="subDomain">The subdomain of this curve to
            be extracted as a new curve</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Line.ToSimpleCurves">
            <summary>
            Decompose this curve down to simple primitive curve types such
            as line and arc segments.  Lines are already 'simple' and so this
            will just return a list containing this line.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Line.ClosestPoint(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Find the closest point on a line segment specified by start and end points to
            a test point.
            </summary>
            <param name="startPt">The start point of the line</param>
            <param name="endPt">The end point of the line</param>
            <param name="testPt">The point from which the distance is to be checked</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Line.ClosestParameter(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Find the closest point on a line segment specified by start and end points to
            a test point.
            </summary>
            <param name="startPt">The start point of the line</param>
            <param name="endPt">The end point of the line</param>
            <param name="testPt">The point from which the distance is to be checked</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.Plane">
            <summary>
            Represents an infinite plane described in terms of an origin point and a local coordinate system,
            where X and Y axes lie on the plane and the Z axis is normal to it.
            The coordinate system of the plane is right-handed.
            Immutable geometric primitive.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Plane.GlobalXY">
            <summary>
            A preset plane representing the global XY plane, centered on the global origin.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Plane.GlobalYZ">
            <summary>
            A preset plane representing the global YZ plane, centred on the global origin.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Plane.GlobalXZ">
            <summary>
            A present plane representing the global XZ plane, centred on the global origin.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Plane.GlobalYX">
            <summary>
            A preset plane representing the global XY plane, centered on the global origin,
            but aligned with its X-axis lying along the global Y-axis.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Plane.#ctor">
            <summary>
            Default constructor.  Plane is initialised as a global XY plane.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Plane.#ctor(Nucleus.Geometry.Vector)">
            <summary>
            Constructor creating a global XY plane with its origin at the specified point
            </summary>
            <param name="origin">The origin point of the new plane</param>
        </member>
        <member name="M:Nucleus.Geometry.Plane.#ctor(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Constructor creating a plane defined by an origin point and a normal vector.
            The X- and Y-axes will be generated perpendicular to the normal vector and with the x-axis orientated as closely as possible to the global x-axis.
            </summary>
            <param name="origin">The origin point of the plane</param>
            <param name="normal">The normal vector to the plane.  Will become the plane's local Z-axis.
            Should be a unit vector if consistent scaling is required.</param>
        </member>
        <member name="M:Nucleus.Geometry.Plane.#ctor(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Constructor creating a plane defined by an origin and two vectors on the plane.
            </summary>
            <param name="origin">The origin point of the plane</param>
            <param name="xAxis">The first vector that lies on the plane.  Will form the plane local x-axis.</param>
            <param name="xyVector">A second vector that lies on the plane but that is not coincident with the first.</param>
        </member>
        <member name="M:Nucleus.Geometry.Plane.#ctor(Nucleus.Geometry.CartesianCoordinateSystem)">
            <summary>
            Constructor creating a plane from the XY plane of the specified coordinate system
            </summary>
            <param name="cSystem"></param>
        </member>
        <member name="M:Nucleus.Geometry.Plane.#ctor(Nucleus.Geometry.CartesianCoordinateSystem,Nucleus.Geometry.Vector)">
            <summary>
            Initialise a new plane aligned with the XY plane of the specified coordinate system positioned
            at a new origin point
            </summary>
            <param name="cSystem">The coordinate system (or plane) to copy orientation from</param>
            <param name="newOrigin">The origin point of the new plane</param>
        </member>
        <member name="M:Nucleus.Geometry.Plane.#ctor(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Constructor explicitly specifying all axes.
            The data is not validated.
            </summary>
            <param name="origin"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:Nucleus.Geometry.Plane.Project(Nucleus.Geometry.Vector)">
            <summary>
            Project the specified point onto the plane.
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Plane.DistanceTo(Nucleus.Geometry.Vector)">
            <summary>
            Get the distance above or below the plane the specified point lies.
            This is returned as a signed multiple of the local z-axis.
            If above the plane the result will be positive, if below negative.
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Plane.AreaRatio">
            <summary>
            Get the adjustment ratio of an area plotted on this plane to that of
            its projection on the global XY plane.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Plane.AreaRatio(Nucleus.Geometry.Plane)">
            <summary>
            Get the adjustment ratio of an area plotted on this plane to that of
            its projection on the specified plane
            </summary>
            <param name="onPlane"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Plane.Rotate(Nucleus.Geometry.Vector,Nucleus.Geometry.Angle)">
            <summary>
            Rotate this plane around its origin about the specified axis
            </summary>
            <param name="axis">The axis of rotation</param>
            <param name="rotation">The angle of rotation</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Plane.Rotate(Nucleus.Geometry.Angle)">
            <summary>
            Create a copy of this Plane rotated about its own normal.
            The plane itself will remain the same however the local coordinate axes will
            have been rotated within that plane.
            </summary>
            <param name="rotation"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Plane.From3Points(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Construct a plane from three points in space.
            The three points must be different, else this will fail and return null.
            </summary>
            <param name="origin">The point to be used as the origin of the plane</param>
            <param name="ptX">A point lying on the X-axis</param>
            <param name="ptXY">A point lying somewhere on the XY-plane, but not on the X-axis</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Plane.FromXAndZ(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Construct a cartesian coordinate system from X and Z axis vectors
            </summary>
            <param name="origin"></param>
            <param name="xAxis"></param>
            <param name="zAxis"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Plane.FromXAxis(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Construct a plane from an X axis, using the global Z axis
            </summary>
            <param name="origin"></param>
            <param name="xAxis"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.PolyCurve">
            <summary>
            A curve formed of several continuous curves joined together.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.PolyCurve.SubCurves">
            <summary>
            The sub-curves of this PolyCurve
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.PolyCurve.Closed">
            <summary>
            Whether this curve is closed.
            If true, the end of the curve is treated as being the same as the start point.
            Default (for most curve types) is false.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.PolyCurve.IsValid">
            <summary>
            Is the definition of this shape valid?
            i.e. does it have the correct number of vertices, are all parameters within
            acceptable limits, etc.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.PolyCurve.Vertices">
            <summary>
            The collection of vertices which are used to define the geometry of this shape.
            Different shapes will provide different means of editing this collection.
            DO NOT directly modify the collection returned from this property unless you are
            sure you know what you are doing.
            For PolyCurves, this will generate a combined collection of all sub-curve vertices.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Nucleus.Geometry.PolyCurve.SegmentCount" -->
        <member name="P:Nucleus.Geometry.PolyCurve.Start">
            <summary>
            Get the vertex at the start of the curve (if there is one)
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.PolyCurve.End">
            <summary>
            Get the vertex at the end of the curve (if there is one)
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.#ctor(Nucleus.Geometry.GeometryAttributes)">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.#ctor(Nucleus.Geometry.Curve,Nucleus.Geometry.GeometryAttributes)">
            <summary>
            Curve constructor.  Initialises a polycurve starting with the specifed curve
            </summary>
            <param name="curve"></param>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.#ctor(System.Collections.Generic.IEnumerable{Nucleus.Geometry.Curve},Nucleus.Geometry.GeometryAttributes)">
            <summary>
            Initialises a new polycurve 
            </summary>
            <param name="curves"></param>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.#ctor(Nucleus.Geometry.PolyCurve)">
            <summary>
            Creates a new polycurve as a copy of another one
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.#ctor(Nucleus.Geometry.Curve[])">
            <summary>
            Creates a new PolyCurve consisting of the specified sub-curves
            </summary>
            <param name="curves"></param>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.CalculateLength">
            <summary>
            Calculate the total length of this polycurve
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.CalculateSegmentLength(System.Int32)">
            <summary>
            Calculate the length of the specified segment in this polycurve
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.ClosestParameter(Nucleus.Geometry.Vector)">
            <summary>
            Find the closest position along this polycurve to a test point,
            expressed as a parameter value from 0-1 (start-end)
            </summary>
            <param name="toPoint">The test point</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.ParameterAt(Nucleus.Geometry.Vertex)">
            <summary>
            Get the curve parameter at the specified vertex
            </summary>
            <param name="vertex">The vertex.  Must be a defining vertex of this curve.</param>
            <returns>A curve parameter</returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.ParameterAtVertexIndex(System.Int32)">
            <summary>
            Get the curve parameter at the vertex at the specified index
            </summary>
            <param name="vertexIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.PointAt(System.Int32,System.Double)">
            <summary>
            Evaluate a point defined by a parameter within a specified span.
            </summary>
            <param name="span">The index of the span.  Valid range 0 to SegmentCount - 1</param>
            <param name="tSpan">A normalised parameter defining a point along this span of this curve.
            Note that parameter-space is not necessarily uniform and does not equate to a normalised length.
            0 = span start, 1 = span end.
            </param>
            <returns>The vector coordinates describing a point on the curve span at the specified parameter,
            if the curve definition and parameter are valid.  Else, null.</returns>
            <remarks>The base implementation treats the curve as being defined as a polyline, with straight lines
            between vertices.</remarks>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.CalculateEnclosedArea(Nucleus.Geometry.Vector@,Nucleus.Geometry.Plane)">
            <summary>
            Calculate the area enclosed by this curve, were the start and end points to be 
            joined by a straight line segment.
            A plane may optionally be specified, otherwise by default the projected area on 
            the XY plane will be used.
            </summary>
            <param name="centroid">Output.  The centroid of the enclosed area, in local coordinates
            on the specified plane.</param>
            <param name="onPlane">The plane to use to calculate the area.
            If not specified, the XY plane will be used.</param>
            <returns>The signed area enclosed by this curve on the specified plane,
            as a double.</returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.Add(Nucleus.Geometry.Curve)">
            <summary>
            Add a new sub-curve to this PolyCurve.
            Note that to form a valid polycurve the new sub-curve *must*
            start at a point within tolerance of the end point of the
            last sub-curve.
            </summary>
            <param name="subCurve">The curve to add.</param>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.Add(Nucleus.Geometry.Curve,System.Boolean)">
            <summary>
            Add a new sub-curve to this PolyCurve.
            Note that to form a valid polycurve the new sub-curve *must*
            start at a point within tolerance of the end point of the
            last sub-curve.  If autoConnect is set to true, this condition
            will be checked for and a line segment automatically added to
            connect the curve ends if necessary.
            </summary>
            <param name="subCurve">The curve to add.</param>
            <param name="autoConnect">If true, a line segment will automatically be added between
            the end of the last curve and the start of the newly-added one to close
            any gap between them, if necessary.</param>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.AddLine(Nucleus.Geometry.Vector)">
            <summary>
            Add a new line segment to the end of this polycurve.
            The line will run from the end of the last subcurve in this polycurve
            to the specified point.
            This polycurve must contain at least one subcurve already in order for the start
            point to be determined.
            </summary>
            <param name="lineEnd">The end point of the new line segment.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.AddLine(System.Double,System.Double,System.Double)">
            <summary>
            Add a new line segment to the end of this polycurve.
            The line will run from the end of the last subcurve in this polycurve
            to the specified point.
            This polycurve must contain at least one subcurve already in order for the start
            point to be determined.
            </summary>
            <param name="endX">The x-coordinate of the end point of the new line segement</param>
            <param name="endY">The y-coordinate of the end point of the new line segement</param>
            <param name="endZ">The z-coordinate of the end point of the new line segement</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.AddArc(Nucleus.Geometry.Vector)">
            <summary>
            Add a new arc segment to the end of this polycurve.
            The arc will run from the end of the last subcurve in this polycurve
            to the specified, maintaining tangency with the last segment.
            This polycurve must contain at least one subcurve already in order for the
            start point to be determined.
            </summary>
            <param name="arcEnd"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.AddArc(System.Double,System.Double,System.Double)">
            <summary>
            Add a new arc segment to the end of this polycurve.
            The arc will run from the end of the last subcurve in this polycurve
            to the specified, maintaining tangency with the last segment.
            This polycurve must contain at least one subcurve already in order for the
            start point to be determined.
            </summary>
            <param name="endX">The x-coordinate of the end point of the new arc segement</param>
            <param name="endY">The y-coordinate of the end point of the new arc segement</param>
            <param name="endZ">The z-coordinate of the end point of the new arc segement</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.AddArcTangent(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Add a new arc segment to the end of this polycurve.
            The arc will run from the end of the last subcurve in this polycurve
            to the specified point, following the specified tangent at its start.
            This polycurve must contain at least one subcurve already in order for the
            start point to be determined.
            </summary>
            <param name="endX">The x-coordinate of the end point of the new arc segement</param>
            <param name="endY">The y-coordinate of the end point of the new arc segement</param>
            <param name="endZ">The z-coordinate of the end point of the new arc segement</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.AddArcTangent(Nucleus.Geometry.Vector,System.Double,System.Double,System.Double)">
            <summary>
            Add a new arc segment to the end of this polycurve.
            The arc will run from the end of the last subcurve in this polycurve
            to the specified point, following the specified tangent at its start.
            This polycurve must contain at least one subcurve already in order for the
            start point to be determined.
            </summary>
            <param name="endX">The x-coordinate of the end point of the new arc segement</param>
            <param name="endY">The y-coordinate of the end point of the new arc segement</param>
            <param name="endZ">The z-coordinate of the end point of the new arc segement</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.Close">
            <summary>
            Close this polycurve by adding an extra line segment between end and start,
            if it is not already closed
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.Offset(System.Collections.Generic.IList{System.Double},System.Boolean,System.Boolean)">
            <summary>
            Offset this curve on the XY plane by varying distances for
            each span.
            </summary>
            <param name="distances">The offset distance.
            Positive numbers will result in the offset curve being to the right-hand 
            side, looking along the curve.  Negative numbers to the left.</param>
            <param name="tidy">If true (default) collapsed segments will be removed.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.Extract(Nucleus.Maths.Interval)">
            <summary>
            Extract a portion of this curve as a new curve
            </summary>
            <param name="subDomain">The subdomain of this curve to
            be extracted as a new curve</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.PopulateWithSubCurves(Nucleus.Maths.Interval,Nucleus.Geometry.PolyCurve)">
            <summary>
            Populate another polycurve with the portions of this one which lie within
            the specified subDomain
            </summary>
            <param name="subDomain"></param>
            <param name="result"></param>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.IsPolyline">
            <summary>
            Could this PolyCurve be accurately represented using a polyline?
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.ToPolyLine">
            <summary>
            Convert this polycurve to a (typically lighter)
            polyline utilising the same vertex positions.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.Explode(System.Boolean)">
            <summary>
            'Explode' this curve into a collection of its constituent
            segments as individual curves.
            </summary>
            <param name="recursive">If true (default), any sub-curves of
            this curve which themselves have sub-curves will also be exploded
            and added to the collection.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.ToSimpleCurves">
            <summary>
            Decompose this polycurve down to simple primitive curve types such
            as line and arc segments
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.ToPolyCurve">
            <summary>
            Get a polycurve version of this curve.  As this curve is
            already a polycurve, this simply returns a self-reference.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.IsSelfIntersectingXY">
            <summary>
            Does this curve self-intersect on the XY plane?
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.Reverse">
            <summary>
            Reverse the direction of this curve
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.TrimStart(System.Double)">
            <summary>
            Reduce the length of this curve from the start
            by the specified value
            </summary>
            <param name="length">The length to cut back from the curve end</param>
            <returns>True if successful, false if not.</returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.TrimEnd(System.Double)">
            <summary>
            Reduce the length of this curve from the end
            by the specified value
            </summary>
            <param name="length">The length to cut back from the curve end</param>
            <returns>True if successful, false if not.</returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.FilletSharpCorners(Nucleus.Geometry.Angle,System.Double)">
            <summary>
            Automatically fillet any sharp corners between segments in the PolyCurve
            </summary>
            <param name="angleLimit">The smallest permissible angle</param>
            <param name="filletLength">The smallest permissible length of the added fillet curve</param>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.ExtractLongCurveChain(Nucleus.Geometry.Angle)">
            <summary>
            Extract from this PolyCurve a chain of subcurves, starting with the
            longest and continuing to select the longest edge until no more can
            be added without adding an edge which is within an angle tolerance of
            an existing curve within the chain.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.FastDuplicateSubCurves">
            <summary>
            Create a collection of fast duplicates of the sub-curves in
            this polycurve
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.Rectangle(System.Double,System.Double,System.Double)">
            <summary>
            Generates a rectangular polycurve on the XY plane centred on the origin
            </summary>
            <param name="depth">The depth of the rectangle</param>
            <param name="width">The width of the rectangle</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyCurve.Trapezoid(System.Double,System.Double,System.Double)">
            <summary>
            Generates a trapezoid polygon on the XY plane with the midpoint of each edge 
            centred on the origin and with a different top and bottom width.
            </summary>
            <param name="depth">The depth of the trapezoid</param>
            <param name="topWidth">The width of the top of the trapezoid</param>
            <param name="baseWidth">The width of the base of the trapezoid</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.PolyLine">
            <summary>
            A curve consisting of straight lines between vertices.
            A polyline may be either open or closed - if closed the
            last vertex is assumed to have a line segment connecting
            it to the first vertex.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.PolyLine.Closed">
            <summary>
            Whether this curve is closed.
            If true, the end of the curve is treated as being the same as the start point.
            Default is false.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.PolyLine.IsValid">
            <summary>
            Is this polyline valid?
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.PolyLine._Vertices">
            <summary>
            Private backing field for Vertices collection
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.PolyLine.Vertices">
            <summary>
            The collection of vertices which are used to define the geometry of this polyline.
            The polyline will be defined as straight lines in between the vertices
            in this collection.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.PolyLine.Points">
            <summary>
            Get an array of the points that define the geometry of this polyline
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.PolyLine.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.PolyLine.#ctor(Nucleus.Geometry.Vector[])">
            <summary>
            Initialise a polyline curve between the given set of points
            </summary>
            <param name="points"></param>
        </member>
        <member name="M:Nucleus.Geometry.PolyLine.#ctor(System.Boolean,Nucleus.Geometry.Vector[])">
            <summary>
            Initialise a polyline curve between the given set of points, optionally closing the loop
            </summary>
            <param name="close"></param>
            <param name="points"></param>
        </member>
        <member name="M:Nucleus.Geometry.PolyLine.#ctor(System.Collections.Generic.IEnumerable{Nucleus.Geometry.Vector},System.Boolean,Nucleus.Geometry.GeometryAttributes)">
            <summary>
            Points constructor.
            Creates a polyline between the specified set of points
            </summary>
            <param name="points"></param>
            <param name="close"></param>
        </member>
        <member name="M:Nucleus.Geometry.PolyLine.#ctor(Nucleus.Geometry.PolyLine)">
            <summary>
            Create a PolyLine that is a copy of another PolyLine
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Nucleus.Geometry.PolyLine.#ctor(System.Collections.Generic.IEnumerable{Nucleus.Geometry.Vector},Nucleus.Geometry.GeometryAttributes)">
            <summary>
            Points constructor.
            Creates a polyline between the specified set of points
            </summary>
            <param name="points"></param>
            <param name="close"></param>
        </member>
        <member name="M:Nucleus.Geometry.PolyLine.Close(System.Boolean)">
            <summary>
            Close this polyline, so that a line segment joins the last vertex and the first one.
            </summary>
            <param name="close">If true, polyline will be made closed.  If false, will be made unclosed.</param>
        </member>
        <member name="M:Nucleus.Geometry.PolyLine.Add(Nucleus.Geometry.Vector)">
            <summary>
            Add a new point to the end of the polyline 
            (creating a new polyline segment if this is not the first point added)
            </summary>
            <param name="pt"></param>
        </member>
        <member name="M:Nucleus.Geometry.PolyLine.Offset(System.Collections.Generic.IList{System.Double},System.Boolean,System.Boolean)">
            <summary>
            Offset this curve on the XY plane by varying distances for
            each span.
            </summary>
            <param name="distances">The offset distance.
            Positive numbers will result in the offset curve being to the right-hand 
            side, looking along the curve.  Negative numbers to the left.</param>
            <param name="tidy">If true (default) collapsed segments will be removed.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyLine.ToLines">
            <summary>
            Convert this polycurve into an equivalent list
            of Line objects
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyLine.IsSelfIntersectingXY">
            <summary>
            Does this polyline self-intersect on the XY plane?
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyLine.ToPolyCurve">
            <summary>
            Convert this polyline into a polycurve containing
            line objects representing the same geometry
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyLine.Explode(System.Boolean)">
            <summary>
            'Explode' this curve into a collection of its constituent
            segments as individual curves.
            </summary>
            <param name="recursive">If true (default), any sub-curves of
            this curve which themselves have sub-curves will also be exploded
            and added to the collection.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyLine.Extract(Nucleus.Maths.Interval)">
            <summary>
            Extract a portion of this curve as a new curve
            </summary>
            <param name="subDomain">The subdomain of this curve to
            be extracted as a new curve</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyLine.ToSimpleCurves">
            <summary>
            Decompose this curve down to simple primitive curve types such
            as line and arc segments.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyLine.Clean">
            <summary>
            Automatically tidy up this polyline by removing any adjacent 
            duplicate vertices
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.PolyLine.TrimStart(System.Double)">
            <summary>
            Reduce the length of this curve from the start
            by the specified value
            </summary>
            <param name="length">The length to cut back from the curve end</param>
            <returns>True if successful, false if not.</returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyLine.TrimEnd(System.Double)">
            <summary>
            Reduce the length of this curve from the end
            by the specified value
            </summary>
            <param name="length">The length to cut back from the curve end</param>
            <returns>True if successful, false if not.</returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyLine.Trapezoid(System.Double,System.Double,System.Double)">
            <summary>
            Static factory method to create a polyline representing a trapezoid centred on the
            origin of the XY plane.  If depth or both widths are 0 or lower, null will be returned instead.
            </summary>
            <param name="depth">The depth of the trapezoid</param>
            <param name="topWidth">The width of the top of the trapezoid</param>
            <param name="baseWidth">The width of the base of the trapezoid</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyLine.Rectangle(System.Double,System.Double)">
            <summary>
            Static factory method to create a polyline representing a rectangle centred on the
            origin on the XY plane.  If the depth or width are 0 or lower null will be returned instead.
            </summary>
            <param name="depth">The depth of the rectangle</param>
            <param name="width">The width of the rectangle</param>
            <returns>A polyline representing the specified rectangle with vertices arranged in an
            anti-clockwise manner, or null is the input depth and width are invalid.</returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyLine.Rectangle(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Static factory method to create a polyline representing a rectangle with the specified
            corner point coordinates.
            </summary>
            <returns>A polyline representing the specified rectangle with vertices arranged in an
            anti-clockwise manner, or null is the input depth and width are invalid.</returns>
        </member>
        <member name="M:Nucleus.Geometry.PolyLine.Rectangle(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Static factory method to create a polyline representing a rectangle on the XY plane between the two specified
            corner points.
            </summary>
            <param name="v0"></param>
            <param name="v1"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.VertexGeometry">
            <summary>
            An abstract base class for vertex geometry - geometry defined by and containing 
            a set of vertices.
            Different types of geometry will require different numbers and types of vertices
            and will interpret them in different ways, however the basic data structure is 
            always the same.
            </summary>
            <typeparam name="TVertex">The type of vertex used to define this shape</typeparam>
            <typeparam name="TParameter">The type of the parameter used to indicate a 
            specific position </typeparam>
        </member>
        <member name="F:Nucleus.Geometry.VertexGeometry._SuppressChangedNotification">
            <summary>
            When true, changes to this geometry will be made silently without being
            reported.  Used to prevent multiple change notifications being sent when
            significant geometry changes are made that may result in a chain of partial
            update notifications being enacted.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.VertexGeometry._Element">
            <summary>
            Private backing field for Element property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.VertexGeometry.Element">
            <summary>
            The element, if any, that this shape describes geometry for.
            Shapes can exist independently of any element, but may only belong to
            a maximum of one at any one time.
            If this shape does not describe element geometry this will return null.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.VertexGeometry.Vertices">
            <summary>
            The collection of vertices which are used to define the geometry of this shape.
            Different shapes will provide different means of editing this collection.
            DO NOT directly modify the collection returned from this property unless you are
            sure you know what you are doing.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.VertexGeometry.VertexCount">
            <summary>
            Get the total number of vertices that define this geometry
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.VertexGeometry.IsValid">
            <summary>
            Is the definition of this shape valid?
            i.e. does it have the correct number of vertices, are all parameters within
            acceptable limits, etc.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.VertexGeometry._Attributes">
            <summary>
            Private backing field for Attributes property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.VertexGeometry.Attributes">
            <summary>
            Optional attached display attributes for this geometry, which determine how this
            object is drawn.  This property may be null, in which case default options should
            be used.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.VertexGeometry._BoundingBox">
            <summary>
            Private backing member variable for the BoundingBox property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.VertexGeometry.BoundingBox">
            <summary>
            The axis-aligned bounding box that contains this shape.
            Will be calculated as-needed and cached until invalidated by a geometry update.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.VertexGeometry.SuppressChangeNotifications(System.Boolean)">
            <summary>
            Suppress or unsuppress reporting of geometry changes to this shape.
            Call this before and after operations that may result in multiple changes
            to avoid each individual change prompting a separate notification.
            </summary>
            <param name="value">The new value of the suppression flag.
            If true, subsequent change notifications will be suppressed.
            If false, subsequent change notifications will be allowed.</param>
        </member>
        <member name="M:Nucleus.Geometry.VertexGeometry.MapTo(Nucleus.Geometry.ICoordinateSystem)">
            <summary>
            Transform this shape from local coordinates on the specified coordinate system
            to global coordinates.
            </summary> 
        </member>
        <member name="M:Nucleus.Geometry.VertexGeometry.Move(Nucleus.Geometry.Vector)">
            <summary>
            Move this shape along the specified translation vector
            </summary>
            <param name="translation"></param>
        </member>
        <member name="M:Nucleus.Geometry.VertexGeometry.Transform(Nucleus.Geometry.Transform)">
            <summary>
            Apply the specified transformation to this shape
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.VertexGeometry.GenerateBoundingBox">
            <summary>
            Internal function used to populate the BoundingBox property
            when necessary.
            The default implementation returns the bounding box of the vertices
            which define this shape.
            </summary>
            <returns>A new boundingbox</returns>
        </member>
        <member name="M:Nucleus.Geometry.VertexGeometry.InvalidateCachedGeometry">
            <summary>
            Invalidate any temporarily cached geometric data in this shape, forcing
            it to be recalculated the next time it is needed
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.VertexGeometry.NotifyGeometryUpdated">
            <summary>
            Notify this shape that one or more of its vertices or another aspect
            of it's geometric definition has been altered.  May prompt recalculation
            of certain other properties.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.VertexGeometry.CopyAttachedDataFrom(Nucleus.Geometry.VertexGeometry,System.Boolean)">
            <summary>
            Copy attached data (for example, nodes connected to vertices)
            from another shape to this one.
            </summary>
            <param name="other"></param>
            <param name="copyOnlyIfCoincident">If true, data will only be copied between
            vertices if the old and new vertex are within tolerance of one another.
            If false (default) data will be copied regardless.</param>
        </member>
        <member name="M:Nucleus.Geometry.VertexGeometry.DettachNodes">
            <summary>
            Dettach all nodes from the vertices of this shape
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.VertexGeometry.Flatten(System.Double)">
            <summary>
            Flatten all vertices of this geometry to the specified Z level
            </summary>
            <param name="Z"></param>
        </member>
        <member name="M:Nucleus.Geometry.VertexGeometry.StretchBoxAround(Nucleus.Geometry.BoundingBox)">
            <summary>
            Stretch a bounding box to fit around this geometry.
            </summary>
            <param name="box"></param>
        </member>
        <member name="T:Nucleus.Geometry.VertexGeometryCollection`1">
            <summary>
            A generic, observable, keyed collection of vertex geometry objects
            </summary>
            <typeparam name="TShape"></typeparam>
        </member>
        <member name="P:Nucleus.Geometry.VertexGeometryCollection`1.BoundingBox">
            <summary>
            Get the bounding box of the geometry contained within this collection
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.VertexGeometryCollection`1.AllVertices">
            <summary>
            Get a collection containing all of the vertices belonging to the geometry in this collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.VertexGeometryCollection`1.GeometryInBounds(Nucleus.Geometry.BoundingBox,System.Boolean,Nucleus.Geometry.VertexGeometryCollection{`0})">
            <summary>
            Get the geometry in this collection that falls within the specified axis-aligned bounding box
            </summary>
            <param name="bounds">The bounding box to check</param>
            <param name="inclusive">If true, the output can include objects that lie partially within the bounds, else
            the geometry must be entirely contained by the box to be included</param>
            <param name="addToThis">The output collection, to which passing geometry should be added</param>
        </member>
        <member name="M:Nucleus.Geometry.VertexGeometryCollection`1.SetAllWeights(System.Double)">
            <summary>
            Set the display 'Weight' attribute of all geometry in this collection
            </summary>
            <param name="weight"></param>
        </member>
        <member name="T:Nucleus.Geometry.VertexGeometryCollection">
            <summary>
            An observable, keyed collection of vertex geometry objects
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.VertexGeometryCollection.AllOnLayer(System.String)">
            <summary>
            Extract from this collection all geometry objects that are marked as lying on
            a layer with the specified name
            </summary>
            <param name="layerName">The layer name to search for.  Case sensitive.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.VertexGeometryCollection.Layered">
            <summary>
            Extract a dictionary of geometry objects keyed by the layer name of their attributes
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.VertexGeometryCollection.GeometryInBounds(Nucleus.Geometry.BoundingBox,System.Boolean)">
            <summary>
            Get the geometry in this collection that falls within the specified axis-aligned bounding box
            </summary>
            <param name="bounds">The bounding box to check</param>
            <param name="inclusive">If true, the output can include objects that lie partially within the bounds, else
            the geometry must be entirely contained by the box to be included</param>
        </member>
        <member name="M:Nucleus.Geometry.VertexGeometryCollection.RationalisePolycurves">
            <summary>
            Convert any polycurves in this collection that can be expressed accurately as polylines
            into PolyLine objects
            </summary>
        </member>
        <member name="T:Nucleus.Geometry.Vertex">
            <summary>
            Base class for vertices - positions in space that
            form part of the definition (or are themselves derived from)
            a particular piece of geometry, and that may have additional
            attached data defining properties at that position.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Vertex.UnsetIndex">
            <summary>
            The value set aside to indicate an unset vertex index
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Vertex._Position">
            <summary>
            Private backing member variable for the Position property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Vertex.Position">
            <summary>
            The current position of this vertex.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Vertex.X">
            <summary>
            Shortcut property to get or set the X coordinate of the position of this vertex
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Vertex.Y">
            <summary>
            Shortcut property to get or set the Y coordinate of the position of this vertex
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Vertex.Z">
            <summary>
            Shortcut property to get or set the Z coordinate of the position of this vertex
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Vertex._Owner">
            <summary>
            Private backing member variable for the Shape property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Vertex.Owner">
            <summary>
            The shape (if any) that this vertex belongs to.
            Vertices removed from their owner will automatically be detatched from
            their node to prevent memory leaks.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Vertex.Element">
            <summary>
            Get the element (if any) that this vertex forms part of the geometric definition for
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Vertex._Node">
            <summary>
            Internal backing member for node property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Vertex.Node">
            <summary>
            The node, if any, that this vertex is attached to.
            This node may be shared with other vertices and represents
            a point of connection between them.
            By default, this property is null and this vertex is not
            connected to any other.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Vertex._Number">
            <summary>
            Private backing field for VertexIndex property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Vertex.Number">
            <summary>
            The index of this vertex.
            This is a temporary value which will be populated during certain
            operations (such as drawing), but will not generally be populated automatically.
            This does *not* necessarily correspond to the position of this vertex in
            the containing shape.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Vertex._Data">
            <summary>
            Private backing field for Data property
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Vertex.Data">
            <summary>
            The store of data objects attached to this model object.
            This container can be used to add and retrieve data objects of specific
            types.
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Vertex.IsStart">
            <summary>
            Is this vertex the start of a curve?
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Vertex.IsEnd">
            <summary>
            Is this vertex the end of a curve?
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Vertex.#ctor">
            <summary>
            Parameterless constructor.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Vertex.#ctor(Nucleus.Geometry.Vector)">
            <summary>
            Position constructor.
            Create a vertex with an explicitly defined position.
            </summary>
            <param name="position"></param>
        </member>
        <member name="M:Nucleus.Geometry.Vertex.#ctor(Nucleus.Model.Node)">
            <summary>
            Node constructor.
            Initialises a new vertex at the specified node position
            and connected to the specified node.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:Nucleus.Geometry.Vertex.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Initialise a new vertex at the specified coordinates
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:Nucleus.Geometry.Vertex.#ctor(Nucleus.Geometry.Vertex)">
            <summary>
            Initialise a new vertex copying data from the specified other
            vertex
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Nucleus.Geometry.Vertex.MapTo(Nucleus.Geometry.ICoordinateSystem)">
            <summary>
            Transform this vertex by mapping it from local coordinates on the given system to
            global coordinates
            </summary>
            <param name="cSyatem">The coordinate system to use to map the vertex geometric data</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nucleus.Geometry.Vertex.Transform(Nucleus.Geometry.Transform)" -->
        <member name="M:Nucleus.Geometry.Vertex.NotifyOwnerOfPositionUpdate">
            <summary>
            Notify the owning shape that the geometry of this vertex has been updated
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Vertex.NotifyComponentPropertyChanged(System.Object,System.String)">
            <summary>
            Notify this owner that a property of a data component has been changed.
            This may then be 'bubbled' upwards with a new event.
            </summary>
            <param name="component"></param>
            <param name="propertyName"></param>
        </member>
        <member name="M:Nucleus.Geometry.Vertex.HasData">
            <summary>
            Check whether this object has any attached data components
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Vertex.HasData(System.Type)">
            <summary>
            Check whether this object has any attached data components of the specified type
            </summary>
            <param name="componentType"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vertex.NodalOffset">
            <summary>
            Calculate the offset of the position of this vertex from
            the node that it is connected to.
            </summary>
            <returns>The vector from this vertex's node position to its actual position</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vertex.SetPositionByNodalOffset(Nucleus.Geometry.Vector)">
            <summary>
            Set the position of this vertex by an offset vector from
            its node.
            </summary>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vertex.HasData``1">
            <summary>
            Check whether this object has any attached data components of the specified type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vertex.GetData``1">
            <summary>
            Get the data component of the specified type attached to this object (if one exists)
            </summary>
            <typeparam name="T">The type of the attached data component to be retrieved</typeparam>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vertex.GetData``1(System.Boolean)">
            <summary>
            Get data of the specified generic type (or the closest available sub-type) attached to
            this object.  If no data component of the specified type is found then optionally a
            new one will be created.
            </summary>
            <typeparam name="T">The type of data component to be retrieved.</typeparam>
            <param name="create">If true, a new data component of the specified type will
            be created and returned should one not already exist.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vertex.GetAllData``1">
            <summary>
            Get all data within this store that is of the specified generic type or which
            is assignable to that type.
            </summary>
            <typeparam name="T">The type of data component to be retrieved.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vertex.SetData(Nucleus.Model.IVertexDataComponent)">
            <summary>
            Attach a data component to this object
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
        </member>
        <member name="M:Nucleus.Geometry.Vertex.CleanData(System.Type)">
            <summary>
            Remove any attached data components of the specified type
            </summary>
            <param name="ofType"></param>
        </member>
        <member name="M:Nucleus.Geometry.Vertex.GenerateNode(Nucleus.Model.NodeGenerationParameters,Nucleus.Model.NodeCollection,Nucleus.DDTree.NodeDDTree)">
            <summary>
            Generate a node at this vertex, if it does not already posess one.
            This override can be used to generate nodes independent of a full model/element system.
            </summary>
            <param name="options"></param>
        </member>
        <member name="M:Nucleus.Geometry.Vertex.GenerateNode(Nucleus.Model.NodeGenerationParameters)">
            <summary>
            Generate a node at this vertex, if it does not already posess one.
            A new node will only be created if one does not exist and this vertex is part of
            an element's geometry definition.
            </summary>
            <param name="options"></param>
        </member>
        <member name="M:Nucleus.Geometry.Vertex.CopyAttachedDataFrom(Nucleus.Geometry.Vertex)">
            <summary>
            Copy the values of attached data objects (such as the connected node)
            from another vertex.  This is typically used when replacing one shape with another.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Nucleus.Geometry.Vertex.CompareTo(Nucleus.Geometry.Vertex)">
            <summary>
            Comparison function for sorting.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vertex.ToString">
            <summary>
            Covert this vertex to its string representation
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.WrappedCurve">
            <summary>
            Abstract base class for curves internally defined in some other
            library's native representation.
            </summary>
        </member>
        <member name="T:Nucleus.Geometry.HorizontalSetOut">
            <summary>
            Enumerated values for the horizontal set-out of section profiles
            </summary>
        </member>
        <member name="T:Nucleus.Geometry.HorizontalSetOutExtensions">
            <summary>
            Extension methods for the HorizontalSetOut enum
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.HorizontalSetOutExtensions.IsEdge(Nucleus.Geometry.HorizontalSetOut)">
            <summary>
            Is this set out relative to either the left or right edge?
            </summary>
            <param name="hSO"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.VerticalSetOut">
            <summary>
            Enumerated values for the vertical set-out of section profiles
            </summary>
        </member>
        <member name="T:Nucleus.Geometry.VerticalSetOutExtensions">
            <summary>
            Extension methods for the VerticalSetOut Enum
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.VerticalSetOutExtensions.FactorFromTop(Nucleus.Geometry.VerticalSetOut)">
            <summary>
            Get the position of the set-out level as a proportion of the thickness
            of a panel.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.VerticalSetOutExtensions.IsEdge(Nucleus.Geometry.VerticalSetOut)">
            <summary>
            Is this set out relative to either the top or bottom edge?
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.Transform">
            <summary>
            A transform is an operation which can be applied to vertex geometry
            in order to change its position or orientation.
            Represented as a 4 x 4 transformation matrix
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Transform.#ctor">
            <summary>
            Default constructor - creates a new identity transform.
            Equates to a 4x4 matrix with the main diagonal set to 1.0.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Transform.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Constructor taking in a 3 x 3 matrix with the specified values
            </summary>
            <param name="a11">Value in row 1, column 1</param>
            <param name="a12">Value in row 1, column 2</param>
            <param name="a13">Value in row 1, column 3</param>
            <param name="a21">Value in row 2, column 1</param>
            <param name="a22">Value in row 2, column 2</param>
            <param name="a23">Value in row 2, column 3</param>
            <param name="a31">Value in row 3, column 1</param>
            <param name="a32">Value in row 3, column 2</param>
            <param name="a33">Value in row 3, column 3</param>
        </member>
        <member name="M:Nucleus.Geometry.Transform.#ctor(Nucleus.Geometry.Vector)">
            <summary>
            Translation constructor.  Creates a translation transform along the specified vector
            </summary>
            <param name="translationVector">The vector of the translation</param>
        </member>
        <member name="M:Nucleus.Geometry.Transform.#ctor(Nucleus.Maths.Matrix)">
            <summary>
            Initialise a transform based on copying data from another matrix
            </summary>
            <param name="other"></param>
        </member>
        <member name="T:Nucleus.Geometry.VertexCollection">
            <summary>
            An obervable, keyed collection of vertices
            </summary>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="P:Nucleus.Geometry.VertexCollection.HasNodalOffsets">
            <summary>
            Do any of the vertices in this collection have non-zero nodal offsets?
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.VertexCollection.#ctor(Nucleus.Geometry.VertexGeometry)">
            <summary>
            Owner constructor
            </summary>
            <param name="owner"></param>
        </member>
        <member name="M:Nucleus.Geometry.VertexCollection.#ctor">
            <summary>
            Default, parameterless constructor.
            The owner of this vertex collection will be null.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.VertexCollection.#ctor(Nucleus.Geometry.Vertex)">
            <summary>
            Initialise a new vertex collection containing a single vertex
            </summary>
            <param name="vertex"></param>
        </member>
        <member name="M:Nucleus.Geometry.VertexCollection.#ctor(System.Collections.Generic.IEnumerable{Nucleus.Geometry.Vector},Nucleus.Geometry.VertexGeometry)">
            <summary>
            Initialise a new vertex collection, converting the set of position vectors passed in into
            new vertices.
            </summary>
            <param name="points"></param>
        </member>
        <member name="M:Nucleus.Geometry.VertexCollection.#ctor(System.Collections.Generic.IEnumerable{Nucleus.Geometry.Vertex},Nucleus.Geometry.VertexGeometry)">
            <summary>
            Initialise a new vertex collection, containing the specified set of vertices
            </summary>
            <param name="points"></param>
        </member>
        <member name="M:Nucleus.Geometry.VertexCollection.SetItemOwner(Nucleus.Geometry.Vertex)">
            <summary>
            Sets the owning geometry of the specified vertex
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Nucleus.Geometry.VertexCollection.ClearItemOwner(Nucleus.Geometry.Vertex)">
            <summary>
            Clears the owning geometry of the specified
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Nucleus.Geometry.VertexCollection.BoundingBox">
            <summary>
            Calculates and returns the bounding box of all of the vertices
            within this collection.
            </summary>
            <returns>A new bounding box containing all vertices in this collection.</returns>
        </member>
        <member name="M:Nucleus.Geometry.VertexCollection.Plane(System.Double)">
            <summary>
            Calculate the plane these vertices lie on, if they are planar.
            Returns null if the vertex collection is non-planar within the specified tolerance 
            or if there are insufficient points to describe a plane.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.VertexCollection.ContainsNode(Nucleus.Model.Node)">
            <summary>
            Do any of the vertices in this collection contain a reference to
            the specified node?
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.VertexCollection.AssignVertexIndices(System.Int32)">
            <summary>
            Populate the VertexIndex properties of the vertices in this collection,
            starting from the specified (optional) value.
            </summary>
            <param name="startingIndex">The index to assign to the first vertex in the collection.
            Subsequent vertices will be numbered incrementally.</param>
        </member>
        <member name="M:Nucleus.Geometry.VertexCollection.ExtractPoints">
            <summary>
            Extract the position vectors of all vertices in this collection to
            an array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.VertexCollection.Move(Nucleus.Geometry.Vector)">
            <summary>
            Move the vertices in this collection along the specified translation vector
            </summary>
            <param name="translation"></param>
        </member>
        <member name="M:Nucleus.Geometry.VertexCollection.Transform(Nucleus.Geometry.Transform)">
            <summary>
            Apply the specified transformation to all of the vertices in this collection
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.VertexCollection.MoveGlobalToLocal(Nucleus.Geometry.ICoordinateSystem)">
            <summary>
            Move all vertices in this collection from the global coordinate system
            to equivalent positions in the specified local coordinate system
            </summary>
            <param name="cSystem"></param>
        </member>
        <member name="M:Nucleus.Geometry.VertexCollection.MoveLocalToGlobal(Nucleus.Geometry.ICoordinateSystem)">
            <summary>
            Move all vertices in this collection from the local coordinate system specified
            to equivalent positions in global 3D space
            </summary>
            <param name="cSystem"></param>
        </member>
        <member name="M:Nucleus.Geometry.VertexCollection.ClockwiseTestSum">
            <summary>
            Returns a sum value of (x1 - x0)(y1 + y0) for each vector between
            vertices in this collection, which can be used to test whether the
            vertices are overall stored in a clockwise or anti-clockwise direction.
            If the result is greater than 0, the collection is clockwise.
            If the result is less than 0, the collection is anticlockwise.
            If the result is 0, it is indeterminate.
            The final vector from the last vertex to the first one will also be included.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.Vector">
            <summary>
            3D Vector structure.
            Represents a position or direction in 3D space through X, Y and Z components.
            Immutable.
            </summary>
            <remarks>
            This type is currently implemented as a structure instead of a class for
            reasons of efficiency.  This may be reviewed once benchmarking has been performed, however.
            As the size of this struct exceeds the recommended 16 bytes, it may work out that
            passing vectors around in function arguments etc. is inefficient.  
            </remarks>
        </member>
        <member name="F:Nucleus.Geometry.Vector.Unset">
            <summary>
            A constant value representing an unset, invalid vector.
            All components are set to NaN.
            Note that as NaN values never evaluate equal, do
            not attempt comparison of this vector with others - use the
            IsValid() method to determine when a vector is null instead.
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Vector.Zero">
            <summary>
            Constant value representing a zero-length 3d vector
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Vector.UnitX">
            <summary>
            Constant value representing a unit vector along the global X-axis
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Vector.UnitY">
            <summary>
            Constant value representing a unit vector along the global Y-axis
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Vector.UnitZ">
            <summary>
            Constant value representing a unit vector along the global Z-axis
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Vector.X">
            <summary>
            The vector's X component
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Vector.Y">
            <summary>
            The vector's Y component
            </summary>
        </member>
        <member name="F:Nucleus.Geometry.Vector.Z">
            <summary>
            The vector's Z component
            </summary>
        </member>
        <member name="P:Nucleus.Geometry.Vector.Item(System.Int32)">
            <summary>
            Get an indexed component of this vector.
            0 = X, 1 = Y, 2 = Z
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Geometry.Vector.Item(Nucleus.Geometry.CoordinateAxis)">
            <summary>
            Get the specified dimension of this vector.
            </summary>
            <param name="dimension"></param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Geometry.Vector.Item(Nucleus.Geometry.Direction)">
            <summary>
            Get the component of this vector in the specified direction.
            </summary>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Geometry.Vector.Angle">
            <summary>
            Get the angle of this vector on the XY plane.
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.Vector.#ctor(System.Double,System.Double)">
            <summary>
            X, Y coordinate constructor - vector will be initialised to (x,y,0)
            </summary>
            <param name="x">The x coordinate</param>
            <param name="y">The y coordinate</param>
        </member>
        <member name="M:Nucleus.Geometry.Vector.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            X, Y, Z coordinate constructor - vector will be initialised to (x,y,z)
            </summary>
            <param name="x">The x coordinate</param>
            <param name="y">The y coordinate</param>
            <param name="z">The z coordinate</param>
        </member>
        <member name="M:Nucleus.Geometry.Vector.#ctor(Nucleus.Geometry.Angle)">
            <summary>
            Angle constructor.
            Create a new vector on the XY plane pointing in the specified
            angle anticlockwise from the global X-axis.
            </summary>
            <param name="angle">The angle of the direction of the vector, clockwise
            from the global X axis.  In radians.</param>
        </member>
        <member name="M:Nucleus.Geometry.Vector.#ctor(System.Boolean)">
            <summary>
            Validity constructor.
            If the input boolean is false then the vector will be created as an invalid vector,
            identical to the Vector.Unset constant.  If true, will be initialised as 0,0,0
            </summary>
            <param name="valid">Create a valid vector?</param>
        </member>
        <member name="M:Nucleus.Geometry.Vector.#ctor(System.String,System.Char,System.Double)">
            <summary>
            String constructor.
            Creates a new vector by attempting to parse a string in the format
            {X} [separator] {Y} [separator] {Z}.
            </summary>
            <param name="description">The string to be parsed</param>
            <param name="separator">The character used to denote the separations between coordinates.
            By default this is taken as being a comma.</param>
            <param name="scalingFactor">An optional scaling factor which can be used to
            convert from non-SI units.  Each component of the vector will be multiplied by
            this value.</param>
        </member>
        <member name="M:Nucleus.Geometry.Vector.#ctor(Nucleus.Geometry.Direction)">
            <summary>
            Create a unit vector pointing in the specified direction
            (or in the direction of the axis of rotation)
            </summary>
            <param name="direction"></param>
        </member>
        <member name="M:Nucleus.Geometry.Vector.IsValid">
            <summary>
            Is this vector valid?
            A vector is valid if all of its components are not NaN.
            </summary>
            <returns>True if all components are valid, else false.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.IsValidNonZero">
            <summary>
            Is this vector valid and non-zero?
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.XYEquals(Nucleus.Geometry.Vector)">
            <summary>
            Are the X and Y components of this vector equal to those of another?
            </summary>
            <param name="other">The vector to test against</param>
            <returns>True if the vectors are equal to
            one another on the XY plane.  Else false.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.XYEquals(Nucleus.Geometry.Vector,System.Double)">
            <summary>
            Are the X and Y components of this vector equal to those of another
            within the specified tolerance?
            </summary>
            <param name="other">The vector to test against</param>
            <param name="tolerance">A per-component tolerance value</param>
            <returns>True if the vectors are within tolerance of
            one another on the XY plane.  Else false.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Equals(Nucleus.Geometry.Vector)">
            <summary>
            IEquatable implementation.
            Checks whether this vector is equal to another.
            </summary>
            <param name="other">Another vector to check</param>
            <returns>True if the components of the two vectors are equal, else false.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Equals(Nucleus.Geometry.Vector,System.Double)">
            <summary>
            Checks whether this vector is approximately equal to another, within a tolerance value
            </summary>
            <param name="other"></param>
            <param name="tolerance"></param>
            <returns>True if the components of the two vectors are all within tolerance of
            one another.  Else false.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Equals(System.Object)">
            <summary>
            Equals override for generic objects.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.GetHashCode">
            <summary>
            GetHashCode override.
            Generates a hash code by XORing those of its components.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.MagnitudeSquared">
            <summary>
            Get the squared magnitude of this vector.
            Faster than using Magnitude() as it's calculation does not include a (slow) square-root operation.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Magnitude">
            <summary>
            Get the current magnitude of this vector.
            Use of MagnitudeSquared instead is advised in performance-criticial situations 
            where the exact value is not necessary as it does not require a square-root operation.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.DistanceToSquared(Nucleus.Geometry.Vector)">
            <summary>
            Calculate the squared distance from this position vector to another.
            </summary>
            <param name="position">Another position vector</param>
            <returns>The squared distance from this point to another, as a double.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.DistanceTo(Nucleus.Geometry.Vector)">
            <summary>
            Calculate the distance from this position vector to another.
            Use of DistanceToSquared instead is advised in performance-critical situations
            where the exact value is not necessary as it does not require a square-root operation.
            </summary>
            <param name="position">Another position vector</param>
            <returns>The distance from this point to another, as a double.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.ManhattenDistanceTo(Nucleus.Geometry.Vector)">
            <summary>
            Calculate the Manhatten distance from this position vector to another.
            The Manhatten distance is the is the sum of the absolute difference between
            each component of the two vectors - i.e. it is the distance you would have
            to travel from one point to the other if you could only move orthogonally
            along the global axes.
            </summary>
            <param name="position">Another position vector.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.XYDistanceToSquared(Nucleus.Geometry.Vector)">
            <summary>
            Calculate the squared distance from this position vector to another
            on the XY plane.
            </summary>
            <param name="position">Another position vector.</param>
            <returns>The squared distance on the XY plane from this point to another,
            as a double.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.XYDistanceTo(Nucleus.Geometry.Vector)">
            <summary>
            Calculate the distance from this position vector to another
            on the XY plane.
            </summary>
            <param name="position">Another position vector.</param>
            <returns>The distance on the XY plane from this point to another,
            as a double.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.IsCloser(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Is this point closer to a target point than another point is?
            </summary>
            <param name="toThis"></param>
            <param name="thanThisIs"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.ClosestOf(Nucleus.Geometry.Vector[])">
            <summary>
            Find and return the point within the specified set of points which is closest
            to this point.
            </summary>
            <param name="points"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.AngleTo(Nucleus.Geometry.Vector)">
            <summary>
            Find the angle on the XY plane from this position vector to another
            </summary>
            <param name="other">The position vector to measure the angle to</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.IsZero">
            <summary>
            Are all components of this vector equal to zero?
            </summary>
            <returns>True if all components are zero, else false</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Interpolate(Nucleus.Geometry.Vector,System.Double)">
            <summary>
            Interpolate between this vector and another
            </summary>
            <param name="towards">The vector to interpolate towards</param>
            <param name="factor">The interpolation factor.  0 = this vector, 1 = the 'towards' vector</param>
            <returns>An interpolated 3D vector</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Interpolate(Nucleus.Geometry.Vector,System.Double,System.Double,System.Double)">
            <summary>
            Interpolate between this vector and another corresponding to
            a set of key values
            </summary>
            <param name="v1">The vector to interpolate towards</param>
            <param name="x0">The key value mapped to this vector</param>
            <param name="x1">The key value mapped to the other vector</param>
            <param name="x">The value of the vector at the position to be interpolated</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.MoveTowards(Nucleus.Geometry.Vector,System.Double)">
            <summary>
            Returns a position moving the specified distance from this point towards 
            the target.  
            </summary>
            <param name="target">The point to move towards</param>
            <param name="step">The distance to move</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Cross(Nucleus.Geometry.Vector)">
            <summary>
            Calculate the cross, or vector, product of this and another vector.
            Creates a new vector perpendicular to both input vectors.
            </summary>
            <param name="other">The vector to cross with this one.</param>
            <returns>The cross-product vector</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Cross(Nucleus.Geometry.Vector@)">
            <summary>
            Calculate the cross, or vector, product of this and another vector.
            Creates a new vector perpendicular to both input vectors.
            </summary>
            <param name="other">The vector to cross with this one.</param>
            <returns>The cross-product vector</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Dot(Nucleus.Geometry.Vector)">
            <summary>
            Calculate the dot, or scalar, product of this and another vector.
            Provides the component of this vector in the direction of (or, the projection onto) the other vector.
            </summary>
            <param name="other">The vector to project this vector onto.  
            If the length of the projection is required, this should be a unit vector.</param>
            <returns>The dot product as a double.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Dot(Nucleus.Geometry.Vector@)">
            <summary>
            Calculate the dot, or scalar, product of this and another vector.
            Provides the component of this vector in the direction of (or, the projection onto) the other vector.
            This version recieves the other by reference to avoid having to copy the full data of the struct.
            </summary>
            <param name="other">The vector to project this vector onto.  
            If the length of the projection is required, this should be a unit vector.</param>
            <returns>The dot product as a double.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Unitize">
            <summary>
            Create a unitized version of this vector
            (i.e. a vector in the same direction but with a magnitude of 1).
            In the case that the vector is zero-length, it will remain zero length
            and will not be unitized.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Reverse">
            <summary>
            Get the inverse of this vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Scale(System.Double)">
            <summary>
            Scale this vector by a factor
            </summary>
            <param name="scalar"></param>
            <returns>A new vector created by scaling all components of this one.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Add(Nucleus.Geometry.Vector)">
            <summary>
            Add another vector to this one and return the result
            </summary>
            <param name="other">Another vector to be added to this one.</param>
            <returns>The combined vector</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Add(Nucleus.Geometry.Vector@)">
            <summary>
            Add another vector to this one and return the result.
            Pass-by-reference version.
            </summary>
            <param name="other">Another vector to be added to this one.</param>
            <returns>The combined vector</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Add(System.Double,System.Double)">
            <summary>
            Add another vector defined as X and Y coordinates to this one
            and return the resultant vector.
            </summary>
            <param name="x">The value to add to the x-component</param>
            <param name="y">The value to add to the y-component</param>
            <returns>The combined vector</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Add(System.Double,System.Double,System.Double)">
            <summary>
            Add another vector defined as X, Y and Z coordinates to this one
            and return the resultant vector.
            </summary>
            <param name="x">The value to add to the x-component</param>
            <param name="y">The value to add to the y-component</param>
            <param name="z">The value to add to the z-component</param>
            <returns>The combined vector</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.MultiplyComponents(Nucleus.Geometry.Vector)">
            <summary>
            Multiply the components of this vector by the equivalent components of
            another.  (Note that this is not the same as multiplying two vectors together!)
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.DivideComponents(Nucleus.Geometry.Vector)">
            <summary>
            Divide the components of this vector by the equivalent components of another.
            Note that this is not the same as dividing one vector by another (which is undefined!)
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Abs">
            <summary>
            Get a vector containing the absolute values of the components in this vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.AngleBetween(Nucleus.Geometry.Vector)">
            <summary>
            Calculate the (smallest, non-directional) angle between this vector and another.
            In the range -PI/2 to PI/2.
            </summary>
            <param name="other"></param>
            <returns>The smallest angle between this vector and another,
            in Radians.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Rotate(Nucleus.Geometry.Vector,Nucleus.Geometry.Angle)">
            <summary>
            Rotate this vector by an angle around an axis,
            following the right-hand rule.
            </summary>
            <param name="axis">A unit vector representing an axis of rotation.</param>
            <param name="angle">The angle of rotation, in radians.
            Counter-clockwise around the axis.</param>
            <returns>A new vector created by rotating this vector anticlockwise about the 
            given axis by the given angle.</returns>
            <remarks>Uses the Rodrigues Rotation Formula - see: 
            https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula </remarks>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Rotate(Nucleus.Geometry.Angle)">
            <summary>
            Rotate this vector by an angle on the XY plane.
            </summary>
            <param name="angle">The angle of rotation, in radians.
            Counter-clockwise around the global Z-axis.</param>
            <returns>A new vector created by rotating this vector anticlockwise about the
            given axis by the given angle.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Transform(Nucleus.Geometry.Transform)">
            <summary>
            Apply the specified transformation to this vector and return the result.
            The vector is treated as a column vector for the purposes of this calculation.
            </summary>
            <param name="transform">THe transformation matrix.</param>
            <returns>A new vector representing the result of the transformation on this one.</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Project(Nucleus.Geometry.Plane)">
            <summary>
            Project this point in space onto a plane
            </summary>
            <param name="ontoPlane">The plane to project the point onto.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Project(Nucleus.Geometry.Vector)">
            <summary>
            Project this vector onto a plane described by its normal.
            </summary>
            <param name="normal"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.WithX(System.Double)">
            <summary>
            Create a new copy of this vector, but with the specified X coordinate
            </summary>
            <param name="x">The new value of the X coordinate in the copied vector</param>
            <returns>A new vector, copying the components from this one but replacing X</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.WithY(System.Double)">
            <summary>
            Create a new copy of this vector, but with the specified Y coordinate
            </summary>
            <param name="y">The new value of the Y coordinate in the copied vector</param>
            <returns>A new vector, copying the components from this one but replacing Y</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.WithZ(System.Double)">
            <summary>
            Create a new copy of this vector, but with the specified Z coordinate
            </summary>
            <param name="z">The new value of the Z coordinate in the copied vector</param>
            <returns>A new vector, copying the components from this one but replacing Z</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.With(Nucleus.Geometry.Direction,System.Double)">
            <summary>
            Create a new copy of this vector, but replacing the specified
            direction component with the given value
            </summary>
            <param name="direction">The direction of the axis to be modified.
            XX, YY and ZZ directions are taken as referring to the X, Y and Z
            axes respectively.</param>
            <param name="value">The new value of the component</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.With(System.Int32,System.Double)">
            <summary>
            Create a new copy of this vector, but replacing the specified
            direction component with the given value
            </summary>
            <param name="index">The index of the axis to be modified.
            From 0-2, indicating 0 = X, 1 = Y, 2 = Z</param>
            <param name="value">The new value of the component</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.With(Nucleus.Base.Bool6D,System.Double)">
            <summary>
            Return a vector with the components specified set to the
            given value.  The components set to false will have their
            original value while those set to true will use the value
            specified.
            </summary>
            <param name="components">The components to replace</param>
            <param name="value">The value to set the specified components to</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.WithXY(System.Double,System.Double)">
            <summary>
            Create a new vector with the specified X and Y components but
            using the Z component of this vector.
            </summary>
            <param name="x">The new X coordinate</param>
            <param name="y">The new Y coordinate</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.AddX(System.Double)">
            <summary>
            Add a value to the X component of this vector and return the result
            </summary>
            <param name="value">The value to be added to the X component</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.AddY(System.Double)">
            <summary>
            Add a value to the Y component of this vector and return the result
            </summary>
            <param name="value">The value to be added to the Y component</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.AddZ(System.Double)">
            <summary>
            Add a value to the Z component of this vector and return the result
            </summary>
            <param name="value">The value to be added to the Z component</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.XY">
            <summary>
            Create a copy of this vector flattened to the XY plane
            </summary>
            <returns>A new vector with the same X and Y components as this one,
            but with Z set to 0</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.IsXOnly">
            <summary>
            Does this vector have a non-zero component in the X-axis only?
            </summary>
            <returns>True if only the X-component is non-zero</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.IsYOnly">
            <summary>
            Does this vector have a non-zero component in the Y-axis only?
            </summary>
            <returns>True if only the Y-component is non-zero</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.IsZOnly">
            <summary>
            Does this vector have a non-zero component in the Z-axis only?
            </summary>
            <returns>True if only the Y-component is non-zero</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.IsParallelTo(Nucleus.Geometry.Vector)">
            <summary>
            Is this vector parallel to another?
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.IsInDirection(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Test whether this position lies in a particular direction from a point.
            This test will return true for angle differences of below 90 degrees (non-inclusive)
            </summary>
            <param name="direction"></param>
            <param name="fromPoint"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.AlignTo(Nucleus.Geometry.Vector)">
            <summary>
            Flip (or not) this vector to face in the same overall direction as another
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.RoundOff(System.Double)">
            <summary>
            Create a copy of this vector with its components rounded to the nearest whole
            increment
            </summary>
            <param name="increment"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Remap(Nucleus.Geometry.CoordinateAxis,Nucleus.Geometry.CoordinateAxis,Nucleus.Geometry.CoordinateAxis)">
            <summary>
            Produce a new Vector using remapped components of this one.
            </summary>
            <param name="newX">The source dimension to use for the x component of the new vector</param>
            <param name="newY">The source dimension to use for the y component of the new vector</param>
            <param name="newZ">The source dimension to use for the z component of the new vector</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.RemapZXY">
            <summary>
            Produce a new Vector using the Z,X,Y components of this one mapped
            respectively onto X,Y,Z of the new one.
            Useful to convert points drawn on the XY plane to ones drawn on the YZ plane.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.RemapZnegXY">
            <summary>
            Produce a new Vector using the Z,-X,Y components of this one mapped
            respectively onto X,Y,Z of the new one.
            Useful to convert points drawn on the XY plane to ones drawn on the YZ plane,
            where the Y axis is flipped.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.PerpendicularXY">
            <summary>
            Get a vector perpendicular to this vector on the XY plane
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.LargestComponent">
            <summary>
            Get the absolute magnitude of the largest component coordinate of this vector.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.XComponent">
            <summary>
            Get a Vector containing only the X component of this vector.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.YComponent">
            <summary>
            Get a Vector containing only the Y component of this vector.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.ZComponent">
            <summary>
            Get a Vector containing only the Z component of this vector.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.PrimaryAxis">
            <summary>
            Get the dimensional axis in which this vector has its largest component
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.InRegion(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Is this vector inside the bounding region specified by its limiting coordinate values
            on the XY plane?
            </summary>
            <param name="minX"></param>
            <param name="maxX"></param>
            <param name="minY"></param>
            <param name="maxY"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Limit(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Return a copy of this vector limited to the specified maximum and minimum
            coordinates in the XY plane.
            </summary>
            <param name="minX"></param>
            <param name="maxX"></param>
            <param name="minY"></param>
            <param name="maxY"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.ToString">
            <summary>
            ToString override
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.PerpendicularTo(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Find the unit vector perpendicular to the plane defined by the specified three
            points.
            </summary>
            <param name="pt0"></param>
            <param name="pt1"></param>
            <param name="pt2"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.TriangleArea(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Find the area of the 3D triangle denoted by the specified three vectors
            </summary>
            <param name="pt0">The first vertex point</param>
            <param name="pt1">The second vertex point</param>
            <param name="pt2">The third vertex point</param>
            <returns>Triangle area as double</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.TriangleAreaSquared(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Find the squared area of the 3D triangle denoted by the specified three vectors
            </summary>
            <param name="pt0">The first vertex point</param>
            <param name="pt1">The second vertex point</param>
            <param name="pt2">The third vertex point</param>
            <returns>Squared triangle area as double</returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.TriangleClosestPoint(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Find the closest point on a triangle to a test point
            </summary>
            <param name="tri0">The first corner of the triangle</param>
            <param name="tri1">The second corner of the triangle</param>
            <param name="tri2">The third corner of the triangle</param>
            <param name="testPt">The point for which to find the closest point</param>
            <returns>The closest point as a Vector</returns>
            <remarks>Base on https://www.gamedev.net/forums/topic/552906-closest-point-on-triangle/ </remarks>
        </member>
        <member name="M:Nucleus.Geometry.Vector.FromLatitudeAndLongitude(Nucleus.Geometry.Angle,Nucleus.Geometry.Angle,Nucleus.Geometry.Angle,Nucleus.Geometry.Angle)">
            <summary>
            Create a Vector expressed in meters describing the position of a point on
            the Earth given in latitude and longitude relative to an origin point also
            described in latitude and longitude.
            </summary>
            <param name="latitude">The latitude of the point</param>
            <param name="longitude">The longitude of the point</param>
            <param name="originLatitude">The latitude of the origin</param>
            <param name="originLongitude">The longitude of the origin</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.FromTokensList(System.Collections.Generic.IList{System.String},System.Int32)">
            <summary>
            Create a vector from a sequential set of values in a list,
            starting at the specified index.  Out-of-bounds errors are automatically checked for.
            </summary>
            <param name="tokens"></param>
            <param name="startIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Create2D(System.Double[])">
            <summary>
            Create an array of vectors from a list of components, alternating
            between X and Y.  If the entered set of components is of an odd number,
            the Y coordinate of the last point will be taken as 0.
            </summary>
            <param name="components"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.Create3D(System.Double[])">
            <summary>
            Create an array of vectors from a list of components, cycling through
            X, Y and Z.  If the entered set of components is of an insufficient number
            to provide the full three components of each vector, missing Y and Z values
            for the final vector will be taken as zero.
            </summary>
            <param name="components"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.op_Equality(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            == operator override.
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.op_Inequality(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            != operator override
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.op_GreaterThan(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            > operator overrides.
            Compares the magnitudes of the two vectors.
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.op_LessThan(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Operator overrides.
            Compares the magnitudes of the two vectors.
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.op_GreaterThanOrEqual(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            >= operator overrides.
            Compares the magnitudes of the two vectors.
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.op_LessThanOrEqual(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Operator overrides.
            Compares the magnitudes of the two vectors.
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.op_Addition(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            + operator override.  Performs vector addition on two vectors
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.op_Subtraction(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            - operator override.  Performs vector addition on two vectors
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.op_UnaryNegation(Nucleus.Geometry.Vector)">
            <summary>
            The inverse vector.
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.op_Multiply(Nucleus.Geometry.Vector,System.Double)">
            <summary>
            * operator override.  Multiplies a vector by a scalar.
            </summary>
            <param name="v"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.op_Multiply(System.Double,Nucleus.Geometry.Vector)">
            <summary>
            * operator override.  Multiplies a vector by a scalar.
            </summary>
            <param name="v"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.op_Multiply(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            * operator override.  Calculates the dot product of two vectors
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.op_Division(Nucleus.Geometry.Vector,System.Double)">
            <summary>
            / operator override.  Divides a vector by a divisor.
            </summary>
            <param name="v"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.Vector.op_Modulus(Nucleus.Geometry.Vector,System.Double)">
            <summary>
            % operator override.  Perform
            </summary>
            <param name="v"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Geometry.VectorExtensions">
            <summary>
            Extension methods related to Vectors
            </summary>
        </member>
        <member name="M:Nucleus.Geometry.VectorExtensions.RemapZXY(Nucleus.Geometry.Vector[])">
            <summary>
            Remap all vectors in this array from the XY to the YZ plane
            </summary>
            <param name="vectors"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.VectorExtensions.RemapZnegXY(Nucleus.Geometry.Vector[])">
            <summary>
            Remap all vectors in this array from the XY to the YZ plane,
            with the Y axis flipped
            </summary>
            <param name="vectors"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.VectorExtensions.Move(System.Collections.Generic.IList{Nucleus.Geometry.Vector},Nucleus.Geometry.Vector)">
            <summary>
            Move all vectors in this array along a translation vector and return the result
            </summary>
            <param name="vectors"></param>
            <param name="translation"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.VectorExtensions.Rotate(System.Collections.Generic.IList{Nucleus.Geometry.Vector},Nucleus.Geometry.Angle)">
            <summary>
            Rotate all these vectors by an angle on the XY plane
            </summary>
            <param name="vectors"></param>
            <param name="angle"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.VectorExtensions.GlobalToLocal(Nucleus.Geometry.Vector[],Nucleus.Geometry.ICoordinateSystem,System.Boolean)">
            <summary>
            Remap all vectors in this array from the global coordinate system to the local coordinate
            system specified.
            </summary>
            <param name="vectors"></param>
            <param name="cSystem"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.VectorExtensions.LocalToGlobal(Nucleus.Geometry.Vector[],Nucleus.Geometry.ICoordinateSystem,System.Boolean)">
            <summary>
            Remap all vectors in this array from the local coordinate system specified to the global
            coordinate system.
            </summary>
            <param name="vectors"></param>
            <param name="cSystem"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.VectorExtensions.PolygonContainmentXY(System.Collections.Generic.IList{Nucleus.Geometry.Vector},Nucleus.Geometry.Vector)">
            <summary>
            Check for containment of a point within a polygon with these vertices on the XY plane
            </summary>
            <param name="point">The point to test for containment</param>
            <returns>True if the point is inside (or on) the polygon, else false.</returns>
            <remarks>This is a copy of the IPosition list extension method of the same name.
            Changes made to one must be manually adapted to the other.</remarks>
        </member>
        <member name="M:Nucleus.Geometry.VectorExtensions.XCoordinates(System.Collections.Generic.IList{Nucleus.Geometry.Vector})">
            <summary>
            Extract all of the X coordinates from a set of vectors
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.VectorExtensions.YCoordinates(System.Collections.Generic.IList{Nucleus.Geometry.Vector})">
            <summary>
            Extract all of the Y coordinates from a set of vectors
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.VectorExtensions.ZCoordinates(System.Collections.Generic.IList{Nucleus.Geometry.Vector})">
            <summary>
            Extract all of the Z coordinates from a set of vectors
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.VectorExtensions.FindClosest(System.Collections.Generic.IList{Nucleus.Geometry.Vector},Nucleus.Geometry.Vector)">
            <summary>
            Find the closest point in this set of position vectors to the target point.
            </summary>
            <param name="v"></param>
            <param name="toPoint">The test point</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.VectorExtensions.FindClosest(System.Collections.Generic.IList{Nucleus.Geometry.Vector},System.Collections.Generic.IList{Nucleus.Geometry.Vector})">
            <summary>
            Find the point in this set of position vectors which has the smalled combined
            sum of square distances to all of the points in another set.
            </summary>
            <param name="v"></param>
            <param name="toPoints"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.VectorExtensions.XYEquals(System.Collections.Generic.IList{Nucleus.Geometry.Vector},System.Collections.Generic.IList{Nucleus.Geometry.Vector},System.Double)">
            <summary>
            Check whether these vectors are equal to another set on the XY plane
            </summary>
            <param name="v"></param>
            <param name="other"></param>
            <param name="tolerance"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nucleus.Geometry.VectorExtensions.Plane(System.Collections.Generic.IList{Nucleus.Geometry.Vector},System.Double)" -->
        <member name="M:Nucleus.Geometry.VectorExtensions.ArePlanar(System.Collections.Generic.IList{Nucleus.Geometry.Vector},System.Double)">
            <summary>
            Do all points in this set lie on the same plane?
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.VectorExtensions.VectorToNext(System.Collections.Generic.IList{Nucleus.Geometry.Vector},System.Int32)">
            <summary>
            Get the vector from the point at the specified index to the
            point after it in this list
            </summary>
            <param name="v"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.VectorExtensions.MaximumAngleBetween(System.Collections.Generic.IList{Nucleus.Geometry.Vector},Nucleus.Geometry.Vector)">
            <summary>
            Find the maximum angle between any of the vectors in this collection
            and the specified other vector
            </summary>
            <param name="v"></param>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Geometry.VectorExtensions.ClockwiseTestSum(System.Collections.Generic.IList{Nucleus.Geometry.Vector})">
            <summary>
            Returns a sum value of (x1 - x0)(y1 + y0) for each vector between
            points in this collection, which can be used to test whether the
            points are overall stored in a clockwise or anti-clockwise direction.
            If the result is greater than 0, the collection is clockwise.
            If the result is less than 0, the collection is anticlockwise.
            If the result is 0, it is indeterminate.
            The final vector from the last vertex to the first one will also be included.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Logs.GrammaticalPerson">
            <summary>
            Enumerated value representing grammatical person
            </summary>
        </member>
        <member name="F:Nucleus.Logs.GrammaticalPerson.First">
            <summary>
            First persion - the speaker - 'I', 'my' etc.
            </summary>
        </member>
        <member name="F:Nucleus.Logs.GrammaticalPerson.Second">
            <summary>
            Second person - the addressee - 'You', 'your' etc.
            </summary>
        </member>
        <member name="F:Nucleus.Logs.GrammaticalPerson.Third">
            <summary>
            Third person - other parties - 'They', 'their' etc.
            </summary>
        </member>
        <member name="T:Nucleus.Logs.LogScriptMarkupParser">
            <summary>
            Class to parse markup tags in log script entries
            </summary>
        </member>
        <member name="F:Nucleus.Logs.LogScriptMarkupParser.MARKUP_OPEN">
            <summary>
            The character which depicts the start of 
            a formatting markup expression
            </summary>
        </member>
        <member name="F:Nucleus.Logs.LogScriptMarkupParser.MARKUP_CLOSE">
            <summary>
            The character which depicts the end of 
            a formatting markup expression
            </summary>
        </member>
        <member name="F:Nucleus.Logs.LogScriptMarkupParser.FUNCTION_OPEN">
            <summary>
            The character which depicts the start of
            a function markup expression
            </summary>
        </member>
        <member name="F:Nucleus.Logs.LogScriptMarkupParser.FUNCTION_CLOSE">
            <summary>
            The character which depicts the end of
            a function markup expression
            </summary>
        </member>
        <member name="F:Nucleus.Logs.LogScriptMarkupParser.ARGUMENT_OPEN">
            <summary>
            The character which depicts the start of a set of function arguments
            </summary>
        </member>
        <member name="F:Nucleus.Logs.LogScriptMarkupParser.ARGUMENT_CLOSE">
            <summary>
            The character which depicts the end of a set of function arguments
            </summary>
        </member>
        <member name="F:Nucleus.Logs.LogScriptMarkupParser.ARGUMENT_SEPARATOR">
            <summary>
            The character which separates 
            </summary>
        </member>
        <member name="F:Nucleus.Logs.LogScriptMarkupParser._Log">
            <summary>
            Private backing member variable for the Log property
            </summary>
        </member>
        <member name="P:Nucleus.Logs.LogScriptMarkupParser.Log">
            <summary>
            The log to write to
            </summary>
        </member>
        <member name="F:Nucleus.Logs.LogScriptMarkupParser._Subjects">
            <summary>
            Private backing member variable for the Subjects property
            </summary>
        </member>
        <member name="P:Nucleus.Logs.LogScriptMarkupParser.Subjects">
            <summary>
            The collection of objects to be used as source data
            </summary>
        </member>
        <member name="F:Nucleus.Logs.LogScriptMarkupParser._RNG">
            <summary>
            Private backing member variable for the RNG property
            </summary>
        </member>
        <member name="P:Nucleus.Logs.LogScriptMarkupParser.RNG">
            <summary>
            The random number generator used to randomly determine variations
            </summary>
        </member>
        <member name="M:Nucleus.Logs.LogScriptMarkupParser.WriteToLog(System.String)">
            <summary>
            Parse and write a markup string to the log
            </summary>
            <param name="markup"></param>
        </member>
        <member name="M:Nucleus.Logs.LogScriptMarkupParser.ExpandMarkup(System.String)">
            <summary>
            Expand any expandable tags within a markup string
            </summary>
            <param name="markup"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Logs.LogScriptMarkupParser.ExecuteTag(System.String,System.Int32)">
            <summary>
            Execute a markup tag.  In the first pass (pass = 0) expandable
            tags will be expanded.  In the second executable tags will executed.
            </summary>
            <param name="markup"></param>
            <param name="pass"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Logs.LogScriptMarkupParser.B">
            <summary>
            Bold on
            </summary>
        </member>
        <member name="M:Nucleus.Logs.LogScriptMarkupParser._B">
            <summary>
            Bold off
            </summary>
        </member>
        <member name="M:Nucleus.Logs.LogScriptMarkupParser.I">
            <summary>
            Italics on
            </summary>
        </member>
        <member name="M:Nucleus.Logs.LogScriptMarkupParser._I">
            <summary>
            Italics off
            </summary>
        </member>
        <member name="M:Nucleus.Logs.LogScriptMarkupParser.RANDOM(System.String,System.String)">
            <summary>
            Select a random value
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Logs.LogScriptMarkupParser.RANDOM(System.String,System.String,System.String)">
            <summary>
            Select a random value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Logs.LogScriptMarkupParser.RANDOM(System.String,System.String,System.String,System.String)">
            <summary>
            Select a random value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Logs.LogScriptMarkupParser.RANDOM(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Select a random value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Logs.LogScriptMarkupParser.RANDOMInternal(System.String[])">
            <summary>
            Select a random value
            </summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Logs.LogScriptMarkupParser.SUBJECT(System.String,System.String)">
            <summary>
            Retrieve a value from the specified subject
            </summary>
            <param name="index"></param>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Logs.LogScriptMarkupParser.GENDER(System.String,System.String,System.String,System.String)">
            <summary>
            Select a variation based on the gender of a subject
            </summary>
            <param name="index"></param>
            <param name="neutral"></param>
            <param name="masculine"></param>
            <param name="feminine"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Logs.ICalculationLog">
            <summary>
            A message log object that can be used to output records of calculations
            </summary>
        </member>
        <member name="M:Nucleus.Logs.ICalculationLog.Superscript(System.String)">
            <summary>
            Write text to the log as a superscript
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Logs.ICalculationLog.Subscript(System.String)">
            <summary>
            Write text to the log as a subscript
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Logs.ICalculationLog.Symbol(System.String)">
            <summary>
            Write a symbol to the log
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Logs.ICalculationLog.Diagram(System.String)">
            <summary>
            Add a diagram image to the log
            </summary>
            <param name="resourceURI"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Logs.ILog">
            <summary>
            An interface for message logs to which text can be written.
            </summary>
        </member>
        <member name="M:Nucleus.Logs.ILog.WriteText(System.String)">
            <summary>
            Write text to the log.
            </summary>
            <param name="text">The text string to write out</param>
            <remarks>It is recommended to use the extension method 'Write' instead
            of using this directly as that function also returns a reference to
            the log itself to allow chaining.</remarks>
        </member>
        <member name="P:Nucleus.Logs.ILog.IsBold">
            <summary>
            Get or set whether text written to the log currently will be displayed in bold.
            Some log types do not support bold text and setting this property will do nothing.
            </summary>
        </member>
        <member name="P:Nucleus.Logs.ILog.IsItalicised">
            <summary>
            Get or set whether text written to the log subsequently will be displayed in italics.
            Some log types do not support italics and setting this property will do nothing.
            </summary>
        </member>
        <member name="T:Nucleus.Logs.ILogExtensions">
            <summary>
            Extension methods for log objects
            </summary>
        </member>
        <member name="M:Nucleus.Logs.ILogExtensions.Write``1(``0,System.String)">
            <summary>
            Write text to the log.
            </summary>
            <param name="text">The text string to write out</param>
            <returns>A reference to this instance of the log, to allow chaining.</returns>
        </member>
        <member name="M:Nucleus.Logs.ILogExtensions.WriteLine``1(``0,System.String)">
            <summary>
            Write a line of text to the log, followed by a carriage return.
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Logs.ILogExtensions.WriteMarkup``1(``0,System.String,System.Random,System.Object[])">
            <summary>
            Write text to the log from a string of text containing markup.
            Returns a reference to this log to enable chaining.
            </summary>
            <typeparam name="TLog"></typeparam>
            <param name="log"></param>
            <param name="markup"></param>
            <param name="rng"></param>
            <param name="subjects"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Logs.ILogExtensions.Bold``1(``0,System.Boolean)">
            <summary>
            Switch whether text subsequently written to the log should be displayed
            with a bold weight.  Returns a reference to this log to enable chaining.
            </summary>
            <typeparam name="TLog"></typeparam>
            <param name="log"></param>
            <param name="value">If true, subsequent text will be bold, if
            false it will not.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Logs.ILogExtensions.Italics``1(``0,System.Boolean)">
            <summary>
            Switch whether text subsequently written to the log should be displayed
            in italics.  Returns a reference to this log to enable chaining.
            </summary>
            <typeparam name="TLog"></typeparam>
            <param name="log"></param>
            <param name="value">If true, subsequent text will be italicised, if
            false it will not.</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Logs.LogScript">
            <summary>
            An object which represents a script which is to be drawn upon
            to automatically populate log messages
            </summary>
        </member>
        <member name="F:Nucleus.Logs.LogScript.ENTRY_START">
            <summary>
            The sequence of characters which depicts an entry key when 
            placed at the start of a line.
            </summary>
        </member>
        <member name="F:Nucleus.Logs.LogScript._Entries">
            <summary>
            Private backing member variable for the Entries property
            </summary>
        </member>
        <member name="P:Nucleus.Logs.LogScript.Entries">
            <summary>
            The dictionary of entries, keyed by a reference string
            </summary>
        </member>
        <member name="M:Nucleus.Logs.LogScript.LoadFrom(Nucleus.Base.FilePath)">
            <summary>
            Load the script from a file
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Logs.LogScript.Load(System.IO.TextReader)">
            <summary>
            Load the script via a text reader.
            </summary>
            <param name="reader"></param>
        </member>
        <member name="T:Nucleus.Logs.LogScriptEntry">
            <summary>
            An entry in a log script which defines variations on a message.
            </summary>
        </member>
        <member name="F:Nucleus.Logs.LogScriptEntry._Variations">
            <summary>
            Private backing member variable for the Variations property
            </summary>
        </member>
        <member name="P:Nucleus.Logs.LogScriptEntry.Variations">
            <summary>
            The possible variations of log entry message, in raw markup form.
            </summary>
        </member>
        <member name="T:Nucleus.Logs.StringLog">
            <summary>
            Log class which assembles messages into a single string
            via an internal StringBuilder
            </summary>
        </member>
        <member name="F:Nucleus.Logs.StringLog._Builder">
            <summary>
            The backing StringBuilder
            </summary>
        </member>
        <member name="T:Nucleus.Calculation.CalculationAttribute">
            <summary>
            An attribute which may be used to tag calculation functions
            </summary>
        </member>
        <member name="T:Nucleus.Calculation.CalculationInputAttribute">
            <summary>
            An attribute which may be used to tag object properties which represent 
            calculation input variables
            </summary>
        </member>
        <member name="T:Nucleus.Calculation.CalculationOutputAttribute">
            <summary>
            An attribute which may be used to tag object properties which represent 
            calculation output variables
            </summary>
        </member>
        <member name="T:Nucleus.Calculation.CalculationVariableAttribute">
            <summary>
            An attribute which may be used to tag properties representing
            calculation input or output variables
            </summary>
        </member>
        <member name="T:Nucleus.Conversion.ModelConversionOptions">
            <summary>
            Conversion options for whole-model writing
            </summary>
        </member>
        <member name="F:Nucleus.Conversion.ModelConversionOptions._UpdateSince">
            <summary>
            Private backing field for UpdateSince property
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.ModelConversionOptions.UpdateSince">
            <summary>
            Gets or sets the time of the prior update/read.
            If specified, only those objects which have been modified since this time
            will be updated here.
            </summary>
        </member>
        <member name="F:Nucleus.Conversion.ModelConversionOptions._Update">
            <summary>
            Private backing field for update property
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.ModelConversionOptions.Update">
            <summary>
            Should this be updated since the last modfications, rather than being a full rewrite of the
            file.
            </summary>
        </member>
        <member name="F:Nucleus.Conversion.ModelConversionOptions._Levels">
            <summary>
            Private backing field for Levels property
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.ModelConversionOptions.Levels">
            <summary>
            Read/Write Levels?
            </summary>
        </member>
        <member name="F:Nucleus.Conversion.ModelConversionOptions._Nodes">
            <summary>
            Private backing field for Nodes property
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.ModelConversionOptions.Nodes">
            <summary>
            Read/Write Nodes?
            </summary>
        </member>
        <member name="F:Nucleus.Conversion.ModelConversionOptions._Families">
            <summary>
            Private backing field for Families property
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.ModelConversionOptions.Families">
            <summary>
            Read/Write Families?
            </summary>
        </member>
        <member name="F:Nucleus.Conversion.ModelConversionOptions._LinearElements">
            <summary>
            Private backing field for LinearElements property
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.ModelConversionOptions.LinearElements">
            <summary>
            Read/Write Linear Elements?
            </summary>
        </member>
        <member name="F:Nucleus.Conversion.ModelConversionOptions._PanelElements">
            <summary>
            Private backing field for PanelElements property
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.ModelConversionOptions.PanelElements">
            <summary>
            Read/Write Panel Elements?
            </summary>
        </member>
        <member name="F:Nucleus.Conversion.ModelConversionOptions._Constraints">
            <summary>
            Private backing field for Constraints property
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.ModelConversionOptions.Constraints">
            <summary>
            Read/Write Rigid Constraints?
            </summary>
        </member>
        <member name="F:Nucleus.Conversion.ModelConversionOptions._Sets">
            <summary>
            Private backing field for Sets property
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.ModelConversionOptions.Sets">
            <summary>
            Read/Write Sets?
            </summary>
        </member>
        <member name="F:Nucleus.Conversion.ModelConversionOptions._Loading">
            <summary>
            Private backing field for Loading property
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.ModelConversionOptions.Loading">
            <summary>
            Read/Write Loading Data?
            </summary>
        </member>
        <member name="T:Nucleus.Conversion.IDMappingsDictionary">
            <summary>
            A dictionary of IDMappingTables keyed by the filepath they were last written to.
            </summary>
        </member>
        <member name="M:Nucleus.Conversion.IDMappingsDictionary.Add(Nucleus.Conversion.IIDMappingTable)">
            <summary>
            Add a table to this collection,
            automatically extracting the key from the stored FilePath.
            The FilePath property of the table must have been set for the
            table to be successfully added.
            </summary>
            <param name="table"></param>
            <returns>True if successful, false if not.</returns>
        </member>
        <member name="M:Nucleus.Conversion.IDMappingsDictionary.GetLatest``1">
            <summary>
            Get the most recently stored ID table of the specified type
            </summary>
            <typeparam name="TTable">The type of table to find</typeparam>
            <returns>The table of that type with the most recent LastUsed value,
            or null if no tables of the specified type have been stored.</returns>
        </member>
        <member name="M:Nucleus.Conversion.IDMappingsDictionary.GetLatest(System.String)">
            <summary>
            Get the most recently stored ID table for a file with
            the specified extension.
            </summary>
            <param name="extension">The file extension to find</param>
            <returns>The table of that extension with the most recent LastUsed value,
            or null if no tables of the specified type have been stored.</returns>
        </member>
        <member name="T:Nucleus.Conversion.ConversionContext">
            <summary>
            Base class for conversion contexts - objects that contain data on the context of a conversion operation
            </summary>
        </member>
        <member name="F:Nucleus.Conversion.ConversionContext._ExInfo">
            <summary>
            Private backing field for ExInfo property
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.ConversionContext.ExInfo">
            <summary>
            The current execution information
            </summary>
        </member>
        <member name="T:Nucleus.Conversion.ConversionOptions">
            <summary>
            A basic set of options used when converting between types.
            </summary>
        </member>
        <member name="F:Nucleus.Conversion.ConversionOptions._DeleteObjects">
            <summary>
            Private backing field for DeleteMissingObjects property
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.ConversionOptions.DeleteObjects">
            <summary>
            Should objects missing from the source dataset during synchronisation be deleted from the
            target model?
            </summary>
            <summary>
            Read/Write Panel Elements?
            </summary>
        </member>
        <member name="T:Nucleus.Conversion.IDMappingTable`2">
            <summary>
            A table of identifiers mapping from one ID system to another
            </summary>
            <typeparam name="TFirstID"></typeparam>
            <typeparam name="TSecondID"></typeparam>
        </member>
        <member name="F:Nucleus.Conversion.IDMappingTable`2._FirstIDName">
            <summary>
            Private backing field for FirstIDName property
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.IDMappingTable`2.FirstIDName">
            <summary>
            The name of the first set of IDs to be contained within this table
            </summary>
        </member>
        <member name="F:Nucleus.Conversion.IDMappingTable`2._SecondIDName">
            <summary>
            Private backing field for the SecondIDName property
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.IDMappingTable`2.SecondIDName">
            <summary>
            The name of the second set of IDs to be contained within this table
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.IDMappingTable`2.FilePath">
            <summary>
            The path of the last file this ID mapping table applies to.
            Use the LinkToFile method to populate this property and also to automatically
            set the LastUsed date and time after a read or write operation.
            </summary>
        </member>
        <member name="F:Nucleus.Conversion.IDMappingTable`2._LastUsed">
            <summary>
            Private backing field for LastUsed property
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.IDMappingTable`2.LastUsed">
            <summary>
            The time (in Coordinated Universal Time, UTC) that this mapping table was last used to
            convert to a file.  This should be set to DateTime.UtcNow immediately after a read or
            write operation using this mapping has been completed.
            Using the LinkToFile method will automatically set this property.
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.IDMappingTable`2.DefaultCategory">
            <summary>
            The name of the category used to store objects when no other category is specified.
            </summary>
        </member>
        <member name="F:Nucleus.Conversion.IDMappingTable`2._TypeCategories">
            <summary>
            Private backing field for TypeCategories property
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.IDMappingTable`2.TypeCategories">
            <summary>
            Map of types to the name of the category under which they are stored
            </summary>
        </member>
        <member name="M:Nucleus.Conversion.IDMappingTable`2.#ctor(System.String,System.String)">
            <summary>
            Constructor.  Initialises a new IDMappingTable for the two specified ID type names
            </summary>
            <param name="firstIDName"></param>
            <param name="secondIDName"></param>
        </member>
        <member name="M:Nucleus.Conversion.IDMappingTable`2.LinkToFile(Nucleus.Base.FilePath)">
            <summary>
            Store the specified filepath and the current time
            to the relevant properties in this table.
            Call this method immediately after a read or write operation
            using this mapping table to store a record of the file involved.
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="M:Nucleus.Conversion.IDMappingTable`2.HasSecondID(System.String,`0)">
            <summary>
            Determines whether this mapping table contains an entry within the second set stored
            under the specified catagory and associated with the given ID from the first set.
            </summary>
            <param name="category">The mapping category</param>
            <param name="firstID">The ID from the first set</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Conversion.IDMappingTable`2.HasSecondID(`0)">
            <summary>
            Determines whether this mapping table contains an entry within the second set stored
            under any catagory and associated with the given ID from the first set.
            </summary>
            <param name="firstID">The ID from the first set</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Conversion.IDMappingTable`2.GetSecondID(Nucleus.Model.ModelObject)">
            <summary>
            Get the ID from the second set mapped to the ID of the specified object.
            The category and the first ID values will be automatically determined.
            </summary>
            <param name="mObj"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Conversion.IDMappingTable`2.GetSecondID(System.String,`0)">
            <summary>
            Get the ID from the second set within the category and associated with the ID from
            the first set specified.
            </summary>
            <param name="category">The mapping category</param>
            <param name="firstID">The ID from the first set</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Conversion.IDMappingTable`2.GetSecondID(`0)">
            <summary>
            Get the ID from the second set within any category and associated with the ID from
            the first set specified.
            </summary>
            <param name="firstID">The ID from the first set</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Conversion.IDMappingTable`2.HasFirstID(System.String,`1)">
            <summary>
            Determines whether this mapping tale contains an entry within the first set stored 
            under the specified category and associated with the given ID from the second set
            </summary>
            <param name="category">The mapping category</param>
            <param name="secondID">The ID from the second set</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Conversion.IDMappingTable`2.HasFirstID(`1)">
            <summary>
            Determines whether this mapping tale contains an entry within the first set stored 
            under the specified category and associated with the given ID from the second set
            </summary>
            <param name="secondID">The ID from the second set</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Conversion.IDMappingTable`2.GetFirstID(System.String,`1)">
            <summary>
            Get the ID from the first set within the category and associated with the ID from the
            second set specified
            </summary>
            <param name="category">The mapping category</param>
            <param name="secondID">The ID from the second set</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Conversion.IDMappingTable`2.GetFirstID(`1)">
            <summary>
            Get the ID from the first set within the category and associated with the ID from the
            second set specified
            </summary>
            <param name="category">The mapping category</param>
            <param name="secondID">The ID from the second set</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Conversion.IDMappingTable`2.GetModelObject``1(Nucleus.Model.Model,`1)">
            <summary>
            Get the model object (if any) with the first ID linked to the
            specifed second ID
            </summary>
            <typeparam name="TModelObject"></typeparam>
            <param name="model"></param>
            <param name="secondID"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Conversion.IDMappingTable`2.Add(Nucleus.Base.Unique,`1)">
            <summary>
            Add a model object's ID as a first ID, mapped to a specified
            second.  The category to store it under will be automatically determined
            by the ModelObject's type.
            </summary>
            <param name="mObject"></param>
            <param name="secondID"></param>
        </member>
        <member name="M:Nucleus.Conversion.IDMappingTable`2.ExtractFirstID(Nucleus.Base.Unique)">
            <summary>
            Extract from the specified object the ID to be used as the first ID
            in this table.
            </summary>
            <param name="unique"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Conversion.IDMappingTable`2.Add(System.String,`0,`1)">
            <summary>
            Add a new entry to this mapping table
            </summary>
            <param name="category">The mapping category</param>
            <param name="firstID">The first ID</param>
            <param name="secondID">The second ID</param>
        </member>
        <member name="M:Nucleus.Conversion.IDMappingTable`2.Add(`0,`1)">
            <summary>
            Add a new entry to this mapping table
            </summary>
            <param name="firstID"></param>
            <param name="secondID"></param>
        </member>
        <member name="M:Nucleus.Conversion.IDMappingTable`2.Remove(System.String,`0)">
            <summary>
            Remove an entry from this mapping table
            </summary>
            <param name="category"></param>
            <param name="firstID"></param>
        </member>
        <member name="M:Nucleus.Conversion.IDMappingTable`2.GetCategoryForType(System.Type)">
            <summary>
            Get the name of the category for the speicified type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Conversion.IDMappingTable`2.ToCSV(System.String)">
            <summary>
            Write this ID map to a mapping table in CSV format
            </summary>
            <param name="separator"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Conversion.IDMappingTable`2.SaveAsCSV(Nucleus.Base.FilePath,System.String)">
            <summary>
            Write out this TextFormat to a text file
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="T:Nucleus.Conversion.IIDMappingTable">
            <summary>
            Interface for tables which map from one application's unique identifier system
            to another.
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.IIDMappingTable.FirstIDName">
            <summary>
            The name of the first set of IDs to be contained within this table
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.IIDMappingTable.SecondIDName">
            <summary>
            The name of the second set of IDs to be contained within this table
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.IIDMappingTable.FilePath">
            <summary>
            The file path of the file that this mapping was written to or read from,
            if any.
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.IIDMappingTable.LastUsed">
            <summary>
            The last time that this mapping table was used
            </summary>
        </member>
        <member name="T:Nucleus.Conversion.IStringConversionContext">
            <summary>
            Interface for objects used as a context when extracting values from
            object via the GetValue(path) object extension method.
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.IStringConversionContext.SubComponentIndex">
            <summary>
            The index of the current subcomponent being written
            </summary>
        </member>
        <member name="M:Nucleus.Conversion.IStringConversionContext.SetSourceObject(System.Object)">
            <summary>
            Set the source object about which this context object
            should return data.
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:Nucleus.Conversion.IStringConversionContext.HasSubComponentsToWrite(System.Object)">
            <summary>
            Does the specified item still have sub-components which will
            need to be written out individually?
            Sub-components are child items of the object which need to
            be written still utilising properties from the parent -
            for example each mesh face in a PanelElement may need to be
            treated as a separate element.
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Conversion.ModelIDMappingTable`1">
            <summary>
            Base class for ID mapping tables where the first ID set reference model objects
            </summary>
            <typeparam name="TSecondID"></typeparam>
        </member>
        <member name="T:Nucleus.Conversion.StringConversionContextBase">
            <summary>
            Abstract base class for String conversion contexts.
            Implements a basic version of the required functionality.
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.StringConversionContextBase.SubComponentIndex">
            <summary>
            The index of the current subcomponent being written
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.StringConversionContextBase.SourceObject">
            <summary>
            The current source object
            </summary>
        </member>
        <member name="M:Nucleus.Conversion.StringConversionContextBase.HasSubComponentsToWrite(System.Object)">
            <summary>
            Does the specified item still have sub-components which will
            need to be written out individually?
            Sub-components are child items of the object which need to
            be written still utilising properties from the parent -
            for example each mesh face in a PanelElement may need to be
            treated as a separate element.
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Conversion.StringConversionContextBase.SetSourceObject(System.Object)">
            <summary>
            Set the source object.
            </summary>
            <param name="source"></param>
        </member>
        <member name="T:Nucleus.Conversion.ConversionDirection">
            <summary>
            Enum representing the possible directions of a data conversion
            </summary>
        </member>
        <member name="F:Nucleus.Conversion.ConversionDirection.Both">
            <summary>
            Conversions in both directions are possible
            </summary>
        </member>
        <member name="F:Nucleus.Conversion.ConversionDirection.AtoB">
            <summary>
            This conversion mapping applies from type A to type B, but not the other way
            </summary>
        </member>
        <member name="F:Nucleus.Conversion.ConversionDirection.BtoA">
            <summary>
            This conversion mapping applies from type B to type A, but not the other way
            </summary>
        </member>
        <member name="T:Nucleus.Conversion.ConversionDirectionsExtensions">
            <summary>
            ConversionDirections extension helper methods
            </summary>
        </member>
        <member name="M:Nucleus.Conversion.ConversionDirectionsExtensions.Invert(Nucleus.Conversion.ConversionDirection)">
            <summary>
            Invert this conversion direction
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Conversion.ITypeConverter">
            <summary>
            Interface for classes which provide functionality to convert from one type to another
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.ITypeConverter.Description">
            <summary>
            The description of this converter
            </summary>
        </member>
        <member name="M:Nucleus.Conversion.ITypeConverter.Convert(System.Object)">
            <summary>
            Perform the conversion operation on the specified object
            </summary>
            <param name="fromObject">The object to be converted</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Conversion.MethodTypeConverter">
            <summary>
            Converter which will convert from one type to another via a static method
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.MethodTypeConverter.Method">
            <summary>
            The method used to perform the conversion
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.MethodTypeConverter.Description">
            <summary>
            The description text of this converter
            </summary>
        </member>
        <member name="M:Nucleus.Conversion.MethodTypeConverter.#ctor(System.Reflection.MethodInfo)">
            <summary>
            Constructor creating a new MethodTypeConverter by specifying the method to use
            </summary>
        </member>
        <member name="M:Nucleus.Conversion.MethodTypeConverter.Convert(System.Object)">
            <summary>
            Apply the conversion by calling the method
            </summary>
            <param name="fromObject"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Conversion.PropertyMapping">
            <summary>
            A record that describes a mapping from one property to another, possibly via a converter function
            </summary>
        </member>
        <member name="F:Nucleus.Conversion.PropertyMapping._PathA">
            <summary>
            Private backing field for PathA property
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.PropertyMapping.PathA">
            <summary>
            The path of the property on type A
            </summary>
        </member>
        <member name="F:Nucleus.Conversion.PropertyMapping._PathB">
            <summary>
            Private backing field for PathB property
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.PropertyMapping.PathB">
            <summary>
            The path of the property of type B
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.PropertyMapping.Direction">
            <summary>
            The direction of this mapping.
            Default is 'both'.
            </summary>
        </member>
        <member name="M:Nucleus.Conversion.PropertyMapping.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Conversion.PropertyMapping.#ctor(System.String,System.String)">
            <summary>
            Path constructor
            </summary>
            <param name="pathA"></param>
            <param name="pathB"></param>
        </member>
        <member name="M:Nucleus.Conversion.PropertyMapping.#ctor(System.String,System.String,Nucleus.Conversion.ConversionDirection)">
            <summary>
            Path and direction constructor
            </summary>
            <param name="pathA"></param>
            <param name="pathB"></param>
            <param name="direction"></param>
        </member>
        <member name="M:Nucleus.Conversion.PropertyMapping.ApplyAtoB(System.Object,System.Object)">
            <summary>
            Apply this property mapping to transfer data
            between object a and object b
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:Nucleus.Conversion.PropertyMapping.ApplyBtoA(System.Object,System.Object)">
            <summary>
            Apply this property mapping to transfer data
            between object b and object a
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:Nucleus.Conversion.PropertyMapping.GetPathEnd(System.Object,System.String[])">
            <summary>
            Get the penultimate value in a property path chain -
            i.e. the one that the property the path leads to must be gotten or set on
            </summary>
            <param name="startObject"></param>
            <param name="pathTokens"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Conversion.PropertyMapping.Invert">
            <summary>
            Obtain an inverted copy of this property mapping
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Conversion.MappingTypeConverter">
            <summary>
            Converter which provides a customisable property mapping from one type to another
            </summary>
        </member>
        <member name="F:Nucleus.Conversion.MappingTypeConverter._TypeA">
            <summary>
            Private backing member variable for TypeA property
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.MappingTypeConverter.TypeA">
            <summary>
            The first type to map to/from
            </summary>
        </member>
        <member name="F:Nucleus.Conversion.MappingTypeConverter._TypeB">
            <summary>
            Private backing member variable for TypeB property
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.MappingTypeConverter.TypeB">
            <summary>
            The second type to map to/from
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.MappingTypeConverter.PropertyMap">
            <summary>
            The collection of property mappings that describe how the properties of one type should be converted into another
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.MappingTypeConverter.Description">
            <summary>
            Description implementation
            </summary>
        </member>
        <member name="T:Nucleus.Conversion.ConversionLibrary">
            <summary>
            A library of converter routines to take one type of data and convert
            it into another as closely as possible.
            </summary>
        </member>
        <member name="P:Nucleus.Conversion.ConversionLibrary.LoadedConverters">
            <summary>
            The dictionary of conversion methods loaded from converters.
            Keyed by source type, then by target type.
            </summary>
        </member>
        <member name="M:Nucleus.Conversion.ConversionLibrary.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Conversion.ConversionLibrary.#ctor(System.Reflection.Assembly)">
            <summary>
            Initialises a new ConversionLibrary, loading in converters from a specified assembly
            </summary>
            <param name="converterAssembly"></param>
        </member>
        <member name="M:Nucleus.Conversion.ConversionLibrary.LoadConverters(System.Reflection.Assembly)">
            <summary>
            Load all classes containing conversion routines from the specified assembly 
            into the library
            </summary>
            <param name="converterAssembly"></param>
        </member>
        <member name="M:Nucleus.Conversion.ConversionLibrary.LoadConverters(System.Type)">
            <summary>
            Load a class containing conversion routines into the library
            </summary>
            <param name="converterClass"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Conversion.ConversionLibrary.Convert(System.Object,System.Type)">
            <summary>
            Convert the specified object to the specified type, using a previously loaded
            converter.
            </summary>
            <param name="sourceObject"></param>
            <param name="toType"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Conversion.ConversionLibrary.AllSuitableConverters(System.Type,System.Type)">
            <summary>
            Find all loaded converters that could conceivably be applied to the given pair of types
            </summary>
            <param name="fromType">The type to convert from</param>
            <param name="toType">The type of convert to</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.DDTree.MeshFaceDDTree.RayTrace(Nucleus.Geometry.Axis)">
            <summary>
            Trace a ray through this tree, testing for intersections with item geometry.
            Returns information about the first intersection encountered.
            </summary>
            <param name="ray">The ray to test</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.DDTree.RayHit`1">
            <summary>
            Class to store the result of a ray hit test
            </summary>
        </member>
        <member name="F:Nucleus.DDTree.RayHit`1._Item">
            <summary>
            Private backing field for Item property
            </summary>
        </member>
        <member name="P:Nucleus.DDTree.RayHit`1.Item">
            <summary>
            The item hit by the ray
            </summary>
        </member>
        <member name="F:Nucleus.DDTree.RayHit`1._Parameter">
            <summary>
            Private backing field for Parameter property
            </summary>
        </member>
        <member name="P:Nucleus.DDTree.RayHit`1.Parameter">
            <summary>
            The ray intersection parameter - the multiplication factor
            to be applied to the ray direction vector from the ray origin
            vector in order to find the intersection point
            </summary>
        </member>
        <member name="M:Nucleus.DDTree.RayHit`1.#ctor(`0,System.Double)">
            <summary>
            Initialise a RayHit result
            </summary>
            <param name="item"></param>
            <param name="parameter"></param>
        </member>
        <member name="T:Nucleus.DDTree.PositionDDTree`1">
            <summary>
            A DDTree adapted to store and access objects with no dimension 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Nucleus.DDTree.VertexDDTree">
            <summary>
            A divided dimension tree to store geometry vertices
            </summary>
        </member>
        <member name="M:Nucleus.DDTree.NodeDDTree.MinXOf(Nucleus.Model.Node)">
            <summary>
            Find the minimum bounding X-coordinate of the given entry in the tree.
            Should be overridden to deal with the specific tree type.
            </summary>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.DDTree.NodeDDTree.MaxXOf(Nucleus.Model.Node)">
            <summary>
            Find the maximum bounding X-coordinate of the given entry in the tree.
            Should be overridden to deal with the specific tree type.
            </summary>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.DDTree.NodeDDTree.MinYOf(Nucleus.Model.Node)">
            <summary>
            Find the minimum bounding Y-coordinate of the given entry in the tree.
            Should be overridden to deal with the specific tree type.
            </summary>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.DDTree.NodeDDTree.MaxYOf(Nucleus.Model.Node)">
            <summary>
            Find the maximum bounding Y-coordinate of the given entry in the tree.
            Should be overridden to deal with the specific tree type.
            </summary>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.DDTree.NodeDDTree.MinZOf(Nucleus.Model.Node)">
            <summary>
            Find the minimum bounding Z-coordinate of the given entry in the tree.
            Should be overridden to deal with the specific tree type.
            </summary>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.DDTree.NodeDDTree.MaxZOf(Nucleus.Model.Node)">
            <summary>
            Find the maximum bounding Z-coordinate of the given entry in the tree.
            Should be overridden to deal with the specific tree type.
            </summary>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.DDTree.NodeDDTree.DistanceSquaredBetween(Nucleus.Geometry.Vector,Nucleus.Model.Node)">
            <summary>
            Returns the minumum squared distance between the specified position in 3D-space and the given entry in the tree.
            Should be overridden to deal with the specific tree type.
            </summary>
            <param name="pt"></param>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.DDTree.NodeDDTree.PositionInDimension(Nucleus.Geometry.CoordinateAxis,Nucleus.Model.Node)">
            <summary>
            Get the nominal position of the specified entry in the tree the specified dimensional axis.
            Should be overridden to deal with the specific tree type
            </summary>
            <param name="dimension"></param>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.DDTree.NodeDDTree.CoincidentNodes(Nucleus.Model.NodeCollection,System.Double)">
            <summary>
            Find all nodes coincident to the specified set of nodes within this tree,
            within the specified tolerance.
            </summary>
            <param name="nodes"></param>
            <param name="tolerance"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.DDTree.DDTree`1">
            <summary>
            The abstract base class for Divided-Dimension Trees.
            This data structure works a lot like a binary partition tree only instead of
            branching in two each time, each level of the D-D tree is subdivided into a number
            of evenly-sized partitions.  This allows for much faster spatial indexing in cases where
            objects are reasonably evenly distributed throughout a particular region of space.
            To implement a tree to hold a particular type of object, this class should be extended
            and the abstract functions overridden to deal with that type.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Nucleus.DDTree.DDTree`1._RootNode">
            <summary>
            The root node of the tree
            </summary>
        </member>
        <member name="P:Nucleus.DDTree.DDTree`1.MaxDivisions">
            <summary>
            The maximum allowable number of divisions per tree
            </summary>
        </member>
        <member name="P:Nucleus.DDTree.DDTree`1.MinCellSize">
            <summary>
            The minimum allowable cell size
            </summary>
        </member>
        <member name="P:Nucleus.DDTree.DDTree`1.MaxLeafPopulation">
            <summary>
            The requested maximum number of objects per leaf node.
            If newly added objects increase the object count beyond this, the node will automatically subdivide.
            Note that the MinCellSize limit may mean that some nodes will contain more than this number.
            </summary>
        </member>
        <member name="M:Nucleus.DDTree.DDTree`1.#ctor(System.Collections.Generic.IList{`0},System.Int32,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="items"></param>
            <param name="maxDivisions"></param>
            <param name="minCellSize"></param>
        </member>
        <member name="M:Nucleus.DDTree.DDTree`1.NearestTo(Nucleus.Geometry.Vector,System.Double,`0)">
            <summary>
            Find the closest item in the tree to the specified point within the specified maximum distance
            </summary>
            <param name="pt">The point to search from</param>
            <param name="maxDistance">The maximum distance</param>
            <param name="ignore">Optional.  A value in the tree which is to be ignored.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.DDTree.DDTree`1.ItemsInside(Nucleus.Geometry.BoundingBox,System.Collections.Generic.IList{`0}@)">
            <summary>
            Find all items within the specified bounding box
            </summary>
            <param name="box">The bounding box to check</param>
            <param name="items">A collection to be populated with the items inside the box</param>
        </member>
        <member name="M:Nucleus.DDTree.DDTree`1.CloseTo(Nucleus.Geometry.Vector,System.Double,System.Collections.Generic.IList{`0}@)">
            <summary>
            Find all items within the specified distance from the given point
            </summary>
            <param name="pt">The point to check distance to</param>
            <param name="maxDistance">The maximum distance within which items will be included</param>
            <param name="output">A collection to be populated with all the items close to the specified point</param>
        </member>
        <member name="M:Nucleus.DDTree.DDTree`1.RayTrace(Nucleus.Geometry.Axis,System.Func{`0,Nucleus.Geometry.Axis,System.Double})">
            <summary>
            Trace a ray through this tree, testing for intersections with item geometry.
            Returns information about the first intersection encountered.
            </summary>
            <param name="ray">The ray to test</param>
            <param name="hitTest">A delegate function to determine whether an item in the
            tree has been hit by the ray.  Should take in the object and ray as parameters
            and return the ray intersection parameter on a hit or double.NaN on a miss.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.DDTree.DDTree`1.RayTrace(Nucleus.Geometry.Axis,System.Func{`0,Nucleus.Geometry.Axis,System.Double},System.Double)">
            <summary>
            Trace a ray through this tree, testing for intersections with item geometry.
            Returns information about the first intersection encountered.
            </summary>
            <param name="ray">The ray to test</param>
            <param name="hitTest">A delegate function to determine whether an item in the
            tree has been hit by the ray.  Should take in the object and ray as parameters
            and return the ray intersection parameter on a hit or double.NaN on a miss.</param>
            <param name="maxRange">The maximum range of the ray.  Beyond this range hits will
            be ignored.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.DDTree.DDTree`1.Add(`0)">
            <summary>
            Add an item to the tree
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Nucleus.DDTree.DDTree`1.Remove(`0)">
            <summary>
            Remove an item from the tree
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Nucleus.DDTree.DDTree`1.MinXOf(`0)">
            <summary>
            Find the minimum bounding X-coordinate of the given entry in the tree.
            Should be overridden to deal with the specific tree type.
            </summary>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.DDTree.DDTree`1.MaxXOf(`0)">
            <summary>
            Find the maximum bounding X-coordinate of the given entry in the tree.
            Should be overridden to deal with the specific tree type.
            </summary>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.DDTree.DDTree`1.MinYOf(`0)">
            <summary>
            Find the minimum bounding Y-coordinate of the given entry in the tree.
            Should be overridden to deal with the specific tree type.
            </summary>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.DDTree.DDTree`1.MaxYOf(`0)">
            <summary>
            Find the maximum bounding Y-coordinate of the given entry in the tree.
            Should be overridden to deal with the specific tree type.
            </summary>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.DDTree.DDTree`1.MinZOf(`0)">
            <summary>
            Find the minimum bounding Z-coordinate of the given entry in the tree.
            Should be overridden to deal with the specific tree type.
            </summary>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.DDTree.DDTree`1.MaxZOf(`0)">
            <summary>
            Find the maximum bounding Z-coordinate of the given entry in the tree.
            Should be overridden to deal with the specific tree type.
            </summary>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.DDTree.DDTree`1.DistanceSquaredBetween(Nucleus.Geometry.Vector,`0)">
            <summary>
            Returns the minumum squared distance between the specified position in 3D-space and the given entry in the tree.
            Should be overridden to deal with the specific tree type.
            </summary>
            <param name="pt"></param>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.DDTree.DDTree`1.PositionInDimension(Nucleus.Geometry.CoordinateAxis,`0)">
            <summary>
            Get the nominal position of the specified entry in the tree the specified dimensional axis.
            Should be overridden to deal with the specific tree type
            </summary>
            <param name="dimension"></param>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.DDTree.DDTree`1.PositionInDimension(Nucleus.Geometry.CoordinateAxis,Nucleus.Geometry.Vector)">
            <summary>
            Get the position of the specified point along the specified dimension's axis
            </summary>
            <param name="dimension"></param>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.DDTree.DDTree`1.MinInDimension(Nucleus.Geometry.CoordinateAxis,`0)">
            <summary>
            Find the minimum position of the specified entry in the tree in the
            specified axis
            </summary>
            <param name="dimension"></param>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.DDTree.DDTree`1.MaxInDimension(Nucleus.Geometry.CoordinateAxis,`0)">
            <summary>
            Find the maximum position of the specified entry in the tree in the
            specified axis
            </summary>
            <param name="dimension"></param>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.DDTree.DDTree`1.CanReturn(`0)">
            <summary>
            Overridable function which allows filtering of results for
            certain sub-types.  Returns true if the specified item
            is a valid result from tree search operations, false if
            it is not (if, for example, it is marked as deleted)
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.DDTree.DDTreeNode`1">
            <summary>
            A node in a D-D Tree
            </summary>
            <typeparam name="T">The type of object contained by the tree</typeparam>
        </member>
        <member name="P:Nucleus.DDTree.DDTreeNode`1.Children">
            <summary>
            The child objects of this node
            </summary>
        </member>
        <member name="F:Nucleus.DDTree.DDTreeNode`1._SplitDimension">
            <summary>
            The dimensional axis along which the space in this node is divided.
            If this is Undefined, the node is not split.
            </summary>
        </member>
        <member name="P:Nucleus.DDTree.DDTreeNode`1.IsLeafNode">
            <summary>
            Is this node a leaf node (i.e. is it not divided)
            </summary>
        </member>
        <member name="M:Nucleus.DDTree.DDTreeNode`1.#ctor(Nucleus.DDTree.DDTree{`0})">
            <summary>
            Constructor
            </summary>
            <param name="tree"></param>
        </member>
        <member name="M:Nucleus.DDTree.DDTreeNode`1.Add(`0,System.Boolean)">
            <summary>
            Add a new item to this node
            </summary>
            <param name="item"></param>
            <param name="autoSubdivide">If true, the node will automatically
            subdivide when the maximum leaf population is exceeded.</param>
        </member>
        <member name="M:Nucleus.DDTree.DDTreeNode`1.AddToBranch(`0,System.Boolean)">
            <summary>
            Add an item to a branch node of this node
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Nucleus.DDTree.DDTreeNode`1.Remove(`0)">
            <summary>
            Remove an item from this node and all branch nodes that contain it
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Nucleus.DDTree.DDTreeNode`1.Contains(`0)">
            <summary>
            Determine whether this node contains a specified child value
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.DDTree.DDTreeNode`1.CloseTo(Nucleus.Geometry.Vector,System.Double,System.Collections.Generic.IList{`0}@)">
            <summary>
            Find all items within the given distance from the given point
            </summary>
            <param name="pt"></param>
            <param name="distanceSquared"></param>
            <param name="output"></param>
        </member>
        <member name="M:Nucleus.DDTree.DDTreeNode`1.NearestTo(Nucleus.Geometry.Vector,System.Double@,`0)">
            <summary>
            Find the closest object to the specified point within the specified distance
            </summary>
            <param name="pt"></param>
            <param name="distanceSquared"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.DDTree.DDTreeNode`1.LargestDimension(System.Collections.Generic.IList{`0},System.Double@,System.Double@)">
            <summary>
            Find the largest dimensional axis in the specified collection of objects
            </summary>
            <param name="collection"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.DDTree.DDTreeNode`1.Subdivide">
            <summary>
            Subdivide this node along the principal axis of its child objects
            </summary>
        </member>
        <member name="M:Nucleus.DDTree.DDTreeNode`1.Swap(System.Double@,System.Double@)">
            <summary>
            Swap the values of two doubles
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:Nucleus.DDTree.DDTreeNode`1.RayTrace(Nucleus.Geometry.Axis,System.Func{`0,Nucleus.Geometry.Axis,System.Double},System.Double,System.Double)">
            <summary>
            Trace a ray through this node and its children searching for intersections with object geometry.
            </summary>
            <param name="ray">The ray to test</param>
            <param name="hitTest">A method delegate which tests for intersections between an item in the tree and a ray
            and returns the ray parameter of intersection (if any)</param>
            <param name="tStart">A clipping value at the start of the section of the ray in which to test for collisions</param>
            <param name="tEnd">A clipping parameter at the end of the section of the ray in which to test for collisions</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.IO.CSVReader">
            <summary>
            A class to help read CSV files
            </summary>
        </member>
        <member name="P:Nucleus.IO.CSVReader.Delimiter">
            <summary>
            The delimiting character.  By default, this is a comma.
            </summary>
        </member>
        <member name="M:Nucleus.IO.CSVReader.ReadToLists(Nucleus.Base.FilePath)">
            <summary>
            Read the CSV file at the specified location to a list of lists of strings
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.CSVReader.ReadToLists(System.IO.Stream)">
            <summary>
            Read the CSV stream to a list of lists of strings
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.CSVReader.ReadToLists(System.IO.TextReader)">
            <summary>
            Read CSV-format data from a TextReader to a list of lists of strings
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.IO.CustomSerializationBinder">
            <summary>
            A customised serialisation binder to enable backwards compatibility with
            files saved from versions of the library prior to the rename.
            </summary>
        </member>
        <member name="T:Nucleus.IO.IApplicationClient">
            <summary>
            Interface for classes which control an external application and provide access to the
            file handling functionality of that application.
            </summary>
        </member>
        <member name="M:Nucleus.IO.IApplicationClient.Open(Nucleus.Base.FilePath)">
            <summary>
            Open the file at the specified filepath in the target application
            </summary>
            <param name="filePath">The filepath to open.  (Note that this can be expressed as a string)</param>
            <returns>True if the specified file could be opened, false if this was prevented in some way.</returns>
        </member>
        <member name="M:Nucleus.IO.IApplicationClient.New">
            <summary>
            Open a new file in the target application
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.IApplicationClient.Save(Nucleus.Base.FilePath)">
            <summary>
            Save the currently open file to the specified file location
            </summary>
            <param name="filePath">The filepath to save to</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.IApplicationClient.Close">
            <summary>
            Close the currently open file in the target application
            </summary>
        </member>
        <member name="T:Nucleus.IO.TokenReader">
            <summary>
            A TokenReader is a utility class that helps with tokenising and reading
            out strings sequentially.
            </summary>
        </member>
        <member name="F:Nucleus.IO.TokenReader._Tokens">
            <summary>
            Private backing field for Tokens property
            </summary>
        </member>
        <member name="P:Nucleus.IO.TokenReader.Tokens">
            <summary>
            The full set of tokens in the string
            </summary>
        </member>
        <member name="F:Nucleus.IO.TokenReader._Index">
            <summary>
            Private backing field for Index property
            </summary>
        </member>
        <member name="P:Nucleus.IO.TokenReader.Index">
            <summary>
            The index of the next token
            </summary>
        </member>
        <member name="P:Nucleus.IO.TokenReader.Item(System.Int32)">
            <summary>
            Get the token at the specified position in the
            tokenised string.  Accessing this will not modify the
            current position of the reader.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.TokenReader.#ctor(System.String)">
            <summary>
            Initialise a new TokenReader set up to tokenise and read the
            specified string, using the default of a tab character as a delimiter
            </summary>
            <param name="str"></param>
        </member>
        <member name="M:Nucleus.IO.TokenReader.#ctor(System.String,System.Char[])">
            <summary>
            Initialise a new TokenReader set up to tokenise and read the
            specified string
            </summary>
            <param name="str"></param>
            <param name="separator"></param>
        </member>
        <member name="M:Nucleus.IO.TokenReader.PeekNext">
            <summary>
            Get the next token, without advancing the position of the
            reader.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.TokenReader.Next">
            <summary>
            Get the next token.  The position of the reader will
            then move along to the next token, such that repeated calls
            to Next() will return each token in sequence.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.TokenReader.NextDouble">
            <summary>
            Get the next token, parsed to a double.  The position of the reader will
            then move along to the next token, such that repeated calls
            to Next___() will return each token in sequence.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.TokenReader.NextInt">
            <summary>
            Get the next token, parsed to an integer.  The position of the reader will
            then move along to the next token, such that repeated calls
            to Next___() will return each token in sequence.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.TokenReader.NextBool">
            <summary>
            Get the next token, parsed to a boolean.  The position of the reader will
            then move along to the next token, such that repeated calls
            to Next___() will return each token in sequence.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.TokenReader.Next3AsVector">
            <summary>
            Read the next three tokens and parse them as a 
            Vector's X, Y and Z coordinates.
            The position of the reader will
            then move along to the next token after these, such that repeated calls
            to Next___() will return each token in sequence.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.TokenReader.Next6AsSixVector">
            <summary>
            Read the next six tokens and parse them as a 
            Six-vector's X, Y, Z, XX, YY and ZZ coordinates.
            The position of the reader will
            then move along to the next token after these, such that repeated calls
            to Next___() will return each token in sequence.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.TokenReader.Next6AsBool6D(System.String)">
            <summary>
            Read the next six tokens and parse them as a 
            Bool6D's X, Y, Z, XX, YY and ZZ boolean values.
            The position of the reader will
            then move along to the next token after these, such that repeated calls
            to Next___() will return each token in sequence.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.TokenReader.NextIs(System.String)">
            <summary>
            Is the next string equal to the specified value (ignoring case)?
            The position of the reader will
            then move along to the next token, such that repeated calls
            to Next___() will return each token in sequence.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.TokenReader.First">
            <summary>
            Get the first token in the string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.TokenReader.Last">
            <summary>
            Get the last token in the string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.TokenReader.Skip(System.Int32)">
            <summary>
            Skip the specified number of tokens
            </summary>
            <param name="number"></param>
        </member>
        <member name="M:Nucleus.IO.TokenReader.AtEnd">
            <summary>
            Has the TokenReader reached the end of the string?
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.IO.TypeFieldsFormat">
            <summary>
            A record of a type's aliases and fields to be used during
            serialisation and deserialisation
            </summary>
        </member>
        <member name="P:Nucleus.IO.TypeFieldsFormat.Alias">
            <summary>
            The alias of the type
            </summary>
        </member>
        <member name="P:Nucleus.IO.TypeFieldsFormat.Type">
            <summary>
            The type
            </summary>
        </member>
        <member name="P:Nucleus.IO.TypeFieldsFormat.Fields">
            <summary>
            The type's serializable fields, in order of storage
            </summary>
        </member>
        <member name="M:Nucleus.IO.TypeFieldsFormat.#ctor(System.String,System.Type,System.Collections.Generic.IList{System.Reflection.FieldInfo})">
            <summary>
            Initialise a new type fields' format record
            </summary>
            <param name="type"></param>
            <param name="fields"></param>
        </member>
        <member name="M:Nucleus.IO.TypeFieldsFormat.FilterField(System.Reflection.FieldInfo)">
            <summary>
            Determine whether or not the specified field is suitable
            </summary>
            <param name="fI"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.IO.UniqueFormatter">
            <summary>
            A custom serialisation class which maintains IUnique-implementing objects as unique objects which
            may be referenced by others and inlines everything else.  The data format is kept malleable and forwards-compatible
            by being recorded within the file itself.
            </summary>
        </member>
        <member name="F:Nucleus.IO.UniqueFormatter.OPEN_DATABLOCK">
            <summary> Character used to denote the opening of a block of data </summary>
        </member>
        <member name="F:Nucleus.IO.UniqueFormatter.CLOSE_DATABLOCK">
            <summary> Character used to denote the closing of a block of data </summary>
        </member>
        <member name="F:Nucleus.IO.UniqueFormatter.SEPARATOR">
            <summary> Character used to separate fields and items in a block of data </summary>
        </member>
        <member name="F:Nucleus.IO.UniqueFormatter.KEY_SEPARATOR">
            <summary> Character used to separate key-value pairs in a block of data </summary>
        </member>
        <member name="F:Nucleus.IO.UniqueFormatter.FORMAT">
            <summary> String that denotes the start of format definition </summary>
        </member>
        <member name="F:Nucleus.IO.UniqueFormatter.DATA">
            <summary> String that denotes the start of data records </summary>
        </member>
        <member name="F:Nucleus.IO.UniqueFormatter._Format">
            <summary>
            The type alias:format dictionary
            </summary>
        </member>
        <member name="F:Nucleus.IO.UniqueFormatter._Aliases">
            <summary>
            The dictionar of type aliases
            </summary>
        </member>
        <member name="F:Nucleus.IO.UniqueFormatter._Uniques">
            <summary>
            The list of Unique objects to be written or reconstructed
            </summary>
        </member>
        <member name="F:Nucleus.IO.UniqueFormatter._Writer">
            <summary>
            The stream writer
            </summary>
        </member>
        <member name="F:Nucleus.IO.UniqueFormatter._Reader">
            <summary>
            The stream reader
            </summary>
        </member>
        <member name="M:Nucleus.IO.UniqueFormatter.WriteValue(System.Object,System.Text.StringBuilder)">
            <summary>
            Write 
            </summary>
            <param name="value"></param>
            <param name="sb"></param>
        </member>
        <member name="M:Nucleus.IO.UniqueFormatter.SerializeItem(Nucleus.Base.IUnique)">
            <summary>
            Serialize a unique item to a string
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.UniqueFormatter.SerializeType(System.Type)">
            <summary>
            Get the alias of the specified type, writing the type format description
            to the stream if it has not already been done for this type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.UniqueFormatter.ToFormatDescription(Nucleus.IO.TypeFieldsFormat)">
            <summary>
            Construct a format descriptor from a type name and a list of serialisable fields
            </summary>
            <param name="typeName">The type's FullName</param>
            <param name="fields">all fields of the type which are to be serialized</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.UniqueFormatter.GenerateFormatDescription">
            <summary>
            Generate the block of text that describes the data formats described within
            the document
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.UniqueFormatter.ReadFormat(System.String,Nucleus.Alerts.AlertLog)">
            <summary>
            Parse a line of text as a data format
            </summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.UniqueFormatter.ReadRecord">
            <summary>
            Read a record string, which consists of a prefix,
            an OPEN_DATABLOCK character, some sub-records and a 
            matching CLOSE_DATABLOCK character.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.UniqueFormatter.String2Object(System.String,System.Type)">
            <summary>
            Convert from a string to an object of the specified type,
            where for 
            </summary>
            <param name="str"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.IO.CSVParser`1">
            <summary>
            A class to parse CSV data and generate objects based upon it
            </summary>
            <typeparam name="TBase">The base type of the data to be constructed</typeparam>
        </member>
        <member name="F:Nucleus.IO.CSVParser`1._CurrentType">
            <summary>
            The current type to be created
            </summary>
        </member>
        <member name="F:Nucleus.IO.CSVParser`1._SubTypes">
            <summary>
            The dictionary of sub-types for the base type of object this parser generates
            </summary>
        </member>
        <member name="P:Nucleus.IO.CSVParser`1.Columns">
            <summary>
            The map of columns to object properties
            </summary>
        </member>
        <member name="M:Nucleus.IO.CSVParser`1.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.IO.CSVParser`1.Parse(Nucleus.Base.FilePath)">
            <summary>
            Parse CSV-format data from a file
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.CSVParser`1.Parse(System.IO.Stream)">
            <summary>
            Parse CSV-format data from a stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.CSVParser`1.Parse(System.String)">
            <summary>
            Parse CSV-format data in a string
            </summary>
            <param name="csvString"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.CSVParser`1.Parse(System.IO.TextReader)">
            <summary>
            Parse CSV-format data from a TextReader
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.CSVParser`1.ParseLine(System.String)">
            <summary>
            Parse a CSV line.  May do one of three things:
            - Set the object type (if only one entry and of a valid type)
            - Set the column properties (if not previously set)
            - Create a new object with the specified properties
            </summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.IO.DocumentTextSerialiser`1">
            <summary>
            Base class for text serialisers that write out documents
            </summary>
            <typeparam name="TSource"></typeparam>
        </member>
        <member name="F:Nucleus.IO.DocumentTextSerialiser`1._CustomHeader">
            <summary>
            Private backing field for CustomHeader property
            </summary>
        </member>
        <member name="P:Nucleus.IO.DocumentTextSerialiser`1.CustomHeader">
            <summary>
            Get or set a custom header to be written before the main body of text.
            Can be used to include customised titles, extra header data etc.
            If null will be ignored.
            </summary>
        </member>
        <member name="F:Nucleus.IO.DocumentTextSerialiser`1._CustomFooter">
            <summary>
            Private backing field for CustomFooter property
            </summary>
        </member>
        <member name="P:Nucleus.IO.DocumentTextSerialiser`1.CustomFooter">
            <summary>
            Get or set a custom footer to be written after the main body of text.
            Can be used to include additional data, closing tags, footer comments etc.
            If null will be ignored.
            </summary>
        </member>
        <member name="M:Nucleus.IO.DocumentTextSerialiser`1.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.IO.DocumentTextSerialiser`1.#ctor(Nucleus.IO.TextFormat,Nucleus.Conversion.IStringConversionContext)">
            <summary>
            Format constructor
            </summary>
            <param name="format"></param>
        </member>
        <member name="T:Nucleus.IO.GWAContext">
            <summary>
            Contextual operations involved with writing out a GWA-format file
            </summary>
        </member>
        <member name="F:Nucleus.IO.GWAContext._NextID">
            <summary>
            The dictionary of IDs for various types
            </summary>
        </member>
        <member name="P:Nucleus.IO.GWAContext.IDMap">
            <summary>
            The ID mapping table
            </summary>
            <remarks>
            Currently, this does not categorise the items, meaning it's not usable to map back again...
            </remarks>
        </member>
        <member name="M:Nucleus.IO.GWAContext.GetNextIDFor(System.Object)">
            <summary>
            Get the next available GSA ID for the specified object.
            Will increment the stored next available ID for the relevant type.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.GWAContext.HasMeshRepresentation">
            <summary>
            Test whether a PanelElement source object has a representation
            that can be written out as a mesh
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.GWAContext.ToInt">
            <summary>
            Convert to integer
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.GWAContext.ElementType">
            <summary>
            Get the element type of the current element object
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.GWAContext.ElementTopo">
            <summary>
            Get a node topology description for the current sub-element
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.GWAContext.ToReleaseString">
            <summary>
            Convert a Bool6D to a GWA release description
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.GWAContext.PointLoadPosition">
            <summary>
            Get a point load position in GWA form (-ve if relative)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.GWAContext.CurrentPanelFace">
            <summary>
            Get the current sub-component mesh face of the current panel element
            source object
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.GWAContext.ElementGroup">
            <summary>
            Get the group number of the current element object
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.GWAContext.FamilyMaterial">
            <summary>
            Get the description of the material of the current family object
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.GWAContext.ListDefinition">
            <summary>
            Convert a set to a GWA list definition
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.GWAContext.SectionDescription">
            <summary>
            Get a GSA section description of the current object
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.GWAContext.GetID">
            <summary>
            Get the GSA ID of the specified object
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.GWAContext.GetID(System.Object,System.Int32)">
            <summary>
            Get the GSA ID of the specified object
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.IO.ModelDocumentTextSerialiser">
            <summary>
            Serialisation class that can write out a model document to text using a defined
            format.
            </summary>
        </member>
        <member name="M:Nucleus.IO.ModelDocumentTextSerialiser.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.IO.ModelDocumentTextSerialiser.#ctor(Nucleus.IO.TextFormat,Nucleus.Conversion.IStringConversionContext)">
            <summary>
            Format constructor
            </summary>
            <param name="format"></param>
        </member>
        <member name="T:Nucleus.IO.TextFormat">
            <summary>
            Data about the format various types should be serialised to.
            For use with TextSerialiser
            </summary>
        </member>
        <member name="F:Nucleus.IO.TextFormat.CONTEXT">
            <summary>
            The symbol used within text formats to denote a step-out to the
            current context
            </summary>
        </member>
        <member name="F:Nucleus.IO.TextFormat.IF">
            <summary>
            The symbol used within text formats to denote the start of a conditional
            format
            </summary>
        </member>
        <member name="F:Nucleus.IO.TextFormat.THEN">
            <summary>
            The symbol used within text formats to close the condition of a conditional
            section of a format
            </summary>
        </member>
        <member name="F:Nucleus.IO.TextFormat._TYPE_START">
            <summary>
            The character sequence that denotes the start of a type name
            when loading this format from a file
            </summary>
        </member>
        <member name="M:Nucleus.IO.TextFormat.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.IO.TextFormat.#ctor(System.String)">
            <summary>
            Initialise a new TextFormat from the specified format data string
            </summary>
            <param name="format"></param>
        </member>
        <member name="M:Nucleus.IO.TextFormat.#ctor(Nucleus.Base.FilePath)">
            <summary>
            Initialise a new TextFormat, loading it from the specified filepath
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="M:Nucleus.IO.TextFormat.Save(Nucleus.Base.FilePath)">
            <summary>
            Write out this TextFormat to a text file
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="M:Nucleus.IO.TextFormat.Load(Nucleus.Base.FilePath)">
            <summary>
            Load type formats from a text file
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="M:Nucleus.IO.TextFormat.Load(System.String)">
            <summary>
            Load type formats from a string
            </summary>
            <param name="formatString"></param>
        </member>
        <member name="M:Nucleus.IO.TextFormat.Load(System.IO.TextReader)">
            <summary>
            Load the format via a text reader.
            </summary>
            <param name="reader"></param>
        </member>
        <member name="M:Nucleus.IO.TextFormat.FormatFor(System.Object)">
            <summary>
            Get the format string (if one exists) for the specified object
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.IO.TextSerialiser`1">
            <summary>
            Class that converts objects to text strings in a customisable format
            </summary>
        </member>
        <member name="F:Nucleus.IO.TextSerialiser`1._OutputBuilder">
            <summary>
            The string builder that is used to produce the output string
            </summary>
        </member>
        <member name="F:Nucleus.IO.TextSerialiser`1._Context">
            <summary>
            Private backing field for Context property
            </summary>
        </member>
        <member name="P:Nucleus.IO.TextSerialiser`1.Context">
            <summary>
            The context object for string conversion
            </summary>
        </member>
        <member name="F:Nucleus.IO.TextSerialiser`1._Format">
            <summary>
            Private backing field for Format property
            </summary>
        </member>
        <member name="P:Nucleus.IO.TextSerialiser`1.Format">
            <summary>
            The dictionary of format strings for different types
            </summary>
        </member>
        <member name="P:Nucleus.IO.TextSerialiser`1.Output">
            <summary>
            Get the string value of the current output
            </summary>
        </member>
        <member name="M:Nucleus.IO.TextSerialiser`1.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.IO.TextSerialiser`1.#ctor(Nucleus.IO.TextFormat,Nucleus.Conversion.IStringConversionContext)">
            <summary>
            Format constructor
            </summary>
            <param name="format"></param>
        </member>
        <member name="M:Nucleus.IO.TextSerialiser`1.SetFormat(System.Type,System.String)">
            <summary>
            Set the format for the specified type
            </summary>
            <param name="type"></param>
            <param name="format"></param>
        </member>
        <member name="M:Nucleus.IO.TextSerialiser`1.Write(System.String)">
            <summary>
            Write a line of text directly
            </summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.TextSerialiser`1.Write(System.Object)">
            <summary>
            Write a line of text representing an object, in the
            format pre-specified for that object's type.
            If no format is loaded for this object's type then it will be
            ignored.
            </summary>
            <param name="item">The item to be written.</param>
            <returns>True if successfully written, false if not.</returns>
        </member>
        <member name="M:Nucleus.IO.TextSerialiser`1.WriteAll(System.Collections.ICollection)">
            <summary>
            Write all items in the specified collection.
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.TextSerialiser`1.IsDeleted(System.Object)">
            <summary>
            Check whether the specified object is marked as deleted
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.TextSerialiser`1.WriteModel(Nucleus.Model.Model)">
            <summary>
            Write a model to text format
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.TextSerialiser`1.WriteAll(`0)">
            <summary>
            Write all data in the specified source object
            </summary>
            <param name="source">The source object to be written</param>
        </member>
        <member name="M:Nucleus.IO.TextSerialiser`1.Clear">
            <summary>
            Clear all stored output text
            </summary>
        </member>
        <member name="M:Nucleus.IO.TextSerialiser`1.Serialize(`0)">
            <summary>
            Serialise the specified source object to text using
            the currently specified string formats
            </summary>
            <param name="source">The source object to be serialized</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.IO.TextSerialiser`1.Serialize(System.IO.Stream,`0,System.String,System.String)">
            <summary>
            Serialise the specified source object to text and
            write it to the specified stream.
            </summary>
            <param name="stream">The stream to write to</param>
            <param name="source">The source object to serialise</param>
        </member>
        <member name="T:Nucleus.Maths.Fresnel">
            <summary>
            Static helper functions for fresnel integrals and other related algorithms
            </summary>
        </member>
        <member name="F:Nucleus.Maths.Fresnel._ROOTHALFPI">
            <summary>
            Constant precalculated value of √(PI/2)
            </summary>
        </member>
        <member name="F:Nucleus.Maths.Fresnel._ROOT2OVERPI">
            <summary>
            Constant precalculated value of √(2/PI)
            </summary>
        </member>
        <member name="F:Nucleus.Maths.Fresnel._EPSILON">
            <summary>
            Accuracy
            </summary>
        </member>
        <member name="M:Nucleus.Maths.Fresnel.S(System.Double)">
            <summary>
            The power series which approximates the solution
            to the fresnel sine integral defined as the integral
            of sin(t²)dt
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Fresnel.SPiOver2(System.Double)">
            <summary>
            The power series which approximates the solution
            to the fresnel sine integral defined as the integral
            of sin(π/2 * t²)dt
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Fresnel.C(System.Double)">
            <summary>
            The power series which approximates the solution
            to the fresnel cosine integral defined as the integral
            of cos(t²)dt
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Fresnel.CPiOver2(System.Double)">
            <summary>
            The power series which approximates the solution
            to the fresnel cosine integral defined as the integral
            of cos(π/2 * t²)dt
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Fresnel.F(System.Double)">
            <summary>
            The function f(X), defined as
            f(X) = (0.5 - S(X))cos(0.5π*X²) - (0.5 - C(X))*sin(0.5π*X²)
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Fresnel.G(System.Double)">
            <summary>
            The function g(X), defined as
            g(X) = (0.5 - C(X))cos(0.5π*X²) + (0.5 - C(X))*sin(0.5π*X²)
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Maths.INamedDataSetCollection">
            <summary>
            Interface for collections of NamedDataSets
            </summary>
        </member>
        <member name="M:Nucleus.Maths.INamedDataSetCollection.GetAllKeys">
            <summary>
            Get the complete set of unique keys in all datasets in this collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.INamedDataSetCollection.GetValueRanges">
            <summary>
            Get a NamedDataSet containing the keys and value ranges of all datasets
            in this collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.INamedDataSetCollection.GetEndValueRanges">
            <summary>
            Get a NamedDataSet containing the keys and end value ranges of all datasets
            in this collection
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Maths.IntInterval">
            <summary>
            A numeric interval between two integers
            </summary>
        </member>
        <member name="F:Nucleus.Maths.IntInterval.Start">
            <summary>
            The minimum, or start, value of this interval.
            </summary>
        </member>
        <member name="F:Nucleus.Maths.IntInterval.End">
            <summary>
            The maximum, or end, value of this interval.
            </summary>
        </member>
        <member name="P:Nucleus.Maths.IntInterval.Size">
            <summary>
            Get the size, or length, of this interval
            </summary>
        </member>
        <member name="P:Nucleus.Maths.IntInterval.IsIncreasing">
            <summary>
            Does this interval represent a range of values which increases from start to finish
            </summary>
        </member>
        <member name="P:Nucleus.Maths.IntInterval.IsDecreasing">
            <summary>
            Does this interval represent a range of
            </summary>
        </member>
        <member name="P:Nucleus.Maths.IntInterval.IsSingularity">
            <summary>
            Is this a singularity?  i.e. are the maximum and minimum values the same?
            </summary>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Maths.IntInterval.Min">
            <summary>
            Get the minimum value encompassed by this interval
            (This will be the lesser of the Start and End fields)
            </summary>
        </member>
        <member name="P:Nucleus.Maths.IntInterval.Max">
            <summary>
            Get the maximum value encompassed by this interval
            (This will be the greater of the Start and End fields)
            </summary>
        </member>
        <member name="P:Nucleus.Maths.IntInterval.AbsMax">
            <summary>
            Get the signed value of the greatest absolute value in this interval.
            This will return whichever of Max and Min has the largest (unsigned) magnitude.
            </summary>
        </member>
        <member name="M:Nucleus.Maths.IntInterval.#ctor(System.Int32)">
            <summary>
            Constructor creating a singularity interval with
            maximum and minimum set to the specified value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Nucleus.Maths.IntInterval.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor creating an interval from maximum and minimum values.
            The minimum value should be lower than or equal to the maximum, or else
            this interval will not be valid.
            </summary>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="M:Nucleus.Maths.IntInterval.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor creating an interval surrounding the specified set of 
            values.  The maximum and minimum will be automatically determined.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:Nucleus.Maths.IntInterval.#ctor(System.Int32[])">
            <summary>
            Constructor creating an interval surrounding the specified set of 
            values.  The maximum and minimum will be automatically determined
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:Nucleus.Maths.IntInterval.Random(System.Random)">
            <summary>
            Generate a random integer within this interval
            </summary>
            <param name="rng">The random number generator to use</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.IntInterval.WithEnd(System.Int32)">
            <summary>
            Create a new interval with the same start value as this one
            but with the new specified end value.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Maths.NamedDataSet">
            <summary>
            A set of named data to be displayed in a spider diagram
            </summary>
        </member>
        <member name="F:Nucleus.Maths.NamedDataSet._Data">
            <summary>
            Private backing field for Data property
            </summary>
        </member>
        <member name="P:Nucleus.Maths.NamedDataSet.Data">
            <summary>
            The data set
            </summary>
        </member>
        <member name="F:Nucleus.Maths.NamedDataSet._Colour">
            <summary>
            Private backing field for Colour property
            </summary>
        </member>
        <member name="P:Nucleus.Maths.NamedDataSet.Colour">
            <summary>
            The colour to use to display this dataset
            </summary>
        </member>
        <member name="M:Nucleus.Maths.NamedDataSet.#ctor">
            <summary>
            Parameterless constructor
            </summary>
        </member>
        <member name="M:Nucleus.Maths.NamedDataSet.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,Nucleus.Maths.Interval})">
            <summary>
            Instantiate a new DiagramData with the specified name and dataset.
            </summary>
            <param name="name"></param>
            <param name="data"></param>
        </member>
        <member name="M:Nucleus.Maths.NamedDataSet.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,Nucleus.Maths.Interval},Nucleus.Rendering.Colour)">
            <summary>
            Instantiate a new DiagramData with the specified name and dataset.
            </summary>
            <param name="name"></param>
            <param name="data"></param>
        </member>
        <member name="M:Nucleus.Maths.NamedDataSet.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.Double})">
            <summary>
            Instantiate a new DiagramData with the specified name and dataset.
            The double data values will be automatically converted to a Interval from
            0 to the specified value.
            </summary>
            <param name="name"></param>
            <param name="data"></param>
        </member>
        <member name="M:Nucleus.Maths.NamedDataSet.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.Double},Nucleus.Rendering.Colour)">
            <summary>
            Instantiate a new DiagramData with the specified name and dataset.
            The double data values will be automatically converted to a Interval from
            0 to the specified value.
            </summary>
            <param name="name"></param>
            <param name="data"></param>
        </member>
        <member name="M:Nucleus.Maths.NamedDataSet.#ctor(System.String)">
            <summary>
            Instantiate a new blank DiagramData with the specified name
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Nucleus.Maths.NamedDataSet.#ctor(System.String,Nucleus.Rendering.Colour)">
            <summary>
            Instantiate a new blank DiagramData with the specified name
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Nucleus.Maths.NamedDataSet.UnionAll(Nucleus.Maths.Interval)">
            <summary>
            Expand all data intervals within this data set to include the
            specified interval
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:Nucleus.Maths.NamedDataSetCollection`1">
            <summary>
            A collection of named data sets
            </summary>
        </member>
        <member name="M:Nucleus.Maths.NamedDataSetCollection`1.GetAllKeys">
            <summary>
            Get a combined list of all the key names in the data sets in this collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.NamedDataSetCollection`1.GetValueRanges">
            <summary>
            Get a NamedDataSet containing the keys and value ranges of all datasets
            in this collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.NamedDataSetCollection`1.GetEndValueRanges">
            <summary>
            Get a NamedDataSet containing the keys and value ranges of all datasets
            in this collection
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Maths.NamedDataSetCollection">
            <summary>
            A collection of named data sets
            </summary>
        </member>
        <member name="T:Nucleus.Maths.MathsHelper">
            <summary>
            Static maths helper functions
            </summary>
        </member>
        <member name="M:Nucleus.Maths.MathsHelper.AreaUnder(System.Double,System.Double,System.Double,System.Double,Nucleus.Geometry.Vector@)">
            <summary>
            Calculate the signed area 'under' the line segment between the two specified points
            on the XY plane - i.e. the area between the line and the X-axis.
            </summary>
            <param name="x0">The x-coordinate of the start of the line</param>
            <param name="y0">The y-coordinate of the start of the line</param>
            <param name="x1">The x-coordinate of the end of the line</param>
            <param name="y1">The y-coordinate of the end of the line</param>
            <param name="centroid">The cumulative centroid.  The centroid of the block under
            the line will be added to the value passed in here</param>
            <returns>The signed area as a double.</returns>
        </member>
        <member name="M:Nucleus.Maths.MathsHelper.IxxUnder(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Calculate the signed second moment of area 'under' the line segment between the
            two specified coordinates on the XY plane about the X-axis
            </summary>
            <param name="x0"></param>
            <param name="y0"></param>
            <param name="x1"></param>
            <param name="y1"></param>
            <returns>The signed Ixx as a double</returns>
        </member>
        <member name="M:Nucleus.Maths.LinearDoubleDataSet.#ctor">
            <summary>
            Initialise a new blank data set
            </summary>
        </member>
        <member name="M:Nucleus.Maths.LinearDoubleDataSet.#ctor(System.Collections.Generic.IList{System.Double})">
            <summary>
            Initialise a new data set containing the specified values.
            Each value will be plotted against it's index in the list
            </summary>
            <param name="values"></param>
        </member>
        <member name="M:Nucleus.Maths.LinearDoubleDataSet.#ctor(System.Double,System.Double)">
            <summary>
            Initialise a new data set containing the specified initial pairing
            of values
            </summary>
            <param name="firstKey"></param>
            <param name="firstValue"></param>
        </member>
        <member name="M:Nucleus.Maths.LinearDoubleDataSet.#ctor(System.Double)">
            <summary>
            Initialise a new data set containing the specified constant value between
            0 and 1.0.
            </summary>
            <param name="constantValue"></param>
        </member>
        <member name="M:Nucleus.Maths.LinearDoubleDataSet.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initialise a new data set containing the two specified initial pairings
            </summary>
            <param name="firstKey"></param>
            <param name="firstValue"></param>
            <param name="secondKey"></param>
            <param name="secondValue"></param>
        </member>
        <member name="M:Nucleus.Maths.LinearDoubleDataSet.ToIntervals">
            <summary>
            Convert this dataset of doubles to an equivalent one of Intervals
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.LinearDoubleDataSet.CalculateAreaUnder(Nucleus.Maths.Interval,Nucleus.Geometry.Vector@)">
            <summary>
            Calculate the signed area under the line, over the specified key range
            </summary>
            <param name="xRange">The range over which the area is to be calculated</param>
            <param name="centroid"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Maths.EvaluationContext">
            <summary>
            A standard evaluation context
            </summary>
        </member>
        <member name="F:Nucleus.Maths.EvaluationContext._Variables">
            <summary>
            Private backing field for Variables property
            </summary>
        </member>
        <member name="P:Nucleus.Maths.EvaluationContext.Variables">
            <summary>
            The set of stored named variables in the evaluation context
            </summary>
        </member>
        <member name="T:Nucleus.Maths.Expression">
            <summary>
            A mathematical equation which can be expressed as a string,
            parsed and evaluated to return a number
            </summary>
        </member>
        <member name="P:Nucleus.Maths.Expression.DefaultContext">
            <summary>
            The default global context which will be used when evaluating expressions
            in cases where a context is not specified.  By default this is null
            and is not used - it must be set specifically to a non-null value in order
            to come into use.
            </summary>
        </member>
        <member name="F:Nucleus.Maths.Expression._Description">
            <summary>
            Protected backing field for Description property
            </summary>
        </member>
        <member name="P:Nucleus.Maths.Expression.Description">
            <summary>
            The expression description string
            </summary>
        </member>
        <member name="M:Nucleus.Maths.Expression.Evaluate">
            <summary>
            Evaluate the expression and return the calculated value.
            The default context will be used.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Expression.Evaluate(Nucleus.Maths.IEvaluationContext)">
            <summary>
            Evaluate the expression and return the calculated value
            </summary>
            <param name="context">The evaluation context to use</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Expression.Evaluate``1(Nucleus.Maths.IEvaluationContext)">
            <summary>
            Evaluate the expression and return the calculated value of the
            specified type.  If the result is not already of the specified
            type then the default of that type will be returned.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Expression.ContainsReference(System.String)">
            <summary>
            Does this expression contain a reference to the specified variable?
            </summary>
            <param name="variableName"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Expression.Parse(System.String)">
            <summary>
            Parse a string description as an expression
            </summary>
            <param name="description"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Expression.FindNextOperator(System.String,System.String@,System.Boolean@,System.Boolean@)">
            <summary>
            Find the next operation to be performed (in reverse order).
            </summary>
            <param name="operatorOut"></param>
            <param name="dualOperand"></param>
            <param name="takeFirst"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Expression.op_Implicit(System.Double)~Nucleus.Maths.Expression">
            <summary>
            Convert a double value into an expression
            </summary>
            <param name="v"></param>
        </member>
        <member name="M:Nucleus.Maths.Expression.op_Implicit(Nucleus.Maths.Expression)~System.Double">
            <summary>
            Convert an expression to a double value
            </summary>
            <param name="v"></param>
        </member>
        <member name="M:Nucleus.Maths.Expression.op_Implicit(System.String)~Nucleus.Maths.Expression">
            <summary>
            Convert a string value into an expression
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:Nucleus.Maths.Expression.op_Implicit(Nucleus.Maths.Expression)~System.String">
            <summary>
            Convert an expression to a string
            </summary>
            <param name="v"></param>
        </member>
        <member name="T:Nucleus.Maths.ExpressionTypeConverter">
            <summary>
            Type converter for the expression class
            </summary>
        </member>
        <member name="T:Nucleus.Maths.GraphLineData">
            <summary>
            Wrapper for graph line data,
            used to present it in a graph
            </summary>
        </member>
        <member name="F:Nucleus.Maths.GraphLineData._Data">
            <summary>
            Private backing field for Data property
            </summary>
        </member>
        <member name="P:Nucleus.Maths.GraphLineData.Data">
            <summary>
            The line data
            </summary>
        </member>
        <member name="M:Nucleus.Maths.GraphLineData.#ctor(System.String,Nucleus.Maths.LinearIntervalDataSet)">
            <summary>
            Initialise a new GraphLineData
            </summary>
            <param name="name"></param>
            <param name="data"></param>
        </member>
        <member name="T:Nucleus.Maths.GraphLineDataCollection">
            <summary>
            A collection of line graph data
            </summary>
        </member>
        <member name="P:Nucleus.Maths.GraphLineDataCollection.KeyRange">
            <summary>
            Get the range of keys contained within this collection
            </summary>
        </member>
        <member name="P:Nucleus.Maths.GraphLineDataCollection.ValueRange">
            <summary>
            Get the range of values contained within this collection
            </summary>
        </member>
        <member name="T:Nucleus.Maths.IEvaluationContext">
            <summary>
            Interface for objects which provide an evaluation context for Expressions
            </summary>
        </member>
        <member name="M:Nucleus.Maths.IEvaluationContext.GetVariable(System.String)">
            <summary>
            Get the stored expression variable
            </summary>
            <param name="name">The name of the variable to retrieve</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.IEvaluationContext.SetVariable(System.String,Nucleus.Maths.Expression)">
            <summary>
            Set the stored expression variable with the given name
            </summary>
            <param name="name">The name of the variable to store</param>
            <param name="value">The expression to store</param>
        </member>
        <member name="T:Nucleus.Maths.LinearDataSet`1">
            <summary>
            An interpolatable data set of values along a single axis.
            </summary>
        </member>
        <member name="P:Nucleus.Maths.LinearDataSet`1.KeyRange">
            <summary>
            Get the range of key values currently stored in this data set
            </summary>
        </member>
        <member name="P:Nucleus.Maths.LinearDataSet`1.IsUniform">
            <summary>
            Is this data set uniform?  i.e. are all of the assigned values equal?
            </summary>
        </member>
        <member name="M:Nucleus.Maths.LinearDataSet`1.#ctor">
            <summary>
            Initialise a new empty LinearGraph
            </summary>
        </member>
        <member name="M:Nucleus.Maths.LinearDataSet`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Initialise a new LinearGraph from a list of values.
            The values will be plotted against their indices.
            </summary>
            <param name="values"></param>
        </member>
        <member name="M:Nucleus.Maths.LinearDataSet`1.AddJump(System.Double,`0,`0)">
            <summary>
            Add a sudden jump between two values.
            As two values cannot share the same key this is implemented by adding
            value0 at t, and value1 at the next greatest valid double parameter.
            </summary>
            <param name="t">The parameter at which to add the value jump</param>
            <param name="value0">The value before the jump</param>
            <param name="value1">The value after the jump</param>
        </member>
        <member name="M:Nucleus.Maths.LinearDataSet`1.ValueAt(System.Double,System.Boolean)">
            <summary>
            Get (or interpolate) the value at the specified parameter
            </summary>
            <param name="t">The parameter at which to retrieve or derive a value</param>
            <param name="extrapolate">If set to true, values outside the currently stored key range
            will be extrapolated from the tangency of the end values.  Otherwise the default value
            will be returned instead.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.LinearDataSet`1.Interpolate(System.Int32,System.Int32,System.Double)">
            <summary>
            Use straight-line interpolation to derive a value at the parameter t
            based on the entries in this list at indices i0 and i1.
            </summary>
            <param name="i0"></param>
            <param name="i1"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.LinearDataSet`1.Interpolate(`0,`0,System.Double)">
            <summary>
            Overridable interpolation function to provide
            efficient interpolation for the data set type
            </summary>
            <param name="i0"></param>
            <param name="i1"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Maths.LinearIntervalDataSet">
            <summary>
            A linear data set that plots numeric intervals along a single axis
            </summary>
        </member>
        <member name="P:Nucleus.Maths.LinearIntervalDataSet.IsEnvelope">
            <summary>
            Does this graph represent an envelope that encloses a range of values rather than
            just a single curve
            </summary>
        </member>
        <member name="P:Nucleus.Maths.LinearIntervalDataSet.ValueRange">
            <summary>
            Get the range of key values currently stored in this data set
            </summary>
        </member>
        <member name="M:Nucleus.Maths.LinearIntervalDataSet.#ctor">
            <summary>
            Initialises a new blank LinearIntervalDataSet
            </summary>
        </member>
        <member name="M:Nucleus.Maths.LinearIntervalDataSet.#ctor(System.Collections.Generic.IList{Nucleus.Maths.Interval})">
            <summary>
            Initialise a new LinearIntervalDataSet from a list of values.
            The values will be plotted against their indices.
            </summary>
            <param name="values"></param>
        </member>
        <member name="M:Nucleus.Maths.LinearIntervalDataSet.#ctor(System.Collections.Generic.IList{System.Double})">
            <summary>
            Initialise a new LinearIntervalDataSet from a list of values.
            The values will be converted to intervals and plotted against their indices.
            </summary>
            <param name="values"></param>
        </member>
        <member name="M:Nucleus.Maths.LinearIntervalDataSet.#ctor(Nucleus.Maths.LinearDoubleDataSet)">
            <summary>
            Initialise a new LinearIntervalDataSet from a LinearDoubleDataSet,
            converting each double value to an equivalent Interval
            </summary>
            <param name="doubleSet"></param>
        </member>
        <member name="M:Nucleus.Maths.LinearIntervalDataSet.Add(System.Double,System.Double)">
            <summary>
            Adds an element with the specified key and value into the
            graph.  The value will be automatically converted into an Interval.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Nucleus.Maths.LinearIntervalDataSet.Envelope(Nucleus.Maths.LinearIntervalDataSet)">
            <summary>
            Envelope this plot with another
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.LinearIntervalDataSet.MaxValues">
            <summary>
            Get the single set of data points that represent the maximum values
            of this envelope
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.LinearIntervalDataSet.MinValues">
            <summary>
            Get the set of data points that represent the minimum values
            of this envelope
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Maths.ValueExpression">
            <summary>
            An expression which represents an explicit value
            </summary>
        </member>
        <member name="F:Nucleus.Maths.ValueExpression._Value">
            <summary>
            Private backing field for Value property
            </summary>
        </member>
        <member name="P:Nucleus.Maths.ValueExpression.Value">
            <summary>
            The value represented by this expression
            </summary>
        </member>
        <member name="M:Nucleus.Maths.ValueExpression.#ctor(System.String,System.Object)">
            <summary>
            Initialise a new value expression with the given description and value
            </summary>
            <param name="description"></param>
        </member>
        <member name="M:Nucleus.Maths.ValueExpression.#ctor(System.Double)">
            <summary>
            Initialise a new value expression with the given double value
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:Nucleus.Maths.BinaryOperationExpression">
            <summary>
            Represents an expression preforming an operation 
            </summary>
        </member>
        <member name="F:Nucleus.Maths.BinaryOperationExpression._OperandA">
            <summary>
            Private backing field for OperandA property
            </summary>
        </member>
        <member name="P:Nucleus.Maths.BinaryOperationExpression.OperandA">
            <summary>
            The first operand
            </summary>
        </member>
        <member name="F:Nucleus.Maths.BinaryOperationExpression._OperandB">
            <summary>
            Private backing field for OperandB property
            </summary>
        </member>
        <member name="P:Nucleus.Maths.BinaryOperationExpression.OperandB">
            <summary>
            The second operand
            </summary>
        </member>
        <member name="F:Nucleus.Maths.BinaryOperationExpression._Operator">
            <summary>
            Private backing field for Operator property
            </summary>
        </member>
        <member name="P:Nucleus.Maths.BinaryOperationExpression.Operator">
            <summary>
            The operator that should be applied to the operands
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nucleus.Maths.BinaryOperationExpression.#ctor(System.String,Nucleus.Maths.Expression,Nucleus.Maths.Expression,System.String)" -->
        <member name="T:Nucleus.Maths.UnaryOperationExpression">
            <summary>
            An expression operation acting on a single operand
            </summary>
        </member>
        <member name="F:Nucleus.Maths.UnaryOperationExpression._Operand">
            <summary>
            Private backing field for Operand property
            </summary>
        </member>
        <member name="P:Nucleus.Maths.UnaryOperationExpression.Operand">
            <summary>
            The operand
            </summary>
        </member>
        <member name="F:Nucleus.Maths.UnaryOperationExpression._Operator">
            <summary>
            Private backing field for Operator property
            </summary>
        </member>
        <member name="P:Nucleus.Maths.UnaryOperationExpression.Operator">
            <summary>
            The operator that should be applied to the operands
            </summary>
        </member>
        <member name="M:Nucleus.Maths.UnaryOperationExpression.#ctor(System.String,Nucleus.Maths.Expression,System.String)">
            <summary>
            Initialis a unary operation expression
            </summary>
            <param name="description"></param>
            <param name="operand"></param>
            <param name="@operator"></param>
        </member>
        <member name="T:Nucleus.Maths.ReferenceExpression">
            <summary>
            An expression that forms a reference to a variable
            </summary>
        </member>
        <member name="M:Nucleus.Maths.ReferenceExpression.#ctor(System.String)">
            <summary>
            Initialise a variable reference
            </summary>
            <param name="description"></param>
        </member>
        <member name="F:Nucleus.Maths.ArrayMatrix._Values">
            <summary>
            Internal backing array of matrix values
            </summary>
        </member>
        <member name="P:Nucleus.Maths.ArrayMatrix.Item(System.Int32,System.Int32)">
            <summary>
            Gets or sets the value at a specific position in the matrix
            </summary>
            <param name="i">The column index</param>
            <param name="j">The row index</param>
            <returns>The value at [i,j] in this matrix</returns>
        </member>
        <member name="M:Nucleus.Maths.ArrayMatrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor creating an empty matrix with the specified number of rows and columns
            </summary>
            <param name="rows"></param>
            <param name="columns"></param>
        </member>
        <member name="M:Nucleus.Maths.ArrayMatrix.#ctor(System.Double[0:,0:])">
            <summary>
            Constructor creating a matrix from a two-dimensional array of doubles
            </summary>
            <param name="values">The 2D array of values</param>
        </member>
        <member name="M:Nucleus.Maths.ArrayMatrix.#ctor(Nucleus.Geometry.Vector)">
            <summary>
            Constructor creating a matrix from a vector.
            The vector will be taken as a column vector.
            </summary>
            <param name="columnVector">The vector to convert to a matrix</param>
        </member>
        <member name="M:Nucleus.Maths.ArrayMatrix.#ctor(System.Int32,System.Int32,System.Random,System.Double)">
            <summary>
            Initialise a matrix filled with (pseudo)random numbers
            </summary>
            <param name="rows">The number of rows in the matrix</param>
            <param name="columns">The number of columns in the matrix</param>
            <param name="populateWith">The random number generator that will provide the (pseudo)random values</param>
            <param name="scale">The maximum value of the random values</param>
        </member>
        <member name="M:Nucleus.Maths.ArrayMatrix.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Constructor creating a 3 x 3 matrix with the specified values
            </summary>
            <param name="a11">Value in row 1, column 1</param>
            <param name="a12">Value in row 1, column 2</param>
            <param name="a13">Value in row 1, column 3</param>
            <param name="a21">Value in row 2, column 1</param>
            <param name="a22">Value in row 2, column 2</param>
            <param name="a23">Value in row 2, column 3</param>
            <param name="a31">Value in row 3, column 1</param>
            <param name="a32">Value in row 3, column 2</param>
            <param name="a33">Value in row 3, column 3</param>
        </member>
        <member name="M:Nucleus.Maths.ArrayMatrix.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Constructor creating a 4 x 4 matrix with the specified values
            </summary>
            <param name="a11"></param>
            <param name="a12"></param>
            <param name="a13"></param>
            <param name="a14"></param>
            <param name="a21"></param>
            <param name="a22"></param>
            <param name="a23"></param>
            <param name="a24"></param>
            <param name="a31"></param>
            <param name="a32"></param>
            <param name="a33"></param>
            <param name="a34"></param>
            <param name="a41"></param>
            <param name="a42"></param>
            <param name="a43"></param>
            <param name="a44"></param>
        </member>
        <member name="M:Nucleus.Maths.ArrayMatrix.#ctor(Nucleus.Maths.Matrix)">
            <summary>
            Constructor creating a clone of an existing matrix
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Nucleus.Maths.ArrayMatrix.Identity(System.Int32)">
            <summary>
            Create a square identity matrix of the given size
            </summary>
            <param name="size">The number of rows and columns the matrix will have</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Maths.Interval">
            <summary>
            A numeric interval.
            Represents a set of real numbers with the property that any number
            that lies between two numbers in the set is also included in the set.
            Immutable.
            </summary>
        </member>
        <member name="F:Nucleus.Maths.Interval.Unset">
            <summary>
            Constant value representing an unset interval
            </summary>
        </member>
        <member name="F:Nucleus.Maths.Interval.Unit">
            <summary>
            The unit interval from 0 to 1.
            </summary>
        </member>
        <member name="F:Nucleus.Maths.Interval.Start">
            <summary>
            The minimum, or start, value of this interval.
            </summary>
        </member>
        <member name="F:Nucleus.Maths.Interval.End">
            <summary>
            The maximum, or end, value of this interval.
            </summary>
        </member>
        <member name="P:Nucleus.Maths.Interval.IsValid">
            <summary>
            Is this interval valid?
            An interval is valid providing both of its limits are not set to NaN.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Maths.Interval.IsSingularity">
            <summary>
            Is this a singularity?  i.e. are the maximum and minimum values the same?
            </summary>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Maths.Interval.Mid">
            <summary>
            The mid-point of this interval
            </summary>
        </member>
        <member name="P:Nucleus.Maths.Interval.Size">
            <summary>
            The size, or length, of this interval
            </summary>
        </member>
        <member name="P:Nucleus.Maths.Interval.Item(System.Int32)">
            <summary>
            Gets the indexed bound of this interval.
            0 = Min, 1 = Max
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Maths.Interval.IsIncreasing">
            <summary>
            Does this interval represent a range of values which increases from start to finish
            </summary>
        </member>
        <member name="P:Nucleus.Maths.Interval.IsDecreasing">
            <summary>
            Does this interval represent a range of
            </summary>
        </member>
        <member name="P:Nucleus.Maths.Interval.Min">
            <summary>
            Get the minimum value encompassed by this interval
            (This will be the lesser of the Start and End fields)
            </summary>
        </member>
        <member name="P:Nucleus.Maths.Interval.Max">
            <summary>
            Get the maximum value encompassed by this interval
            (This will be the greater of the Start and End fields)
            </summary>
        </member>
        <member name="P:Nucleus.Maths.Interval.AbsMax">
            <summary>
            Get the signed value of the greatest absolute value in this interval.
            This will return whichever of Max and Min has the largest (unsigned) magnitude.
            </summary>
        </member>
        <member name="M:Nucleus.Maths.Interval.#ctor(System.Double)">
            <summary>
            Constructor creating a singularity interval with
            maximum and minimum set to the specified value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Nucleus.Maths.Interval.#ctor(System.Double,System.Double)">
            <summary>
            Constructor creating an interval from maximum and minimum values.
            The minimum value should be lower than or equal to the maximum, or else
            this interval will not be valid.
            </summary>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="M:Nucleus.Maths.Interval.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Constructor creating an interval surrounding the specified set of 
            values.  The maximum and minimum will be automatically determined.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:Nucleus.Maths.Interval.#ctor(System.Double[])">
            <summary>
            Constructor creating an interval surrounding the specified set of 
            values.  The maximum and minimum will be automatically determined
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:Nucleus.Maths.Interval.Equals(Nucleus.Maths.Interval)">
            <summary>
            Is this interval equal to another?
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.Equals(System.Double)">
            <summary>
            Is this interval equal to a value?
            The interval counts as equal to a single value only if the interval
            is a singularity with limits equal to the value
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.LesserThan(Nucleus.Maths.Interval)">
            <summary>
            Is this interval less than another?
            The interval counts as less than another if its maximum value
            is lower than the minimum value of the other.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.GreaterThan(Nucleus.Maths.Interval)">
            <summary>
            Is this interval greater than another?
            The interval counts as greater than another if its minimum value
            is greater than the maximum value of the other.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.WrapTo(Nucleus.Maths.Interval)">
            <summary>
            Wrap the start and end values of this interval to the
            specified interval
            </summary>
            <param name="bounds"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.CompareTo(Nucleus.Maths.Interval)">
            <summary>
            IComparable implementation.  Compares this interval to another.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.GetHashCode">
            <summary>
            GetHashCode override.
            Generates a hash code by XORing those of its components.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.ValueAt(System.Double)">
            <summary>
            Evaluate the value at a normalised parameter of this interval.
            </summary>
            <param name="parameter">A normalised parameter.
            0 = Min, 1 = Max.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.ParameterOf(System.Double)">
            <summary>
            Evaluate the normalised parameter (where 0 is Start and 1 is End) of
            the specified value's position related to this interval
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.ParameterOf(Nucleus.Maths.Interval)">
            <summary>
            Normalise another interval to the range of this one.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.Contains(System.Double)">
            <summary>
            Does this interval include the specified value?
            Both start and end are inclusive.
            </summary>
            <param name="value"></param>
            <returns>True if the specified value falls on or between the interval limits, else false.</returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.ContainsOpenEndWrapped(System.Double)">
            <summary>
            Is the parameter t enclosed by this interval?
            The start value is inclusive, the end is exclusive
            </summary>
            <param name="interval"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.Contains(Nucleus.Maths.Interval)">
            <summary>
            Does this interval entirely include another?
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.Overlaps(Nucleus.Maths.Interval)">
            <summary>
            Does this interval entirely or partially include another?
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.Overlap(Nucleus.Maths.Interval)">
            <summary>
            Find the overlap between this interval and another,
            if there is one.
            </summary>
            <param name="other"></param>
            <returns>The interval overlap between the two intervals.
            Or, Interval.Unset if there is no overlap.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nucleus.Maths.Interval.Include(System.Double)" -->
        <member name="M:Nucleus.Maths.Interval.Union(Nucleus.Maths.Interval)">
            <summary>
            Find the union of this and another interval.
            </summary>
            <param name="other"></param>
            <returns>An interval from the combined minimum and maximum 
            values of the two intervals.</returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.Interpolate(Nucleus.Maths.Interval,System.Double)">
            <summary>
            Interpolate this Interval towards another
            </summary>
            <param name="towards">The interval to interpolate towards</param>
            <param name="factor">The interpolation factor.  0 = this interval, 1 = the 'towards' interval</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.Interpolate(Nucleus.Maths.Interval,System.Double,System.Double,System.Double)">
            <summary>
            Interpolate this Interval towards another
            </summary>
            <param name="i1">The other interval to interpolate towards</param>
            <param name="x0">The key value mapped to this interval</param>
            <param name="x1">The key value mapped to the other interval</param>
            <param name="x">The key value at the interpolation point</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.ReasonableDivisions(System.Int32)">
            <summary>
            Generate a set of evently-spaced 'reasonable' rounded numbers within
            this interval, to be used as such things as generating grid lines on graphs
            </summary>
            <param name="divisions">The target number of divisions.  The ultimate number of values may be slightly more or less than this depending on rounding</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.Wrap(System.Double)">
            <summary>
            Wrap the specified value to the bounds of this interval
            </summary>
            <param name="value">The value to wrap</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.WithStart(System.Double)">
            <summary>
            Create a new interval with the same end value as this one
            but with the new specified start value.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.WithEnd(System.Double)">
            <summary>
            Create a new interval with the same start value as this one
            but with the new specified end value.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.Random(System.Random)">
            <summary>
            Generate a random double within this interval
            </summary>
            <param name="rng">The random number generator to use</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.BooleanDifference(System.Collections.Generic.IList{Nucleus.Maths.Interval})">
            <summary>
            Find the boolean difference of this interval and a set of other intervals which
            subtract from it.
            </summary>
            <param name="detractors"></param>
            <param name="domain"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.BooleanDifference(System.Collections.Generic.IList{Nucleus.Maths.Interval},System.Collections.Generic.IList{Nucleus.Maths.Interval})">
            <summary>
            Find the boolean difference of this interval and a set of other intervals which
            subtract from it.
            </summary>
            <param name="detractors"></param>
            <param name="domain"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.op_Addition(Nucleus.Maths.Interval,System.Double)">
            <summary>
            Addition operator override.
            Adds a double value to both max and min of an interval.
            </summary>
        </member>
        <member name="M:Nucleus.Maths.Interval.op_Addition(System.Double,Nucleus.Maths.Interval)">
            <summary>
            Addition operator override.
            Adds a double value to both max and min of an interval.
            </summary>
            <param name="i"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.op_Addition(Nucleus.Maths.Interval,Nucleus.Maths.Interval)">
            <summary>
            Addition operator override.  
            Calculates the range of possible values if any value in the
            first interval is added to any value in the second
            </summary>
            <param name="i1"></param>
            <param name="i2"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.op_Subtraction(Nucleus.Maths.Interval,System.Double)">
            <summary>
            Subtraction operator override.  Subtracts a double from both
            max and min of an interval.
            </summary>
            <param name="i"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.op_Subtraction(System.Double,Nucleus.Maths.Interval)">
            <summary>
            Subtraction operator override.
            Returns the range of possible values from subtracting an 
            interval from a double.
            </summary>
            <param name="i"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.op_Subtraction(Nucleus.Maths.Interval,Nucleus.Maths.Interval)">
            <summary>
            Subtraction operator override.
            Returns the range of possible values from subtracting one
            interval from another.
            </summary>
            <param name="i1"></param>
            <param name="i2"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.op_Multiply(Nucleus.Maths.Interval,System.Double)">
            <summary>
            Multiplication operator override.
            Multiplies an interval by a scalar.
            </summary>
            <param name="i"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.op_Multiply(System.Double,Nucleus.Maths.Interval)">
            <summary>
            Multiplication operator override.
            Multiplies an interval by a scalar.
            </summary>
            <param name="i"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.op_Multiply(Nucleus.Maths.Interval,Nucleus.Maths.Interval)">
            <summary>
            Multiplication operator override.
            Returns the range of possible values from
            multiplying one interval by another.
            </summary>
            <param name="i1"></param>
            <param name="i2"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.op_Division(Nucleus.Maths.Interval,System.Double)">
            <summary>
            Division operator override.
            Divides an interval by a divisor.
            </summary>
            <param name="i"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.op_Division(System.Double,Nucleus.Maths.Interval)">
            <summary>
            Division operator override.
            Divides a value by an interval.
            Returns the range of possible values emerging from the division.
            </summary>
            <param name="d"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.op_Equality(Nucleus.Maths.Interval,Nucleus.Maths.Interval)">
            <summary>
            Equality operator override
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.op_Inequality(Nucleus.Maths.Interval,Nucleus.Maths.Interval)">
            <summary>
            Inequality operator override
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.op_LessThan(Nucleus.Maths.Interval,Nucleus.Maths.Interval)">
            <summary>
            Lesser-than operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.op_GreaterThan(Nucleus.Maths.Interval,Nucleus.Maths.Interval)">
            <summary>
            Greater-than operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.op_Equality(Nucleus.Maths.Interval,System.Double)">
            <summary>
            Interval-double equality operator
            </summary>
            <param name="i"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.op_Inequality(Nucleus.Maths.Interval,System.Double)">
            <summary>
            Interval double equality operator
            </summary>
            <param name="i"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Interval.op_Modulus(Nucleus.Maths.Interval,System.Double)">
            <summary>
            Interval modulo operator
            </summary>
            <param name="i"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.IntervalExtensions.FindEnclosing(System.Collections.Generic.IList{Nucleus.Maths.Interval},System.Double)">
            <summary>
            Find the first interval in this collection that encloses the specified t value
            </summary>
            <param name="intervals"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.IntervalExtensions.FindNext(System.Collections.Generic.IList{Nucleus.Maths.Interval},System.Double)">
            <summary>
            Find the next interval in this collection starting after the specified parameter
            </summary>
            <param name="intervals"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Maths.Matrix">
            <summary>
            Base class for matrices of doubles.
            </summary>
        </member>
        <member name="P:Nucleus.Maths.Matrix.Item(System.Int32,System.Int32)">
            <summary>
            Gets or sets the value at a specific position in the matrix
            </summary>
            <param name="i">The row index</param>
            <param name="j">The column index</param>
            <returns>The value at [i,j] in this matrix</returns>
        </member>
        <member name="F:Nucleus.Maths.Matrix._Rows">
            <summary>
            Private backing field for Rows property
            </summary>
        </member>
        <member name="P:Nucleus.Maths.Matrix.Rows">
            <summary>
            The number of rows in this matrix
            </summary>
        </member>
        <member name="F:Nucleus.Maths.Matrix._Columns">
            <summary>
            Private backing field for Columns property
            </summary>
        </member>
        <member name="P:Nucleus.Maths.Matrix.Columns">
            <summary>
            The number of columns in this matrix
            </summary>
        </member>
        <member name="P:Nucleus.Maths.Matrix.IsSquare">
            <summary>
            Returns true if this is a square matrix -
            i.e. the number of rows equals the number of columns
            </summary>
        </member>
        <member name="M:Nucleus.Maths.Matrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Base constructor.  The number of rows and columns must be specified
            </summary>
            <param name="rows"></param>
            <param name="columns"></param>
        </member>
        <member name="M:Nucleus.Maths.Matrix.CreateNewMatrix(System.Int32,System.Int32)">
            <summary>
            Internal function to create a new blank matrix of the same type 
            as this one. 
            </summary>
            <param name="rows"></param>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Matrix.SetMainDiagonal(System.Double)">
            <summary>
            Set the values of the fields in the 'main diagonal',
            i.e. the fields running from 'top left' to 'bottom right',
            or where i = j.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Nucleus.Maths.Matrix.SetRow(System.Int32,System.Double[])">
            <summary>
            Set the values of the fields in the specified row.
            </summary>
            <param name="row">The row index</param>
            <param name="values">The new set of values to be placed within the row</param>
        </member>
        <member name="M:Nucleus.Maths.Matrix.SetColumn(System.Int32,System.Double[])">
            <summary>
            Set the values of the fields in the specified column.
            </summary>
            <param name="column">The column index</param>
            <param name="values">The new set of values to be placed within the column</param>
        </member>
        <member name="M:Nucleus.Maths.Matrix.ClearRow(System.Int32)">
            <summary>
            Clear a row (i.e. set all values in that row to 0)
            </summary>
            <param name="row">The index of the row to clear</param>
        </member>
        <member name="M:Nucleus.Maths.Matrix.ClearRow(System.Int32,System.Boolean)">
            <summary>
            Clear a row (i.e. set all values in that row to 0),
            optionally maintaining non-singularity by setting the
            diagonal to 1.
            </summary>
            <param name="row">The index of the row to clear</param>
            <param name="maintainNonSingularity">If true, non-singularity will be 
            maintained by setting the diagonal in the row to be 1.</param>
        </member>
        <member name="M:Nucleus.Maths.Matrix.ClearColumn(System.Int32)">
            <summary>
            Clear a column (i.e. set all values in that column to 0)
            </summary>
            <param name="column">The index of the column to clear</param>
        </member>
        <member name="M:Nucleus.Maths.Matrix.ClearColumn(System.Int32,System.Boolean)">
            <summary>
            Clear a column (i.e. set all values in that column to 0),
            optionally maintaining non-singularity by setting the
            diagonal to 1.
            </summary>
            <param name="column">The index of the column to clear</param>
            /// <param name="maintainNonSingularity">If true, non-singularity will be 
            maintained by setting the diagonal in the column to be 1.</param>
        </member>
        <member name="M:Nucleus.Maths.Matrix.SetBlock(System.Int32,System.Int32,Nucleus.Maths.Matrix)">
            <summary>
            Overwrites a section of this matrix with the values defined within another,
            starting at the specified indices
            </summary>
            <param name="startRow">The starting row index for insertion</param>
            <param name="startColumn">The starting column index for insertion</param>
            <param name="values">The matrix of values to be inserted</param>
        </member>
        <member name="M:Nucleus.Maths.Matrix.SwapRows(System.Int32,System.Int32)">
            <summary>
            Exchange the values in two rows in this matrix.
            An elementary row operation.
            </summary>
            <param name="iA">The first row index</param>
            <param name="iB">The second row index</param>
        </member>
        <member name="M:Nucleus.Maths.Matrix.MultiplyRow(System.Int32,System.Double)">
            <summary>
            Multiply a row by a factor.
            An elementary row operation.
            </summary>
            <param name="i">The index of the row to be modified.</param>
            <param name="scalar">The factor to multiply by.</param>
        </member>
        <member name="M:Nucleus.Maths.Matrix.DivideRow(System.Int32,System.Double)">
            <summary>
            Divide a row by a non-zero constant.
            An elementary row operation.
            </summary>
            <param name="i">The row index</param>
            <param name="divisor">The value to divide by.
            Should be non-zero.</param>
        </member>
        <member name="M:Nucleus.Maths.Matrix.SubtractRow(System.Int32,System.Int32,System.Double)">
            <summary>
            Subtract row B times a factor from row A.
            An elementary row operation.
            </summary>
            <param name="iA">The index of the row to subtract from</param>
            <param name="iB">The index of the row to subtract</param>
            <param name="factor">The factor by which the second row is to be multiplied
            before subtraction.</param>
        </member>
        <member name="M:Nucleus.Maths.Matrix.Transpose">
            <summary>
            Create the transpose of this matrix.
            The transpose of a matrix is obtained by flipping rows and columns.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Matrix.GaussianElimination">
            <summary>
            Uses Gaussian Elimination to put the matrix into row-echelon form.
            </summary>
        </member>
        <member name="M:Nucleus.Maths.Matrix.LUDecomposition(Nucleus.Maths.Matrix@,Nucleus.Maths.Matrix@)">
            <summary>
            Express this matrix as the product of:
            L, a singular lower triangular matrix and
            U, an upper triangular matrix.
            This matrix must be square.
            </summary>
            <param name="L">Output.  A singular lower triangular matrix.</param>
            <param name="U">Output.  An upper triangular matrix.</param>
        </member>
        <member name="M:Nucleus.Maths.Matrix.Solve">
            <summary>
            Solve a matrix representing a system of simultaneous equations.
            The matrix must be augmented and in row-echelon form, with each column
            before the last indicating a variable coefficient 
            </summary>
            <returns>A single-row matrix going the solution for each column.</returns>
        </member>
        <member name="M:Nucleus.Maths.Matrix.Add(Nucleus.Maths.Matrix)">
            <summary>
            Matrix addition in-place.  Adds another matrix to this one.
            To obtain a new sum matrix without modifying this one, use the + operator instead.
            </summary>
            <param name="other">Another matrix with the same dimensions as this one.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Matrix.Subtract(Nucleus.Maths.Matrix)">
            <summary>
            Matrix subtraction in-place.  Subtracts another matrix from this one.
            To obtain a new sum matrix without modifying this one, use the - operator instead.
            </summary>
            <param name="other">Another matrix with the same dimensions as this one.</param>
        </member>
        <member name="M:Nucleus.Maths.Matrix.Multiply(System.Double)">
            <summary>
            Multiply this matrix by a scalar in-place.
            All fields of this matrix will be multiplied by the specified factor.
            </summary>
            <param name="scalar">The factor to multiply by</param>
        </member>
        <member name="M:Nucleus.Maths.Matrix.Divide(System.Double)">
            <summary>
            Divide this matrix by a scalar in-place.
            All fields of this matrix will be divided by the specified factor.
            </summary>
            <param name="scalar">The factor to devide by</param>
        </member>
        <member name="M:Nucleus.Maths.Matrix.SubMatrix(System.Int32,System.Int32)">
            <summary>
            Return a sub-matrix of this matrix by eliminating one row and one column
            </summary>
            <param name="row">The row number to remove</param>
            <param name="column">The column number to remove</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Matrix.Adjugate">
            <summary>
            Calculate the adjugate, classical adjoint or adjunct of this matrix
            (i.e. the transpose of the matrix of cofactors).
            This is only valid for square matrices.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Matrix.Inverse">
            <summary>
            Calculate the inverse of this matrix, if it exists.
            If there is no inverse (i.e. the determinant = 0) then null will
            be returned.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Matrix.Determinant">
            <summary>
            Calculate the determinant of this matrix by expanding along the first row.
            This is only valid for square matrices.
            </summary>
            <returns></returns>
            <remarks>Recursive and of factorial order - not recommended for large matrices!</remarks>
        </member>
        <member name="M:Nucleus.Maths.Matrix.Augmented(Nucleus.Maths.Matrix)">
            <summary>
            Generate an augmented form of this matrix by adding the columns from the specified other matrix
            </summary>
            <param name="columns">The values to be placed in the new columns.  Should have the same number of
            rows as this matrix.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Matrix.Duplicate">
            <summary>
            Create a duplicate of this matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Matrix.ToString">
            <summary>
            Get the contents of this matrix expressed as a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Matrix.op_Addition(Nucleus.Maths.Matrix,Nucleus.Maths.Matrix)">
            <summary>
            Addition operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Matrix.op_Subtraction(Nucleus.Maths.Matrix,Nucleus.Maths.Matrix)">
            <summary>
            Subtraction operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Matrix.op_Multiply(System.Double,Nucleus.Maths.Matrix)">
            <summary>
            Scalar multiplication operator
            </summary>
            <param name="s"></param>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Matrix.op_Multiply(Nucleus.Maths.Matrix,System.Double)">
            <summary>
            Scalar multiplication operator
            </summary>
            <param name="s"></param>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Maths.Matrix.op_Multiply(Nucleus.Maths.Matrix,Nucleus.Maths.Matrix)">
            <summary>
            Matrix multiplication operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
            <remarks>Uses standard matrix multiplication.
            Possibly switch out for Strassen algorithm?</remarks>
        </member>
        <member name="M:Nucleus.Maths.Matrix.op_Division(Nucleus.Maths.Matrix,System.Double)">
            <summary>
            Scalar division operator
            </summary>
            <param name="s"></param>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Maths.Interpolation">
            <summary>
            An enumerated value which describes different algorithms to be used for
            tweening interpolation.
            </summary>
        </member>
        <member name="F:Nucleus.Maths.Interpolation.Linear">
            <summary>
            Linear interpolation: t/d
            </summary>
        </member>
        <member name="F:Nucleus.Maths.Interpolation.Quadratic">
            <summary>
            Quadratic interpolation: (t/d)^2
            </summary>
        </member>
        <member name="F:Nucleus.Maths.Interpolation.Cubic">
            <summary>
            Cubic interpolation: (t/d)^3
            </summary>
        </member>
        <member name="F:Nucleus.Maths.Interpolation.SquareRoot">
            <summary>
            Square root interpolation: (t/d)^0.5
            </summary>
        </member>
        <member name="F:Nucleus.Maths.Interpolation.CubeRoot">
            <summary>
            Cube root interpolation: (t/d)^1/3
            </summary>
        </member>
        <member name="F:Nucleus.Maths.Interpolation.Exponential">
            <summary>
            Exponential interpolation: (exp(a*(t/d))-1)*1/(exp(a)-1)
            </summary>
        </member>
        <member name="F:Nucleus.Maths.Interpolation.Elastic">
            <summary>
            Pseudo-elastic interpolation: 1/(exp(a)-1)*cos(b*(t/d)*2*PI)*exp(a*(t/d))-1/(exp(a)-1)
            </summary>
        </member>
        <member name="F:Nucleus.Maths.Interpolation.Sin">
            <summary>
            Sine interpolation: sin(a*(t/d)*2*PI)
            </summary>
        </member>
        <member name="F:Nucleus.Maths.Interpolation.Cos">
            <summary>
            Cosine interpolation: cos(a*(t/d)*2*PI)
            </summary>
        </member>
        <member name="F:Nucleus.Maths.Interpolation.Step">
            <summary>
            Step interpolation: jumps from one value to another at the mid-point
            </summary>
        </member>
        <member name="T:Nucleus.Maths.InterpolationExtensions">
            <summary>
            Extension methods for the Interpolation enum
            </summary>
        </member>
        <member name="M:Nucleus.Maths.InterpolationExtensions.Interpolate(Nucleus.Maths.Interpolation,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Interpolate between two values using the algorithm represented by this enumerated value
            </summary>
            <param name="i"></param>
            <param name="v0">The first value to interpolate from</param>
            <param name="v1">The second value to interpolate towards</param>
            <param name="t">The interpolation parameter.  Typically will be between 0-1,
            where 0 is v0 and 1 is v1</param>
            <param name="alpha">The optional Alpha parameter used in some tweening methods</param>
            <param name="beta">The optional Beta parameter used in some tweening methods</param>
            <returns>The interpolated value</returns>
        </member>
        <member name="M:Nucleus.Maths.InterpolationExtensions.Interpolate(Nucleus.Maths.Interpolation,Nucleus.Geometry.Angle,Nucleus.Geometry.Angle,System.Double,System.Double,System.Double)">
            <summary>
            Interpolate between two angles using the algorithm represented by this enumerated value.
            The direction of rotation will be automatically determined as whichever is the smallest
            change in angle.
            </summary>
            <param name="i"></param>
            <param name="v0">The first value to interpolate from</param>
            <param name="v1">The second value to interpolate towards</param>
            <param name="t">The interpolation parameter.  Typically will be between 0-1,
            where 0 is v0 and 1 is v1</param>
            <param name="alpha">The optional Alpha parameter used in some tweening methods</param>
            <param name="beta">The optional Beta parameter used in some tweening methods</param>
            <returns>The interpolated value</returns>
        </member>
        <member name="M:Nucleus.Maths.InterpolationExtensions.Interpolate(Nucleus.Maths.Interpolation,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,System.Double,System.Double,System.Double)">
            <summary>
            Interpolate between two values using the algorithm represented by this enumerated value
            </summary>
            <param name="i"></param>
            <param name="v0">The first value to interpolate from</param>
            <param name="v1">The second value to interpolate towards</param>
            <param name="t">The interpolation parameter.  Typically will be between 0-1,
            where 0 is v0 and 1 is v1</param>
            <param name="alpha">The optional Alpha parameter used in some tweening methods</param>
            <param name="beta">The optional Beta parameter used in some tweening methods</param>
            <returns>The interpolated value</returns>
        </member>
        <member name="M:Nucleus.Maths.InterpolationExtensions.Interpolate(Nucleus.Maths.Interpolation,Nucleus.Rendering.Colour,Nucleus.Rendering.Colour,System.Double,System.Double,System.Double)">
            <summary>
            Interpolate between two values using the algorithm represented by this enumerated value
            </summary>
            <param name="i"></param>
            <param name="c0">The first value to interpolate from</param>
            <param name="c1">The second value to interpolate towards</param>
            <param name="t">The interpolation parameter.  Typically will be between 0-1,
            where 0 is v0 and 1 is v1</param>
            <param name="alpha">The optional Alpha parameter used in some tweening methods</param>
            <param name="beta">The optional Beta parameter used in some tweening methods</param>
            <returns>The interpolated value</returns>
        </member>
        <member name="M:Nucleus.Maths.InterpolationExtensions.Interpolate``1(Nucleus.Maths.Interpolation,``0,``0,System.Double,System.Double,System.Double)">
            <summary>
            Interpolate between two values using the algorithm represented by this enumerated value.
            This will only successfully work for datatypes which implement the +, - and * operators
            and are unbounded.
            </summary>
            <param name="i"></param>
            <param name="v0">The first value to interpolate from</param>
            <param name="v1">The second value to interpolate towards</param>
            <param name="t">The interpolation parameter.  Typically will be between 0-1,
            where 0 is v0 and 1 is v1</param>
            <param name="alpha">The optional Alpha parameter used in some tweening methods</param>
            <param name="beta">The optional Beta parameter used in some tweening methods</param>
            <returns>The interpolated value</returns>
        </member>
        <member name="M:Nucleus.Maths.InterpolationExtensions.Tween(Nucleus.Maths.Interpolation,System.Double,System.Double,System.Double)">
            <summary>
            Tween a value using the algorithm represented by this enumerated value
            </summary>
            <param name="i"></param>
            <param name="t">The interpolation parameter to be adjusted by this interpolation algorithm.
            Typically should be between 0-1</param>
            <param name="alpha">The optional Alpha parameter used in some tweening methods</param>
            <param name="beta">The optional Beta parameter used in some tweening methods</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Meshing.HalfEdge">
            <summary>
            A half-edge data structure used as a means of
            representing edges in a manifold mesh in an easily-traversable
            manner.
            </summary>
        </member>
        <member name="F:Nucleus.Meshing.HalfEdge._Vertex">
            <summary>
            Private backing member variable for the Vertex property
            </summary>
        </member>
        <member name="P:Nucleus.Meshing.HalfEdge.Vertex">
            <summary>
            The vertex at the end of the half-edge
            </summary>
        </member>
        <member name="F:Nucleus.Meshing.HalfEdge._Pair">
            <summary>
            Private backing member variable for the Pair property
            </summary>
        </member>
        <member name="P:Nucleus.Meshing.HalfEdge.Pair">
            <summary>
            The oppositely-orientated adjacent half-edge
            </summary>
        </member>
        <member name="F:Nucleus.Meshing.HalfEdge._Face">
            <summary>
            Private backing member variable for the Face property
            </summary>
        </member>
        <member name="P:Nucleus.Meshing.HalfEdge.Face">
            <summary>
            The mesh face that the half-edge borders
            </summary>
        </member>
        <member name="F:Nucleus.Meshing.HalfEdge._Next">
            <summary>
            Private backing member variable for the Next property
            </summary>
        </member>
        <member name="P:Nucleus.Meshing.HalfEdge.Next">
            <summary>
            The mesh face that the half-edge borders
            </summary>
        </member>
        <member name="T:Nucleus.Meshing.HalfEdgeFace">
            <summary>
            A face in a half-edge mesh
            </summary>
        </member>
        <member name="F:Nucleus.Meshing.HalfEdgeFace._Edge">
            <summary>
            Private backing member variable for the Edge property
            </summary>
        </member>
        <member name="P:Nucleus.Meshing.HalfEdgeFace.Edge">
            <summary>
            One of the half-edges bordering the face
            </summary>
        </member>
        <member name="T:Nucleus.Meshing.HalfEdgeVertex">
            <summary>
            A vertex in a Half-Egde mesh
            </summary>
        </member>
        <member name="F:Nucleus.Meshing.HalfEdgeVertex._Position">
            <summary>
            Private backing member variable for the Position property
            </summary>
        </member>
        <member name="P:Nucleus.Meshing.HalfEdgeVertex.Position">
            <summary>
            The position of the vertex
            </summary>
        </member>
        <member name="F:Nucleus.Meshing.HalfEdgeVertex._Edge">
            <summary>
            Private backing member variable for the Edge property
            </summary>
        </member>
        <member name="P:Nucleus.Meshing.HalfEdgeVertex.Edge">
            <summary>
            One of the half-edges emanating from this vertex
            </summary>
        </member>
        <member name="T:Nucleus.Meshing.MeshDivisionEdge">
            <summary>
            A temporary data structure to hold information about
            a mesh edge during a subdivision operation
            </summary>
        </member>
        <member name="P:Nucleus.Meshing.MeshDivisionEdge.Vertices">
            <summary>
            The vertices along this edge
            </summary>
        </member>
        <member name="P:Nucleus.Meshing.MeshDivisionEdge.Start">
            <summary>
            Get the start vertex of the edge
            </summary>
        </member>
        <member name="P:Nucleus.Meshing.MeshDivisionEdge.End">
            <summary>
            Get the end vertex of the edge
            </summary>
        </member>
        <member name="P:Nucleus.Meshing.MeshDivisionEdge.Length">
            <summary>
            The length of the edge
            </summary>
        </member>
        <member name="P:Nucleus.Meshing.MeshDivisionEdge.ID">
            <summary>
            The ID of the edge, used to uniquely
            identify and combine them
            </summary>
        </member>
        <member name="P:Nucleus.Meshing.MeshDivisionEdge.Divisions">
            <summary>
            The number of segments this edge has been divided
            into.
            </summary>
        </member>
        <member name="M:Nucleus.Meshing.MeshDivisionEdge.#ctor(Nucleus.Geometry.Vertex,Nucleus.Geometry.Vertex)">
            <summary>
            Initialise a new MeshDivisionEdge between the specified vertices
            </summary>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshDivisionEdge.#ctor(Nucleus.Geometry.MeshFace,System.Int32)">
            <summary>
            Initialise a new MeshDivisionEdge for the specified edge of the specified face
            </summary>
            <param name="face"></param>
            <param name="edgeIndex"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshDivisionEdge.SubDivide(System.Int32)">
            <summary>
            Subdivide this edge by adding new vertices between the start and
            end vertices
            </summary>
            <param name="divisions"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshDivisionEdge.SubDivideByLength(System.Double)">
            <summary>
            Subdivide this edge into segments with no greater than the specified
            maximum length by adding new vertices between the start and end
            vertices.
            </summary>
            <param name="maxLength"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshDivisionEdge.Reversed">
            <summary>
            Get a copy of this edge with the direction reversed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Meshing.MeshDivisionEdge.IDFor(Nucleus.Geometry.Vertex,Nucleus.Geometry.Vertex)">
            <summary>
            Get the ID string for an edge between the specified pair of vertices
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Meshing.MeshDivisionEdge.IDFor(Nucleus.Geometry.MeshFace,System.Int32)">
            <summary>
            Get the ID string for the specified edge of the face
            </summary>
            <param name="face"></param>
            <param name="edgeIndex"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Meshing.MeshDivisionEdgeCollection">
            <summary>
            A collection of mesh division edges
            </summary>
        </member>
        <member name="M:Nucleus.Meshing.MeshDivisionEdgeCollection.#ctor">
            <summary>
            Initialise a new empty collection
            </summary>
        </member>
        <member name="M:Nucleus.Meshing.MeshDivisionEdgeCollection.#ctor(Nucleus.Geometry.MeshFaceCollection)">
            <summary>
            Initialise a collection of MeshDivisionEdges generated from the specified
            face collection.
            </summary>
            <param name="generateFrom"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshDivisionEdgeCollection.GenerateForFaces(Nucleus.Geometry.MeshFaceCollection)">
            <summary>
            Generate edge division structures for the specified collection
            of mesh faces
            </summary>
            <param name="faces"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshDivisionEdgeCollection.SubDivideAll(System.Double)">
            <summary>
            Subdivide all edges in this collection by adding intermediate
            vertices such that no segment between them exceeds the specified
            length
            </summary>
            <param name="maxLength"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshDivisionEdgeCollection.GetEdgesForFace(Nucleus.Geometry.MeshFace)">
            <summary>
            Get all of the previously generated MeshDivisionEdges for the
            specified face.
            Edges will automatically be reversed in order to match the winding
            order of the face if necessary.
            </summary>
            <param name="face"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Meshing.CoordinateSystemRemappingOption">
            <summary>
            An enum describing different ways of remapping points into
            a coordinate system.
            </summary>
        </member>
        <member name="T:Nucleus.Meshing.DelaunayTriangle">
            <summary>
            A special type of mesh face created via a Delaunay Triangulation meshing
            </summary>
        </member>
        <member name="F:Nucleus.Meshing.DelaunayTriangle._ExcludeFromContainmentCheck">
            <summary>
            If true, this triangle can be excluded from future containment checks because
            subsequent vertices will be too far to the right of this triangle to 
            </summary>
        </member>
        <member name="F:Nucleus.Meshing.DelaunayTriangle._Circumcentre">
            <summary>
            The bounding interval of this triangle in the Y-direction
            </summary>
        </member>
        <member name="P:Nucleus.Meshing.DelaunayTriangle.XYCircumcentre">
            <summary>
            Get the circumcentre of the first three vertices of this face on the XY plane
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Meshing.DelaunayTriangle.#ctor(Nucleus.Geometry.Vertex,Nucleus.Geometry.Vertex,Nucleus.Geometry.Vertex)">
            <summary>
            Initialise a triangular mesh face between the three specified vertices
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="v3"></param>
        </member>
        <member name="M:Nucleus.Meshing.DelaunayTriangle.#ctor(Nucleus.Geometry.MeshEdge,Nucleus.Geometry.Vertex)">
            <summary>
            Initialise a triangular mesh face between an edge and a vertex
            </summary>
            <param name="edge"></param>
            <param name="v"></param>
        </member>
        <member name="M:Nucleus.Meshing.DelaunayTriangle.XYCircumcircleContainmentQuickCheck(Nucleus.Geometry.Vertex)">
            <summary>
            Tests whether a point lies in the circumcircle of this face.  Used during delaunay
            triangulation on the XY plane.
            Currently works only for triangle faces which are counterclockwise on XY plane.
            Hence declared internal until it can be made more robust.
            </summary>
            <param name="point">The position vector to test</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Meshing.DelaunayTriangle.GenerateSuperTriangleXY(Nucleus.Geometry.BoundingBox)">
            <summary>
            Generate a triangular mesh face that encompasses the specified bounding box
            Used as the initial stage of delaunary triangulation.
            The triangle will be created using temporary vertices that will not be added to
            the vertices of this mesh.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Meshing.MeshBuilder">
            <summary>
            Builder object for Nucleus meshes
            </summary>
        </member>
        <member name="T:Nucleus.Meshing.MeshBuilderBase">
            <summary>
            An abstract base class used to generically construct meshes in an application-specific format
            </summary>
        </member>
        <member name="P:Nucleus.Meshing.MeshBuilderBase.FacetAngle">
            <summary>
            The limiting angle to be used when facetting curves for meshing
            </summary>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.Finalize">
            <summary>
            Finalize the mesh building.
            Will apply any necessary last steps to the mesh generation.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddVertex(Nucleus.Geometry.Vector)">
            <summary>
            Add a new vertex to the mesh
            </summary>
            <param name="pt"></param>
            <returns>The new vertex index</returns>
            <remarks>The returned vertex indices should be sequential</remarks>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddVertex(Nucleus.Geometry.Vertex)">
            <summary>
            Add a new vertex to the mesh.
            This operation will set the VertexIndex property of the vertex.
            </summary>
            <param name="v"></param>
            <returns>The new vertex index</returns>
            <remarks>The returned indices should be sequential and the 
            VertexIndex property of the input vertex should be set.</remarks> 
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddFace(System.Int32,System.Int32,System.Int32)">
            <summary>
            Add a new tri face to the mesh.
            By default, the winding order is counter-clockwise.
            </summary>
            <param name="v1">The first vertex index</param>
            <param name="v2">The second vertex index</param>
            <param name="v3">The third vertex index</param>
            <returns>The new face index</returns>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddFace(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Add a new quad face to the mesh.
            By default, the winding order is counter-clockwise.
            </summary>
            <param name="v1">The first vertex index</param>
            <param name="v2">The second vertex index</param>
            <param name="v3">The third vertex index</param>
            <param name="v4">The fourth vertex index</param>
            <returns>The new face index</returns>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddFace(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Add a new tri face to the mesh
            </summary>
            <param name="pt1"></param>
            <param name="pt2"></param>
            <param name="pt3"></param>
            <returns>The new face index</returns>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddFace(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Add a new quad face to the mesh
            </summary>
            <param name="pt1"></param>
            <param name="pt2"></param>
            <param name="pt3"></param>
            <param name="pt4"></param>
            <returns>The new face index</returns>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddFace(Nucleus.Geometry.MeshFace)">
            <summary>
            Add a new face to the mesh.
            The vertices within this face should have already had their indices set
            </summary>
            <param name="face"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddFace(System.Collections.Generic.IList{System.Int32})">
            <summary>
            Add a new mesh face specified by an ordered list of vertex indices
            </summary>
            <param name="indices">A list of vertex indices to be converted into a face.  Should contain at least three values.</param>
            <returns>The new face index, or -1 if there were insufficient indices to build a face</returns>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddVertices(System.Collections.Generic.IEnumerable{Nucleus.Geometry.Vector})">
            <summary>
            Add a set of points to the mesh as new vertices
            </summary>
            <param name="points">The points to be added as vertices</param>
            <returns>The vertex index of the last added point</returns>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddVertices(System.Collections.Generic.IEnumerable{Nucleus.Geometry.Vertex})">
            <summary>
            Add a set of vertices to the mesh
            </summary>
            <param name="vertices"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddFaces(System.Collections.Generic.IEnumerable{System.Collections.Generic.IList{System.Int32}})">
            <summary>
            Add a set of faces to the mesh described as a set of Lists of vertex indices
            </summary>
            <param name="faces">The collection of lists of vertex indices to be used to describe the face topology</param>
            <returns>The face index of the last valid added face</returns>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddFaces(System.Collections.Generic.IEnumerable{Nucleus.Geometry.MeshFace})">
            <summary>
            Add a set of faces to the mesh.
            The vertices referenced by these faces should have been previously
            added and the vertex indices set.
            </summary>
            <param name="faces"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddMesh(Nucleus.Geometry.Mesh)">
            <summary>
            Add a Nucleus mesh to the mesh.
            Copies of the input mesh vertices and faces will be appended
            to those already existing in the current mesh.
            </summary>
            <param name="mesh"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddExtrusion(Nucleus.Geometry.Extrusion)">
            <summary>
            Add vertices and faces to the mesh to represent an extrusion solid.
            </summary>
            <param name="extrusion"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddCuboid(System.Double,System.Double,System.Double,Nucleus.Geometry.CartesianCoordinateSystem)">
            <summary>
            Add vertices and faces to the mesh to represent a cuboid of the specified dimensions,
            with its base on the XY plane of the specified coordinate system.
            </summary>
            <param name="width">The width of the cuboid</param>
            <param name="depth">The depth of the cuboid</param>
            <param name="height">The height of the cuboid</param>
            <param name="cSystem"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddTruncatedPyramid(System.Double,System.Double,System.Double,System.Double,System.Double,Nucleus.Geometry.CartesianCoordinateSystem)">
            <summary>
            Add vertices and faces to the mesh to represent a flat-topped pyramid of the specified dimensions,
            with its base on the XY plane of the specified coordinate system.
            </summary>
            <param name="baseWidth"></param>
            <param name="baseDepth"></param>
            <param name="height"></param>
            <param name="cSystem"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddLoft(System.Collections.Generic.IList{System.Collections.Generic.IList{Nucleus.Geometry.Vector}},System.Boolean,System.Boolean)">
            <summary>
            Add strips of faces swept between a set of polylines defined as point lists
            </summary>
            <param name="pointLists">A list of lists of points representing polylines.  Each list should have the same number of points contained within.</param>
            <param name="close">If true, the ends of the points lists will also be joined to form a 'tube'</param>
            <param name="flip">If true, the orientation of the mesh faces produced will be reversed (such that normals point in the opposite direction)</param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddSweep(System.Collections.Generic.IList{Nucleus.Geometry.CartesianCoordinateSystem},System.Collections.Generic.IList{Nucleus.Geometry.Vector},System.Boolean)">
            <summary>
            Add strips of faces sweep between lines of points lying on a set of frames
            </summary>
            <param name="frames">A set of coordinate systems representing frames to be swept between</param>
            <param name="pointStrip">A polyline of points in frame-coordinates that will be used to create vertices on each frame</param>
            <param name="close">If true, the strip of points will be closed (i.e. the last point in each strip will be meshed with the first)</param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddSweep(System.Collections.Generic.IList{Nucleus.Geometry.CartesianCoordinateSystem},Nucleus.Geometry.Curve,Nucleus.Meshing.CoordinateSystemRemappingOption)">
            <summary>
            Add a set of faces generated by sweeping a curve between a set of frames.
            </summary>
            <param name="frames">The local coordinate frames between which faces will be swept</param>
            <param name="profile">The curve to sweep.</param>
            <param name="useYZ"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.FillStartToEnd(System.Collections.Generic.IList{Nucleus.Geometry.Vector},System.Int32)">
            <summary>
            Create faces out of points from the specified list, starting by joining the start points to the end points
            and moving towards the middle of the list
            </summary>
            <param name="pointStrip"></param>
            <param name="startOffset"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.FillStartToEndReverse(System.Collections.Generic.IList{Nucleus.Geometry.Vector},System.Int32)">
            <summary>
            Create faces out of points from the specified list, starting by joining the start points to the end points
            and moving towards the middle of the list
            </summary>
            <param name="pointStrip"></param>
            <param name="startOffset"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.FillBetween(System.Collections.Generic.IList{Nucleus.Geometry.Vector},System.Collections.Generic.IList{Nucleus.Geometry.Vector},System.Boolean,System.Boolean)">
            <summary>
            Create faces by filling between matching indices in two lists of points.
            </summary>
            <param name="pointStrip1">The first set of points</param>
            <param name="pointStrip2">The second set of points</param>
            <param name="reverse">If true, the second set of points will be reversed</param>
            <param name="close">If true, an additional face will be added closing the loop</param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddWidePath(Nucleus.Geometry.IWidePath,Nucleus.Geometry.Vector)">
            <summary>
            Create faces to represent a path with width
            </summary>
            <param name="path">The path to add to the mesh</param>
            <param name="extrude">An optional extrusion vector.  If non-zero the
            path will be extruded along this vector in order to procude a mesh
            with thickness.</param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddModel(Nucleus.Model.Model)">
            <summary>
            Display a model geometry as 3D element section and panel
            mesh geometry
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddSectionPreviews(Nucleus.Model.LinearElementCollection)">
            <summary>
            Add mesh vertices and faces representing the section profiles of the given set of linear elements
            </summary>
            <param name="elements"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddSectionPreview(Nucleus.Model.LinearElement)">
            <summary>
            Add a set of vertices and faces to this mesh representing the given element complete with
            a 3D representation of the assigned section profile
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddSectionPreview(Nucleus.Geometry.Curve,Nucleus.Model.SectionFamily,Nucleus.Geometry.Angle)">
            <summary>
            Add a set of vertices and faces to the mesh representing a sweep of the specified section
            along the specified curve with the specified orientation
            </summary>
            <param name="geometry"></param>
            <param name="section"></param>
            <param name="orientation"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddPanelPreviews(Nucleus.Model.PanelElementCollection)">
            <summary>
            Add a set of vertices and faces to the mesh representing a collection of panels with thickness
            </summary>
            <param name="elements"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddPanelPreview(Nucleus.Model.PanelElement)">
            <summary>
            Add a set of vertices and faces to the mesh representing a panel with thickness
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddPanelPreview(Nucleus.Geometry.Surface,Nucleus.Model.BuildUpFamily)">
            <summary>
            Add a set of vertices and faces to the mesh representing a panel with thickness.
            </summary>
            <param name="geometry"></param>
            <param name="family"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddFamilyPreview(Nucleus.Model.Element)">
            <summary>
            Add a set of vertices and faces to the mesh representing the specified element's
            solid geometry.
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddPlanarRegion(Nucleus.Geometry.PlanarRegion,System.Double,System.Double,System.Boolean,Nucleus.Geometry.Vector)">
            <summary>
            Add a set of vertices and faces to the mesh representing a planar region with optional thickness
            </summary>
            <param name="region"></param>
            <param name="thickness"></param>
            <param name="autoFlip">Automatically flip normals to make them outside/upside</param>
            <param name="topOffset"></param>
            <param name="offset"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddPlanarRegion(Nucleus.Geometry.PlanarRegion,Nucleus.Geometry.Vector,System.Boolean,Nucleus.Geometry.Vector)">
            <summary>
            Add a set of vertices and faces to the mesh representing a planar region with optional thickness
            </summary>
            <param name="region">The region to add</param>
            <param name="path">The path to extrude the region along</param>
            <param name="autoFlip">Automatically flip normals to make them outside/upside</param>
            <param name="offset">The offset of the mesh from the region</param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddPlanarRegion(Nucleus.Geometry.PlanarRegion,Nucleus.Geometry.Vector,System.Double,System.Double,System.Boolean,Nucleus.Geometry.Vector)">
            <summary>
            Add a set of vertices and faces to the mesh representing a planar region with optional thickness
            </summary>
            <param name="region"></param>
            <param name="path">The path to extrude the region along</param>
            <param name="thickness"></param>
            <param name="topOffset"></param>
            <param name="autoFlip">Automatically flip normals to make them outside/upside</param>
            <param name="offset"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddCone(Nucleus.Geometry.Vector,Nucleus.Geometry.Circle,System.Int32)">
            <summary>
            Add a set of vertices and faces to this mesh representing a cone
            </summary>
            <param name="tip">The point at the tip of the cone</param>
            <param name="baseCircle">The base circle of the cone</param>
            <param name="baseResolution">The number of positions around the cone where mesh facets will be generated.</param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddFacetCone(Nucleus.Geometry.Vector,Nucleus.Geometry.Circle,System.Int32)">
            <summary>
            Add a set of vertices and faces to this mesh representing a facetted cone
            </summary>
            <param name="tip"></param>
            <param name="baseCircle"></param>
            <param name="baseResolution"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddCylinder(Nucleus.Geometry.Circle,System.Double,System.Int32)">
            <summary>
            Add a set of vertices and faces to this mesh representing a cylinder
            by extruding a circle
            </summary>
            <param name="baseCircle">The base circle forming one end of the cylinder</param>
            <param name="height">The height of the cylinder - i.e. the extrusion distance of the
            base circle along it's own normal</param>
            <param name="resolution">The number of points around the circle at which to create
            vertices to define the cylinder.</param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddNodeSupport(Nucleus.Model.Node,Nucleus.Model.NodeSupport,System.Double)">
            <summary>
            Add a set of vertices and faces to this mesh representing a nodal support
            </summary>
            <param name="node"></param>
            <param name="support"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddLoad(Nucleus.Model.Loading.Load,System.Double,System.Double,Nucleus.Maths.IEvaluationContext)">
            <summary>
            Add vertices and faces to this mesh to represent the specified load.
            </summary>
            <param name="load">The load to be represented</param>
            <param name="factor">The scaling factor by which the load's value will be multiplied by in order
            to determine the length of the tail of load representations.</param>
            <param name="scale">The overall scaling factor to be applied to the parts of the geometry
            not dependent on the magnitude of the load (i.e. arrow head width, etc.)</param>
            <param name="context"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddArrow(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,System.Double,System.Double)">
            <summary>
            Add faces and vertices to the mesh to represent a flat arrow with a head and a tail.
            </summary>
            <param name="tip">The position of the tip of the arrow</param>
            <param name="direction">The direction that the arrow is pointing</param>
            <param name="sideways">A vector perpendicular to the direction vector in
            the plane of the arrow</param>
            <param name="length">A scaling factor applied to the direction of the arrow</param>
            <param name="width">A scaling factor to be applied to the sideways vector.
            The </param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddLineLoad(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,System.Double,System.Double,System.Double)">
            <summary>
            Add faces and vertices to the mesh to represent a line load via a planar mesh with a serrated
            leading edge:
            ______
            |    |
            VVVVVV
            </summary>
            <param name="start">The start point of application of the line load</param>
            <param name="end">The end point of application of the line load</param>
            <param name="direction">The direction of application of the line load</param>
            <param name="startLength">The length of the arrow tail at the start of the line</param>
            <param name="endLength">The length of the arrow tail and the end of the line</param>
            <param name="zigZagLength">The width of the zig-zag 'arrow heads'</param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddAreaLoad(Nucleus.Geometry.PlanarRegion,Nucleus.Geometry.Vector,System.Double,System.Double)">
            <summary>
            Add faces and vertices to the mesh to represent an area load applied over a specified planar
            region.
            </summary>
            <param name="region">The region to which the load is applied</param>
            <param name="direction">The direction of the load</param>
            <param name="length">The length of the arrows representing the load</param>
            <param name="zigZagLength"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddAreaLoad(Nucleus.Geometry.Mesh,Nucleus.Geometry.Vector,System.Double,System.Double)">
            <summary>
            Add faces and vertices to the mesh to represent an area load applied over a specified mesh
            region.
            </summary>
            <param name="region">The region to which the load is applied</param>
            <param name="direction">The direction of the load</param>
            <param name="length">The length of the arrows representing the load</param>
            <param name="zigZagLength"></param>
        </member>
        <member name="M:Nucleus.Meshing.MeshBuilderBase.AddQuadGridMesh(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,System.Int32,System.Int32)">
            <summary>
            Generate a regular grillage quad mesh
            </summary>
            <param name="origin">An origin point at which to start generating the grid</param>
            <param name="uAxis">A vector which descibes the displacement between each vertex 
            in the mesh in the first ('u') axis</param>
            <param name="vAxis">A vector which describes the displacement between each vertex
            in the mesh in the second ('v') axis</param>
            <param name="uCount">The number of vertices in the first ('u') direction.</param>
            <param name="vCount">The number of vertices in the second ('v') direction.</param>
        </member>
        <member name="T:Nucleus.Meshing.MeshBuilderBase`1">
            <summary>
            An abstract base class used to generically construct meshes in an application-specific format
            </summary>
            <typeparam name="TMesh">The type of mesh being generated</typeparam>
        </member>
        <member name="F:Nucleus.Meshing.MeshBuilderBase`1._Mesh">
            <summary>
            Protected backing field for Mesh property
            </summary>
        </member>
        <member name="P:Nucleus.Meshing.MeshBuilderBase`1.Mesh">
            <summary>
            The mesh that is being built
            </summary>
        </member>
        <member name="T:Nucleus.Model.AnalysisCase">
            <summary>
            A particular condition to be analysed.
            </summary>
        </member>
        <member name="F:Nucleus.Model.AnalysisCase._Task">
            <summary>
            Private backing member variable for the Task property
            </summary>
        </member>
        <member name="P:Nucleus.Model.AnalysisCase.Task">
            <summary>
            The analysis task to which this analysis case belongs
            </summary>
        </member>
        <member name="F:Nucleus.Model.AnalysisCase._LoadCase">
            <summary>
            Private backing member variable for the LoadCase property
            </summary>
        </member>
        <member name="P:Nucleus.Model.AnalysisCase.LoadCase">
            <summary>
            The load case which is to be analysed
            </summary>
        </member>
        <member name="T:Nucleus.Model.AnalysisCaseCollection">
            <summary>
            A collection of analysis cases
            </summary>
        </member>
        <member name="T:Nucleus.Model.AnalysisTask">
            <summary>
            An object which holds information about an analytical task which
            has been or is to be processed
            </summary>
        </member>
        <member name="T:Nucleus.Model.AnalysisTaskCollection">
            <summary>
            A collection of analysis tasks
            </summary>
        </member>
        <member name="T:Nucleus.Model.BuildUpFamilyCollection">
            <summary>
            A collection of build-up families
            </summary>
        </member>
        <member name="M:Nucleus.Model.BuildUpFamilyCollection.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Model.BuildUpFamilyCollection.#ctor(Nucleus.Model.BuildUpFamily)">
            <summary>
            Initialise a new BuildUpFamilyCollection containing the specified single item
            </summary>
            <param name="family"></param>
        </member>
        <member name="M:Nucleus.Model.BuildUpFamilyCollection.#ctor(System.Collections.Generic.IEnumerable{Nucleus.Model.BuildUpFamily})">
            <summary>
            Initialise a new BuildUpFamilyCollection containing the specified set of families
            </summary>
            <param name="families"></param>
        </member>
        <member name="T:Nucleus.Model.BuildUpLayer">
            <summary>
            Class representing a layer of a given material and thickness that forms
            part of the build-up definition of a Face Family
            </summary>
        </member>
        <member name="F:Nucleus.Model.BuildUpLayer._Thickness">
            <summary>
            Private backing field for Thickness property
            </summary>
        </member>
        <member name="P:Nucleus.Model.BuildUpLayer.Thickness">
            <summary>
            The thickness of the layer
            </summary>
        </member>
        <member name="F:Nucleus.Model.BuildUpLayer._Material">
            <summary>
            Private backing field for Material property
            </summary>
        </member>
        <member name="P:Nucleus.Model.BuildUpLayer.Material">
            <summary>
            The material that this layer is made of
            </summary>
        </member>
        <member name="F:Nucleus.Model.BuildUpLayer._Family">
            <summary>
            Private backing field for Family property
            </summary>
        </member>
        <member name="P:Nucleus.Model.BuildUpLayer.Family">
            <summary>
            The family that this layer is part of
            </summary>
        </member>
        <member name="M:Nucleus.Model.BuildUpLayer.#ctor">
            <summary>
            Initialise a new blank build-up layer
            </summary>
        </member>
        <member name="M:Nucleus.Model.BuildUpLayer.#ctor(System.Double,Nucleus.Model.Material)">
            <summary>
            Initialise a new build-up layer of the specified thickness and material
            </summary>
            <param name="thickness"></param>
            <param name="material"></param>
        </member>
        <member name="T:Nucleus.Model.BuildUpLayerCollection">
            <summary>
            A collection of BuildUpLayer objects
            </summary>
        </member>
        <member name="P:Nucleus.Model.BuildUpLayerCollection.TotalThickness">
            <summary>
            Get the total overall thickness of the build-up
            </summary>
        </member>
        <member name="M:Nucleus.Model.BuildUpLayerCollection.#ctor">
            <summary>
            Initialise a new blank Build-Up Layer Collection
            </summary>
        </member>
        <member name="M:Nucleus.Model.BuildUpLayerCollection.#ctor(Nucleus.Model.BuildUpFamily)">
            <summary>
            Initialise a new blank Build-Up Layer Collection belonging to the specified family
            </summary>
            <param name="owner"></param>
        </member>
        <member name="M:Nucleus.Model.BuildUpLayerCollection.#ctor(Nucleus.Model.BuildUpLayer)">
            <summary>
            Initialise a new BuildUpLayerCollection containing the specified layer
            </summary>
            <param name="layer"></param>
        </member>
        <member name="T:Nucleus.Model.ConstraintElement">
            <summary>
            An element set out by a point cloud in space
            and whose 3D geometry consists of repeated block
            instances at each one of those points
            </summary>
        </member>
        <member name="M:Nucleus.Model.ConstraintElement.GetNominalPosition">
            <summary>
            Get a point in space which nominally describes the position of this element,
            to be used for display attachments and the like.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.ConstraintElementCollection">
            <summary>
            A collection of nodal constraint elements
            </summary>
        </member>
        <member name="T:Nucleus.Model.ConstraintFamily">
            <summary>
            A family which describes a rigid constraint between nodes
            in a structural or physical model
            </summary>
        </member>
        <member name="F:Nucleus.Model.ConstraintFamily._Fixity">
            <summary>
            Private backing field for Fixity property
            </summary>
        </member>
        <member name="P:Nucleus.Model.ConstraintFamily.Fixity">
            <summary>
            The lateral and rotational directions in which this node is
            fixed for the purpose of structural and physics-based analysis.
            Represented by a set of six booleans, one each for the X, Y, Z, 
            XX,YY and ZZ degrees of freedom.  If true, the node is restrained in
            that direction, if false it is free to move.
            </summary>
        </member>
        <member name="F:Nucleus.Model.ConstraintFamily._Axes">
            <summary>
            Private backing field for Axes property
            </summary>
        </member>
        <member name="P:Nucleus.Model.ConstraintFamily.Axes">
            <summary>
            The coordinate axis system to which the fixity directions refer
            </summary>
        </member>
        <member name="T:Nucleus.Model.CrossSectionClass">
            <summary>
            The classification of a profile cross-section, indicating the extent to which
            the resistance and rotation capacity of cross sections is limited by its local
            buckling resistance.
            </summary>
        </member>
        <member name="F:Nucleus.Model.CrossSectionClass.Indeterminate">
            <summary>
            The cross-section type has not been or cannot be determined
            </summary>
        </member>
        <member name="F:Nucleus.Model.CrossSectionClass.One">
            <summary>
            Class 1 cross-sections are those which can form
            a plastic hinge with the rotation capacity required from plastic analysis
            without reduction of the resistance.
            </summary>
        </member>
        <member name="F:Nucleus.Model.CrossSectionClass.Two">
            <summary>
            Class 2 cross-sections are those that can develop their plastic moment 
            resistance, but have limited rotation capacity because of local buckling.
            </summary>
        </member>
        <member name="F:Nucleus.Model.CrossSectionClass.Three">
            <summary>
            Class 3 cross-sections are those in which the stress in the extreme 
            compression fibre of the steel (or aluminium) member assuming an elastic 
            distribution of stresses can reach the yield strength, but local buckling 
            is liable to prevent development of the plastic moment resistance. 
            </summary>
        </member>
        <member name="F:Nucleus.Model.CrossSectionClass.Four">
            <summary>
            Class 4 cross-sections are those in which local buckling will occur 
            before the attainment of yield stress in one or more parts of the cross-section.
            </summary>
        </member>
        <member name="T:Nucleus.Model.DesignCase">
            <summary>
            Abstract base class for cases which represent a design situation.
            This encompasses load cases which define a particular set of physical
            loads to be applied to a model and results cases which represent the
            input data for a particular analysis run which produces results
            </summary>
        </member>
        <member name="T:Nucleus.Model.DesignCaseCollection">
            <summary>
            A collection of Design cases
            </summary>
        </member>
        <member name="T:Nucleus.Model.ElementGender">
            <summary>
            Data component to represent the gender of an element
            </summary>
        </member>
        <member name="F:Nucleus.Model.ElementGender._Gender">
            <summary>
            Private backing member variable for the Gender property
            </summary>
        </member>
        <member name="P:Nucleus.Model.ElementGender.Gender">
            <summary>
            The gender of the element
            </summary>
        </member>
        <member name="M:Nucleus.Model.ElementGender.#ctor">
            <summary>
            Initialise a neutral gender
            </summary>
        </member>
        <member name="M:Nucleus.Model.ElementGender.#ctor(Nucleus.Base.Gender)">
            <summary>
            Initialise with the specified gender
            </summary>
            <param name="gender"></param>
        </member>
        <member name="T:Nucleus.Model.ElementUse">
            <summary>
            A description of the usage of an element.
            A tag used to indicate what a model element represents
            </summary>
        </member>
        <member name="F:Nucleus.Model.ElementUse.Beam">
            <summary>
            The element represents a structural beam
            </summary>
        </member>
        <member name="F:Nucleus.Model.ElementUse.Column">
            <summary>
            The element represents a structural column
            </summary>
        </member>
        <member name="F:Nucleus.Model.ElementUse.Brace">
            <summary>
            The element represents structural bracing
            </summary>
        </member>
        <member name="F:Nucleus.Model.ElementUse.Slab">
            <summary>
            The element represents a structural slab
            </summary>
        </member>
        <member name="F:Nucleus.Model.ElementUse.Wall">
            <summary>
            The element represents a structural wall
            </summary>
        </member>
        <member name="F:Nucleus.Model.ElementUse._Name">
            <summary>
            Private backing member variable for the Name property
            </summary>
        </member>
        <member name="P:Nucleus.Model.ElementUse.Name">
            <summary>
            The name of the ElementUse tag.  Two ElementUse tags are assumed to be equal if their names match.
            </summary>
        </member>
        <member name="M:Nucleus.Model.ElementUse.#ctor(System.String)">
            <summary>
            Initalise a new ElementUse with the specified name
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Nucleus.Model.ElementUse.Equals(Nucleus.Model.ElementUse)">
            <summary>
            IEquatable Equals implementation.
            Two ElementUses are equal if they share the same name.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.FactoredLoadCase">
            <summary>
            A load case multiplied by a scalar factor
            </summary>
        </member>
        <member name="M:Nucleus.Model.FactoredLoadCase.#ctor">
            <summary>
            Initialise an empty factored case.
            </summary>
        </member>
        <member name="M:Nucleus.Model.FactoredLoadCase.#ctor(Nucleus.Model.LoadCase)">
            <summary>
            Initialise a new FactoredCase with a factor of 1 and the
            speciifed case.
            </summary>
            <param name="lCase"></param>
        </member>
        <member name="M:Nucleus.Model.FactoredLoadCase.#ctor(System.Double,Nucleus.Model.LoadCase)">
            <summary>
            Initialise a new FactoredCase with the specifed factor
            and case.
            </summary>
            <param name="factor"></param>
            <param name="lCase"></param>
        </member>
        <member name="T:Nucleus.Model.FactoredLoadCaseCollection">
            <summary>
            A collection of factored load cases
            </summary>
        </member>
        <member name="T:Nucleus.Model.FamilyFilter`2">
            <summary>
            Generic base for filters that pass or fail based 
            on the assigned family of an element
            </summary>
            <typeparam name="TElement"></typeparam>
            <typeparam name="TFamily"></typeparam>
        </member>
        <member name="F:Nucleus.Model.FamilyFilter`2._Family">
            <summary>
            Private backing field for Family property
            </summary>
        </member>
        <member name="P:Nucleus.Model.FamilyFilter`2.Family">
            <summary>
            The family to filter by
            </summary>
        </member>
        <member name="M:Nucleus.Model.FamilyFilter`2.Pass(`0)">
            <summary>
            Does the specified item pass through this filter?
            </summary>
            <param name="item">The item to be tested</param>
            <returns>True if the item passes through the filter, false if not.</returns>
        </member>
        <member name="T:Nucleus.Model.FamilyFilter">
            <summary>
            Filter for elements which will pass if the element is assigned
            a specific family
            </summary>
        </member>
        <member name="M:Nucleus.Model.FamilyFilter.#ctor">
            <summary>
            Initialise a new blank FamilyFilter
            </summary>
        </member>
        <member name="M:Nucleus.Model.FamilyFilter.#ctor(Nucleus.Model.Family,System.Boolean)">
            <summary>
            Initialise a new FamilyFilter to pass elements
            with the specified family
            </summary>
            <param name="family"></param>
            <param name="invert"></param>
        </member>
        <member name="T:Nucleus.Model.BlockFamily">
            <summary>
            A family which describes a 3D block of geometry which is
            positioned according to a point in 3D space
            </summary>
        </member>
        <member name="F:Nucleus.Model.BlockFamily._Geometry">
            <summary>
            Private backing field for Geometry property
            </summary>
        </member>
        <member name="P:Nucleus.Model.BlockFamily.Geometry">
            <summary>
            The block base geometry
            </summary>
        </member>
        <member name="T:Nucleus.Model.ElementSet">
            <summary>
            A parametrically-defined set of elements.  
            Allows element collections to be defined via a base collection and a set of logical 
            filters which act upon that collection.
            </summary>
        </member>
        <member name="M:Nucleus.Model.ElementSet.#ctor">
            <summary>
            Create a new blank element set
            </summary>
        </member>
        <member name="M:Nucleus.Model.ElementSet.#ctor(System.String)">
            <summary>
            Create a new blank element set with the specified name
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Nucleus.Model.ElementSet.#ctor(System.Boolean)">
            <summary>
            Create a new 'all elements' set
            </summary>
            <param name="all"></param>
        </member>
        <member name="M:Nucleus.Model.ElementSet.#ctor(Nucleus.Model.Element)">
            <summary>
            Initialise this set to contain a single item
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Nucleus.Model.ElementSet.#ctor(Nucleus.Model.ElementCollection)">
            <summary>
            Initialise this set to contain the specified base collection of items
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Nucleus.Model.ElementSet.#ctor(Nucleus.Model.LinearElementCollection)">
            <summary>
            Initialise this set to contain the specified base collection of items
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Nucleus.Model.ElementSet.#ctor(Nucleus.Model.PanelElementCollection)">
            <summary>
            Initialise this set to contain the specified base collection of items
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Nucleus.Model.ElementSet.#ctor(Nucleus.Model.ElementSet)">
            <summary>
            Initialise a set to contain the items and filters from another set
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Nucleus.Model.ElementSet.#ctor(Nucleus.Model.LinearElementSet)">
            <summary>
            Initialise a set to contain the items and filters from another set
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Nucleus.Model.ElementSet.#ctor(Nucleus.Model.PanelElementSet)">
            <summary>
            Initialise a set to contain the items and filters from another set
            </summary>
            <param name="other"></param>
        </member>
        <member name="T:Nucleus.Model.ElementSet`1">
            <summary>
            Base class for ElementSet subtypes that automatically filter
            out items that are not of the specified subtype
            </summary>
            <typeparam name="TSubType"></typeparam>
        </member>
        <member name="M:Nucleus.Model.ElementSet`1.#ctor">
            <summary>
            Create a new blank element set
            </summary>
        </member>
        <member name="M:Nucleus.Model.ElementSet`1.#ctor(System.Boolean)">
            <summary>
            Create a new 'all elements' set
            </summary>
            <param name="all"></param>
        </member>
        <member name="M:Nucleus.Model.ElementSet`1.#ctor(Nucleus.Model.Element)">
            <summary>
            Initialise this set to contain a single item
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Nucleus.Model.ElementSet`1.#ctor(Nucleus.Model.ElementCollection)">
            <summary>
            Initialise this set to contain the specified base collection of items
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Nucleus.Model.ElementSet`1.#ctor(Nucleus.Model.Family)">
            <summary>
            Initialise this set to contain all elements in the model to which
            it belongs which are part of the specified element family
            </summary>
            <param name="family"></param>
        </member>
        <member name="T:Nucleus.Model.GlobalCoordinateSystemReference">
            <summary>
            A coordinate system reference that is used to indicate that the global coordinate system
            should be used.
            </summary>
        </member>
        <member name="F:Nucleus.Model.GlobalCoordinateSystemReference.Instance">
            <summary>
            The single static instance that should be used to refer to the global coordinate system
            </summary>
        </member>
        <member name="P:Nucleus.Model.GlobalCoordinateSystemReference.IsGlobal">
            <summary>
            Does this object represent the global coordinate system?
            Yes, it does - will always return true.
            </summary>
        </member>
        <member name="M:Nucleus.Model.GlobalCoordinateSystemReference.#ctor">
            <summary>
            Private constructor
            </summary>
        </member>
        <member name="M:Nucleus.Model.GlobalCoordinateSystemReference.GetCoordinateSystem(Nucleus.Model.ModelObject)">
            <summary>
            Get the coordinate system defined by this object as applicable to the specified object
            </summary>
            <param name="onObject">The object to which the coordinate system should relate.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.GlobalCoordinateSystemReference.GetCoordinateSystem(Nucleus.Model.LinearElement,System.Double)">
            <summary>
            Get the coordinate system defined by this object for the specified position along a linear element
            </summary>
            <param name="element">The linear element the coordinate system relates to</param>
            <param name="t">The position along the linear element that the coordinate system relates to</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.GlobalCoordinateSystemReference.Equals(System.Object)">
            <summary>
            Any instance of a global coordinate system will evaluate as equal to any other.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.ILoadCase">
            <summary>
            Interface for objects which represent a loading case
            </summary>
        </member>
        <member name="M:Nucleus.Model.ILoadCase.Contains(Nucleus.Model.Loading.Load)">
            <summary>
            Does this case contain the specified load?
            </summary>
            <param name="load"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.IMaterialDataComponent">
            <summary>
            Interface for data component objects which may be attached
            to a material
            </summary>
        </member>
        <member name="T:Nucleus.Model.IModelObjectSet">
            <summary>
            An interface for sets of Model Objects
            </summary>
        </member>
        <member name="M:Nucleus.Model.IModelObjectSet.GetItems">
            <summary>
            Get the final set of items contained within this set, consisting of all items in the base collection
            and any subsets (or all items in the model if 'All' is true) that pass all filters specified via the
            Filters property.
            </summary>
        </member>
        <member name="M:Nucleus.Model.IModelObjectSet.Add(Nucleus.Model.ModelObject)">
            <summary>
            Add an item to the base collection of this set.
            If the specified item is not a valid type for this set, adding it will
            fail and this function will return false.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.IModelObjectSet.Contains(Nucleus.Model.ModelObject)">
            <summary>
            Does this set contain the specified item?
            (or, would it, if they were part of the same model?)
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.IModelObjectTable">
            <summary>
            Interface for tables of objects, which form the top-level storage mechanism
            for 
            </summary>
        </member>
        <member name="P:Nucleus.Model.IModelObjectTable.NextNumericID">
            <summary>
            Get the next available numeric ID for items in this table
            </summary>
        </member>
        <member name="T:Nucleus.Model.IsoMaterial">
            <summary>
            A material with isotropic properties
            </summary>
        </member>
        <member name="F:Nucleus.Model.IsoMaterial._E">
            <summary>
            Private backing field for E property
            </summary>
        </member>
        <member name="P:Nucleus.Model.IsoMaterial.E">
            <summary>
            The Elastic (or, Young's) Modulus of this material,
            in N/m²
            </summary>
        </member>
        <member name="F:Nucleus.Model.IsoMaterial._PoissonsRatio">
            <summary>
            Private backing field for PoissonsRatio property
            </summary>
        </member>
        <member name="P:Nucleus.Model.IsoMaterial.PoissonsRatio">
            <summary>
            The Poisson's Ratio of this material.
            Unitless.
            </summary>
        </member>
        <member name="F:Nucleus.Model.IsoMaterial._G">
            <summary>
            Private backing field for G property
            </summary>
        </member>
        <member name="P:Nucleus.Model.IsoMaterial.G">
            <summary>
            The Shear Modulus of this material.  In N/m².
            If this is set lower or equal to zero, the
            return value will be automatically calculated from
            the Elastic Modulus and Poisson's Ratio via the formula
            E / (2v + 2).
            </summary>
        </member>
        <member name="F:Nucleus.Model.IsoMaterial._Alpha">
            <summary>
            Private backing field for Alpha property
            </summary>
        </member>
        <member name="P:Nucleus.Model.IsoMaterial.Alpha">
            <summary>
            The coefficient of thermal expansion of this material,
            in /°C
            </summary>
        </member>
        <member name="F:Nucleus.Model.IsoMaterial._YieldStrength">
            <summary>
            Private backing field for yield strength
            </summary>
        </member>
        <member name="P:Nucleus.Model.IsoMaterial.YieldStrength">
            <summary>
            The yield strength of this material, in Pa
            </summary>
        </member>
        <member name="M:Nucleus.Model.IsoMaterial.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Model.IsoMaterial.#ctor(System.String,Nucleus.Model.MaterialCategory)">
            <summary>
            Name constructor
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Nucleus.Model.IsoMaterial.GetE(Nucleus.Geometry.Direction)">
            <summary>
            Get the Elastic (or, Young's) Modulus of this material
            in the specified direction, in N/m²
            </summary>
        </member>
        <member name="M:Nucleus.Model.IsoMaterial.GetYieldStrength(Nucleus.Geometry.Direction)">
            <summary>
            Get the yield strength of this material in the specified
            direction, in Pa.
            </summary>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.IDataOwner">
            <summary>
            An interface for objects which own data stores
            </summary>
        </member>
        <member name="M:Nucleus.Model.IDataOwner.NotifyComponentPropertyChanged(System.Object,System.String)">
            <summary>
            Notify this owner that a property of a data component has been changed.
            This may then be 'bubbled' upwards with a new event.
            </summary>
            <param name="component"></param>
            <param name="propertyName"></param>
        </member>
        <member name="M:Nucleus.Model.IDataOwner.AllAttachedDataComponents">
            <summary>
            Get a flat list of all data components currently attached to this object
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.IDataOwnerExtensions">
            <summary>
            Extension methods for the IDataOwner interface
            </summary>
        </member>
        <member name="M:Nucleus.Model.IDataOwnerExtensions.AllAttachedDataComponents``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Get a flat list containing all unique data components attached to objects in this collection
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.IDataOwnerExtensions.AllAttachedDataTypes``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Get a flat list containing all unique types of data components attached to the
            objects in this collection
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.IVertexDataComponent">
            <summary>
            Interface for data components which may be attached to Vertices
            </summary>
        </member>
        <member name="T:Nucleus.Model.LoadCaseTable">
            <summary>
            A table of load cases, providing the top-level representation of
            structural loading in the model
            </summary>
        </member>
        <member name="M:Nucleus.Model.LoadCaseTable.#ctor(Nucleus.Model.Model)">
            <summary>
            Initialise a new LoadCaseTable belonging to the specified model
            </summary>
            <param name="model"></param>
        </member>
        <member name="T:Nucleus.Model.LoadCaseType">
            <summary>
            Enumerated value representing the different possible types of
            a structural load case
            </summary>
        </member>
        <member name="F:Nucleus.Model.LoadCaseType.Undefined">
            <summary>
            The type of load is undefined
            </summary>
        </member>
        <member name="F:Nucleus.Model.LoadCaseType.Dead">
            <summary>
            The load is static and is unlikely to change significantly
            within the life of the structure
            </summary>
        </member>
        <member name="F:Nucleus.Model.LoadCaseType.Live">
            <summary>
            The load is imposed and may vary significantly during operation
            of the structure
            </summary>
        </member>
        <member name="F:Nucleus.Model.LoadCaseType.Accidental">
            <summary>
            The load is an accidental load due to causes such as explosion, impact, etc.
            </summary>
        </member>
        <member name="F:Nucleus.Model.LoadCaseType.Wind">
            <summary>
            The load is due to wind action on the structure
            </summary>
        </member>
        <member name="F:Nucleus.Model.LoadCaseType.Seismic">
            <summary>
            The load is induced by seismic movements
            </summary>
        </member>
        <member name="F:Nucleus.Model.LoadCaseType.Thermal">
            <summary>
            The load is induced by changes in temperature in the structure
            </summary>
        </member>
        <member name="T:Nucleus.Model.LoadCombinationCase">
            <summary>
            A combination of load cases
            </summary>
        </member>
        <member name="F:Nucleus.Model.LoadCombinationCase._GUID">
            <summary>
            Private backing field for GUID property
            </summary>
        </member>
        <member name="P:Nucleus.Model.LoadCombinationCase.GUID">
            <summary>
            The GUID of this object, which can be used to uniquely identify it. 
            </summary>
        </member>
        <member name="T:Nucleus.Model.Loading.AreaLoad">
            <summary>
            A force load applied over a particular planar region
            </summary>
        </member>
        <member name="F:Nucleus.Model.Loading.AreaLoad._AppliedOver">
            <summary>
            Private backing field for AppliedOver property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Loading.AreaLoad.AppliedOver">
            <summary>
            The region over which the load is applied.
            If this is not specified, the load is assumed to apply
            directly over the entire surface of any specified panel
            elements, but not at all to linear elements.
            </summary>
        </member>
        <member name="M:Nucleus.Model.Loading.AreaLoad.#ctor">
            <summary>
            Default constructor.  Initialises a new blank area load.
            </summary>
        </member>
        <member name="M:Nucleus.Model.Loading.AreaLoad.#ctor(Nucleus.Geometry.PlanarRegion,Nucleus.Model.ElementCollection)">
            <summary>
            Initialise a new area load over the specified area to be resolved to the
            specified elements.
            </summary>
            <param name="appliedOver"></param>
            <param name="appliedTo"></param>
        </member>
        <member name="T:Nucleus.Model.Loading.LinearElementPointLoad">
            <summary>
            A point load applied to a linear element
            </summary>
        </member>
        <member name="F:Nucleus.Model.Loading.LinearElementPointLoad._Position">
            <summary>
            Private backing field for point load position.
            </summary>
        </member>
        <member name="P:Nucleus.Model.Loading.LinearElementPointLoad.Position">
            <summary>
            The position of the point load along the element.
            By default (when Relative = true), this is a relative position 
            along the element where
            0 = the element start and 1 = the element end.
            Otherwise (when Relative = false) it is an absolute distance
            value from the element start.
            </summary>
        </member>
        <member name="F:Nucleus.Model.Loading.LinearElementPointLoad._Relative">
            <summary>
            Private backing field for 'Relative' property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Loading.LinearElementPointLoad.Relative">
            <summary>
            Is the position of this point load defined relatively?
            If true (default) the Position property refers to a 
            relative position along the element where
            0 = the element start and 1 = the element end.
            Otherwise (when Relative = false) it is an absolute distance
            value from the element start.
            </summary>
        </member>
        <member name="M:Nucleus.Model.Loading.LinearElementPointLoad.SetPosition(Nucleus.Geometry.Curve,Nucleus.Geometry.Vector)">
            <summary>
            Set the position of this point load to to represent the
            closest point on a curve to a point
            </summary>
            <param name="onCurve"></param>
            <param name="closestTo"></param>
        </member>
        <member name="M:Nucleus.Model.Loading.LinearElementPointLoad.SetPosition(Nucleus.Model.LinearElement,Nucleus.Geometry.Vector)">
            <summary>
            Set the position of this point load to represent the
            closest point on the specified linear element to
            a point
            </summary>
            <param name="element"></param>
            <param name="closestTo"></param>
        </member>
        <member name="M:Nucleus.Model.Loading.LinearElementPointLoad.SimpleBeamMoment(System.Double,System.Double)">
            <summary>
            Calculate the moment induced in a simply supported beam
            by this point load at a given position x along a member
            of length l
            </summary>
            <param name="x"></param>
            <param name="l"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.Loading.PanelLoad">
            <summary>
            A force load applied directly to the faces of panel elements
            </summary>
        </member>
        <member name="M:Nucleus.Model.Loading.PanelLoad.#ctor">
            <summary>
            Default constructor.  Initialises a new blank area load.
            </summary>
        </member>
        <member name="M:Nucleus.Model.Loading.PanelLoad.#ctor(Nucleus.Model.ElementCollection)">
            <summary>
            Initialise a new area load over the specified area to be resolved to the
            specified elements.
            </summary>
            <param name="appliedOver"></param>
            <param name="appliedTo"></param>
        </member>
        <member name="T:Nucleus.Model.Loading.GravityLoad">
            <summary>
            A Gravity load which is applied to elements and generates a force
            based on an acceleration and the individual mass of those elements
            </summary>
        </member>
        <member name="M:Nucleus.Model.Loading.GravityLoad.#ctor">
            <summary>
            Initialise a new gravity load with the default properties
            </summary>
        </member>
        <member name="M:Nucleus.Model.Loading.GravityLoad.GravityVector">
            <summary>
            Get a vector which describes the direction and magnitude
            of the gravity load.  The default evaluation context will be used.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.Loading.LinearElementLoad">
            <summary>
            A force load that is applied along linear elements
            </summary>
        </member>
        <member name="P:Nucleus.Model.Loading.LinearElementLoad.Distribution">
            <summary>
            The distribution of the applied load along each element,
            stored as a multiplication factor for the base value mapped against a
            normalised length along the element.
            By default, this distribution contains a single value of 1.0, representing
            a uniformly distributed load with a scaling factor of 1.
            </summary>
            <remarks>Currently not possible to have sudden stops... fix?</remarks>
        </member>
        <member name="M:Nucleus.Model.Loading.LinearElementLoad.SetUniform(System.Double)">
            <summary>
            Set this load to have a uniform distribution along the element
            </summary>
            <param name="scalingFactor"></param>
        </member>
        <member name="T:Nucleus.Model.Loading.ForceLoad`2">
            <summary>
            Abstract base class for structural and physical load types that act in a particular
            direction.
            </summary>
            <typeparam name="TAppliedTo"></typeparam>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="F:Nucleus.Model.Loading.ForceLoad`2._Direction">
            <summary>
            Private backing field for Direction property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Loading.ForceLoad`2.Direction">
            <summary>
            The axis (of the coordinate system specified by the Axes property)
            along which or about which this force is applied
            </summary>
        </member>
        <member name="P:Nucleus.Model.Loading.ForceLoad`2.IsMoment">
            <summary>
            Is this force applied as a moment?
            (i.e. is the Direction a rotational one)
            </summary>
        </member>
        <member name="F:Nucleus.Model.Loading.ForceLoad`2._Axes">
            <summary>
            Private backing field for Axes property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Loading.ForceLoad`2.Axes">
            <summary>
            The reference system used to resolve the application of the load
            in 3D space.  The direction property determines which axis of this
            system is used.
            </summary>
        </member>
        <member name="M:Nucleus.Model.Loading.ForceLoad`2.SetForce(Nucleus.Geometry.Vector)">
            <summary>
            Set the force exerted by this load by specifying the force vector.
            The direction, axis system and value will be derived from this information.
            </summary>
            <param name="forceVector"></param>
        </member>
        <member name="M:Nucleus.Model.Loading.ForceLoad`2.SetForce(Nucleus.Geometry.Vector,System.Double)">
            <summary>
            Set the force exerted by this load by specifying a direction vector and
            a value.  The direction and axis system will be derived from this information.
            </summary>
            <param name="direction"></param>
            <param name="value"></param>
        </member>
        <member name="M:Nucleus.Model.Loading.ForceLoad`2.GetDirectionVector(`1)">
            <summary>
            Get the direction vector which describes the axis about or around which this force is
            applied.
            </summary>
            <param name="forObject"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.Loading.NodeLoad">
            <summary>
            A force load applied directly to a set of nodes
            </summary>
        </member>
        <member name="T:Nucleus.Model.Loading.ThermalLoad">
            <summary>
            A load acting on an element due to a change in temperature
            </summary>
        </member>
        <member name="T:Nucleus.Model.Loading.Load">
            <summary>
            Abstract base class for objects which represent a load of some kind applied to the model to
            be considered during analysis.
            </summary>
        </member>
        <member name="F:Nucleus.Model.Loading.Load._Case">
            <summary>
            Private backing field for Case property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Loading.Load.Case">
            <summary>
            The load case to which this load belongs
            </summary>
        </member>
        <member name="F:Nucleus.Model.Loading.Load._Value">
            <summary>
            Private backing field for Value property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Loading.Load.Value">
            <summary>
            The value of the load
            </summary>
        </member>
        <member name="M:Nucleus.Model.Loading.Load.IsAppliedTo(Nucleus.Model.ModelObject)">
            <summary>
            Is this load applied to the specified model object?
            </summary>
            <param name="mObj"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Loading.Load.CanApplyToType(System.Type)">
            <summary>
            Test whether this load can be applied to an object of the
            specified type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Loading.Load.ApplyTo(Nucleus.Model.ModelObject)">
            <summary>
            Apply this load to an object, if possible
            </summary>
            <param name="mObj"></param>
            <returns>True if the load could be applied.</returns>
        </member>
        <member name="T:Nucleus.Model.Loading.Load`2">
            <summary>
            Generic abstract base class for objects which represent a load of some kind applied to the model
            to be considered during an analysis
            </summary>
            <typeparam name="TAppliedTo">The type of the set of objects to which this load can be applied</typeparam>
        </member>
        <member name="F:Nucleus.Model.Loading.Load`2._AppliedTo">
            <summary>
            Private backing field for AppliedTo property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Loading.Load`2.AppliedTo">
            <summary>
            The set of objects that this load is applied to
            </summary>
        </member>
        <member name="M:Nucleus.Model.Loading.Load`2.OnDeserialized(System.Runtime.Serialization.StreamingContext)">
            <summary>
            Called immediately after deserialisation to re-register all objects
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:Nucleus.Model.Loading.Load`2.IsAppliedTo(Nucleus.Model.ModelObject)">
            <summary>
            Is this load applied to the specified model object?
            </summary>
            <param name="mObj"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Loading.Load`2.CanApplyToType(System.Type)">
            <summary>
            Test whether this load can be applied to an object of the
            specified type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Loading.Load`2.ApplyTo(Nucleus.Model.ModelObject)">
            <summary>
            Apply this load to the specified object, if possible.
            </summary>
            <param name="mObj"></param>
            <returns>True on success, else false.</returns>
        </member>
        <member name="M:Nucleus.Model.Loading.Load`2.GetValueUnits">
            <summary>
            Get a string which descibes the units in which this load's
            value is expressed
            </summary>
        </member>
        <member name="T:Nucleus.Model.LoadTable">
            <summary>
            A collection of loads
            </summary>
        </member>
        <member name="T:Nucleus.Model.LocalCoordinateSystemReference">
            <summary>
            A coordinate system reference the use of which indicates that the local coordinate system
            of the element (or other object) in question should be used in place of a global or
            user-defined coordinate system.
            </summary>
        </member>
        <member name="F:Nucleus.Model.LocalCoordinateSystemReference.Instance">
            <summary>
            The single static instance that should be used to refer to the use of the local coordinate system
            </summary>
        </member>
        <member name="P:Nucleus.Model.LocalCoordinateSystemReference.IsLocal">
            <summary>
            Does this object represent a local coordinate system?
            Yes - it does!  Will always return true for this type.
            </summary>
        </member>
        <member name="M:Nucleus.Model.LocalCoordinateSystemReference.GetCoordinateSystem(Nucleus.Model.LinearElement,System.Double)">
            <summary>
            Get the coordinate system defined by this object for the specified position along a linear element
            </summary>
            <param name="element">The linear element the coordinate system relates to</param>
            <param name="t">The position along the linear element that the coordinate system relates to</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.CoordinateSystemReferenceCollection`1">
            <summary>
            Abstract base class for collections of coordinate system references
            </summary>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="M:Nucleus.Model.CoordinateSystemReferenceCollection`1.#ctor">
            <summary>
            Default constructor.  Initialises a new model object collection
            </summary>
        </member>
        <member name="M:Nucleus.Model.CoordinateSystemReferenceCollection`1.#ctor(Nucleus.Model.Model)">
            <summary>
            Owner constructor.  Initialises a model object collection with an owning model.
            </summary>
            <param name="model"></param>
        </member>
        <member name="T:Nucleus.Model.CoordinateSystemReferenceCollection">
            <summary>
            A collection of coordinate system references
            </summary>
        </member>
        <member name="M:Nucleus.Model.CoordinateSystemReferenceCollection.#ctor">
            <summary>
            Default constructor.  Initialises a new model object collection
            </summary>
        </member>
        <member name="M:Nucleus.Model.CoordinateSystemReferenceCollection.#ctor(Nucleus.Model.Model)">
            <summary>
            Owner constructor.  Initialises a model object collection with an owning model.
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Nucleus.Model.CoordinateSystemReferenceCollection.#ctor(Nucleus.Model.CoordinateSystemReference[])">
            <summary>
            Initialise a collection with the specified initial value(s)
            </summary>
            <param name="sysRef"></param>
        </member>
        <member name="T:Nucleus.Model.MaterialCategory">
            <summary>
            The category of a material.
            May be used to determine which design codes are
            applicable or to establish equivalent material
            properties in external packages.
            </summary>
        </member>
        <member name="F:Nucleus.Model.MaterialCategory.Undefined">
            <summary>
            The material category is not specified and
            may be a type of material not expressly covered
            by this enum.
            </summary>
        </member>
        <member name="F:Nucleus.Model.MaterialCategory.Steel">
            <summary>
            The material is a type of steel.
            </summary>
        </member>
        <member name="F:Nucleus.Model.MaterialCategory.Aluminium">
            <summary>
            The material is a type of aluminium.
            </summary>
        </member>
        <member name="F:Nucleus.Model.MaterialCategory.Concrete">
            <summary>
            The material is a type of concrete
            or reinforced concrete
            </summary>
        </member>
        <member name="F:Nucleus.Model.MaterialCategory.Wood">
            <summary>
            The material is a type of wood
            </summary>
        </member>
        <member name="F:Nucleus.Model.MaterialCategory.Glass">
            <summary>
            The material is a type of glass
            </summary>
        </member>
        <member name="T:Nucleus.Model.MaterialDataStore">
            <summary>
            A data storage mechanism for materials
            Stores data components keyed by type.
            </summary>
        </member>
        <member name="T:Nucleus.Model.ModelObjectSetTable">
            <summary>
            A table of ModelObjectSets to be stored in a Model
            </summary>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSetTable.#ctor(Nucleus.Model.Model)">
            <summary>
            Owner constructor.  Initialises a model object set collection with an owning model.
            </summary>
            <param name="model"></param>
        </member>
        <member name="T:Nucleus.Model.MultiElementVertex">
            <summary>
            A wrapper for combined vertices which form part of multiple elements' definitions, with
            properties set up to make the local properties easier to interrogate and set for all of those
            elements at once.
            This is a temporary object that is created when necessary and is not persisted
            beyond that.
            </summary>
        </member>
        <member name="F:Nucleus.Model.MultiElementVertex._Description">
            <summary>
            Private backing field for Description property
            </summary>
        </member>
        <member name="P:Nucleus.Model.MultiElementVertex.Description">
            <summary>
            The description of the position of this vertex relative to its parent element.
            Typically a number, "Start" or "End"
            </summary>
        </member>
        <member name="F:Nucleus.Model.MultiElementVertex._Elements">
            <summary>
            Private backing field for Elements properties
            </summary>
        </member>
        <member name="P:Nucleus.Model.MultiElementVertex.Elements">
            <summary>
            The elements that this vertex is linked to
            </summary>
        </member>
        <member name="F:Nucleus.Model.MultiElementVertex._Vertices">
            <summary>
            Private backing field for Vertices property
            </summary>
        </member>
        <member name="P:Nucleus.Model.MultiElementVertex.Vertices">
            <summary>
            The collection of vertices represented by this MultiElementVertex
            </summary>
        </member>
        <member name="P:Nucleus.Model.MultiElementVertex.Node">
            <summary>
            Get or set the node shared by all the element vertices this
            object represents.  If all vertices do not share the same node,
            null will be returned.
            </summary>
        </member>
        <member name="P:Nucleus.Model.MultiElementVertex.Position">
            <summary>
            Get or set the position shared by all the element vertices this
            object represents.  If all vertices do not share the same position,
            Vector.Unset will be returned.
            </summary>
        </member>
        <member name="P:Nucleus.Model.MultiElementVertex.X">
            <summary>
            Get or set the position X-coordinate shared by all the element vertices
            this object represents.  If all vertices do not lie on the same X-coordinate,
            double.NaN will be returned.
            </summary>
        </member>
        <member name="P:Nucleus.Model.MultiElementVertex.Y">
            <summary>
            Get or set the position Y-coordinate shared by all the element vertices
            this object represents.  If all vertices do not lie on the same Y-coordinate,
            double.NaN will be returned.
            </summary>
        </member>
        <member name="P:Nucleus.Model.MultiElementVertex.Z">
            <summary>
            Get or set the position Z-coordinate shared by all the element vertices
            this object represents.  If all vertices do not lie on the same Z-coordinate,
            double.NaN will be returned.
            </summary>
        </member>
        <member name="P:Nucleus.Model.MultiElementVertex.Offset">
            <summary>
            The offset vector of this element vertex from the node which defines it
            </summary>
        </member>
        <member name="P:Nucleus.Model.MultiElementVertex.Offset_X">
            <summary>
            The X-coordinate of the offset vector
            </summary>
        </member>
        <member name="P:Nucleus.Model.MultiElementVertex.Offset_Y">
            <summary>
            The Y-coordinate of the offset vector
            </summary>
        </member>
        <member name="P:Nucleus.Model.MultiElementVertex.Offset_Z">
            <summary>
            The Z-coordinate of the offset vector
            </summary>
        </member>
        <member name="P:Nucleus.Model.MultiElementVertex.Releases">
            <summary>
            The releases of the vertex
            </summary>
        </member>
        <member name="P:Nucleus.Model.MultiElementVertex.Release_X">
            <summary>
            The translational release of this vertex in the x-axis
            </summary>
        </member>
        <member name="P:Nucleus.Model.MultiElementVertex.Release_Y">
            <summary>
            The translational release of this vertex in the y-axis
            </summary>
        </member>
        <member name="P:Nucleus.Model.MultiElementVertex.Release_Z">
            <summary>
            The translational release of this vertex in the z-axis
            </summary>
        </member>
        <member name="P:Nucleus.Model.MultiElementVertex.Release_XX">
            <summary>
            The rotational release of this vertex about the x-axis
            </summary>
        </member>
        <member name="P:Nucleus.Model.MultiElementVertex.Release_YY">
            <summary>
            The rotational release of this vertex about the y-axis
            </summary>
        </member>
        <member name="P:Nucleus.Model.MultiElementVertex.Release_ZZ">
            <summary>
            The rotational release of this vertex about the z-axis
            </summary>
        </member>
        <member name="M:Nucleus.Model.MultiElementVertex.#ctor(Nucleus.Model.ElementCollection,Nucleus.Geometry.VertexCollection,System.String)">
            <summary>
            Initialise a new MultiElementVertex for the specified elements and vertices
            </summary>
            <param name="elements"></param>
            <param name="vertices"></param>
            <param name="description"></param>
        </member>
        <member name="M:Nucleus.Model.MultiElementVertex.#ctor(System.Collections.Generic.IList{Nucleus.Model.ElementVertex})">
            <summary>
            Initialise a MultiElementVertex helper object combining the
            specified set of ElementVertices.
            </summary>
            <param name="elementVertices"></param>
        </member>
        <member name="M:Nucleus.Model.MultiElementVertex.#ctor(Nucleus.Model.ElementVertex)">
            <summary>
            Initialise a MultiElementVertex from a single elementvertex
            </summary>
            <param name="elementVertex"></param>
        </member>
        <member name="M:Nucleus.Model.MultiElementVertex.Merge(Nucleus.Model.ElementVertex)">
            <summary>
            Merge an element vertex into this object
            </summary>
            <param name="elVert"></param>
        </member>
        <member name="T:Nucleus.Model.PanelElementSet">
            <summary>
            A set of panel elements
            </summary>
        </member>
        <member name="T:Nucleus.Model.PointElement">
            <summary>
            An element set out by a single point in space and whose
            solid 3D geometry is produced by positioning a block geometry
            at that point.
            </summary>
        </member>
        <member name="M:Nucleus.Model.PointElement.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Model.PointElement.#ctor(System.String)">
            <summary>
            Name constructor
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Nucleus.Model.PointElement.GetNominalPosition">
            <summary>
            Get a point in space which nominally describes the position of this element,
            to be used for display attachments and the like.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.PointElement.OrientateToVector(Nucleus.Geometry.Vector)">
            <summary>
            Modify the orientation of this element so that the appropriate axis
            of the local coordinate system (Z for linear elements, X for panels)
            points as closely as possible towards the specified guide vector.
            </summary>
            <param name="vector"></param>
        </member>
        <member name="T:Nucleus.Model.PropertyMatchFilter`2">
            <summary>
            Base class for set filters which pass or reject objects based on whether
            their properties match a specified pre-set value
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="F:Nucleus.Model.PropertyMatchFilter`2._Value">
            <summary>
            Private backing field for the Value property
            </summary>
        </member>
        <member name="P:Nucleus.Model.PropertyMatchFilter`2.Value">
            <summary>
            The value to match against.
            </summary>
        </member>
        <member name="M:Nucleus.Model.PropertyMatchFilter`2.GetItemPropertyValue(`0)">
            <summary>
            Get the value of the property to be compared with the preset
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nucleus.Model.PropertyMatchFilter`2.Pass(`0)" -->
        <member name="T:Nucleus.Model.ResultsCaseCollection">
            <summary>
            A collection of results cases
            </summary>
        </member>
        <member name="T:Nucleus.Model.ChannelProfile">
            <summary>
            Represents profiles shaped like a 'C' (or '[') with two flanges
            and a web on the left-hand side.
            </summary>
        </member>
        <member name="M:Nucleus.Model.ChannelProfile.#ctor">
            <summary>
            Initialise a new blank channel profile
            </summary>
        </member>
        <member name="M:Nucleus.Model.ChannelProfile.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initialise a new channel profile with the specified parameters
            </summary>
            <param name="depth"></param>
            <param name="width"></param>
            <param name="flangeThickness"></param>
            <param name="webThickness"></param>
            <param name="rootRadius"></param>
        </member>
        <member name="M:Nucleus.Model.ChannelProfile.#ctor(System.String)">
            <summary>
            Initialise a C-profile based on dimensions specified by a string.
            The string should consist of numeric values in mm separated by spaces,
            x's or the multiplication sign '×' and in the order Depth, Width,
            Flange Thickness, Web Thickness, Root Radius
            </summary>
            <param name="dimensionString"></param>
        </member>
        <member name="T:Nucleus.Model.SectionProfiles.GeometricProfile">
            <summary>
            A section profile that is defined explicitly by user-set cross-sectional geometry.
            </summary>
        </member>
        <member name="F:Nucleus.Model.SectionProfiles.GeometricProfile._Geometry">
            <summary>
            Private backing field for Geometry property
            </summary>
        </member>
        <member name="P:Nucleus.Model.SectionProfiles.GeometricProfile.Geometry">
            <summary>
            The geometry of the section profile
            </summary>
        </member>
        <member name="M:Nucleus.Model.SectionProfiles.GeometricProfile.#ctor">
            <summary>
            Initialise a new blank GeometricProfile with no geometry.
            This profile will not be valid until the Geometry property
            is set.
            </summary>
        </member>
        <member name="M:Nucleus.Model.SectionProfiles.GeometricProfile.#ctor(Nucleus.Geometry.PlanarRegion)">
            <summary>
            Initialise a new GeometricProfile with the specified geometry.
            </summary>
            <param name="geometry"></param>
        </member>
        <member name="T:Nucleus.Model.TrapezoidProfile">
            <summary>
            A profile in the shape of a solid trapezoid, with a different width
            at the top to the bottom
            </summary>
        </member>
        <member name="F:Nucleus.Model.TrapezoidProfile._Depth">
            <summary>
            Private backing member variable for the Depth property
            </summary>
        </member>
        <member name="P:Nucleus.Model.TrapezoidProfile.Depth">
            <summary>
            The depth of the section
            </summary>
        </member>
        <member name="F:Nucleus.Model.TrapezoidProfile._TopWidth">
            <summary>
            Private backing member variable for the TopWidth property
            </summary>
        </member>
        <member name="P:Nucleus.Model.TrapezoidProfile.TopWidth">
            <summary>
            The width of the top of the section
            </summary>
        </member>
        <member name="F:Nucleus.Model.TrapezoidProfile._BaseWidth">
            <summary>
            Private backing member variable for the BaseWidth property
            </summary>
        </member>
        <member name="P:Nucleus.Model.TrapezoidProfile.BaseWidth">
            <summary>
            The width of the base of the section
            </summary>
        </member>
        <member name="M:Nucleus.Model.TrapezoidProfile.#ctor">
            <summary>
            Initialise a new blank trapezoid profile with the parameters not set
            </summary>
        </member>
        <member name="M:Nucleus.Model.TrapezoidProfile.#ctor(System.String)">
            <summary>
            Initialise a TrapexoidProfile based on dimensions specified by a string.
            The string should consist of numeric values in mm separated by spaces,
            x's or the multiplication sign '×' and in the order Depth, Width,
            Flange Thickness, Web Thickness, Root Radius
            </summary>
            <param name="dimensionString"></param>
        </member>
        <member name="T:Nucleus.Model.SetFilterBase`1">
            <summary>
            Abstract generic base class for set filters
            </summary>
        </member>
        <member name="P:Nucleus.Model.SetFilterBase`1.Invert">
            <summary>
            Inversion toggle.  If set to true, those items which would
            normally pass the filter will fail and vise versa.
            </summary>
        </member>
        <member name="M:Nucleus.Model.SetFilterBase`1.Pass(`0)">
            <summary>
            Does the specified item pass through this filter?
            </summary>
            <param name="item">The item to be tested</param>
            <returns>True if the item passes through the filter, false if not.</returns>
        </member>
        <member name="T:Nucleus.Model.UserCoordinateSystemReference">
            <summary>
            A coordinate system reference that wraps a user-defined coordinate system
            </summary>
        </member>
        <member name="F:Nucleus.Model.UserCoordinateSystemReference._CoordinateSystem">
            <summary>
            Private backing field for CoordinateSystem property
            </summary>
        </member>
        <member name="P:Nucleus.Model.UserCoordinateSystemReference.CoordinateSystem">
            <summary>
            The geometric coordinate system stored within this object
            </summary>
        </member>
        <member name="M:Nucleus.Model.UserCoordinateSystemReference.#ctor">
            <summary>
            Initialise a new user coordinate system aligned to the
            global coordinate system
            </summary>
        </member>
        <member name="M:Nucleus.Model.UserCoordinateSystemReference.#ctor(System.String,Nucleus.Geometry.ICoordinateSystem)">
            <summary>
            Initialise a new user coordinate system
            </summary>
            <param name="name"></param>
            <param name="cSystem"></param>
        </member>
        <member name="M:Nucleus.Model.UserCoordinateSystemReference.GetCoordinateSystem(Nucleus.Model.LinearElement,System.Double)">
            <summary>
            Get the coordinate system defined by this object for the specified position along a linear element
            </summary>
            <param name="element">The linear element the coordinate system relates to</param>
            <param name="t">The position along the linear element that the coordinate system relates to</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.AngleProfile">
            <summary>
            An 'L'-shaped angle profile consisting of one flange and one web
            </summary>
        </member>
        <member name="M:Nucleus.Model.AngleProfile.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Model.AngleProfile.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initialises a profile with the specified dimensions
            </summary>
            <param name="depth"></param>
            <param name="width"></param>
            <param name="flangeThickness"></param>
            <param name="webThickness"></param>
        </member>
        <member name="M:Nucleus.Model.AngleProfile.#ctor(System.String)">
            <summary>
            Initialise an angle profile based on dimensions specified by a string.
            The string should consist of numeric values in mm separated by spaces,
            x's or the multiplication sign '×' and in the order Depth, Width,
            Flange Thickness, Web Thickness, Root Radius
            </summary>
            <param name="dimensionString"></param>
        </member>
        <member name="T:Nucleus.Model.FamilyDataStore">
            <summary>
            Extensible storage mechanism for adding attached data to families
            </summary>
        </member>
        <member name="M:Nucleus.Model.FamilyDataStore.#ctor(Nucleus.Model.Family)">
            <summary>
            Initialise a new data store owned by the specified family
            </summary>
            <param name="owner"></param>
        </member>
        <member name="T:Nucleus.Model.IDataComponent">
            <summary>
            Interface for objects which can be attached to DataOwners
            </summary>
        </member>
        <member name="T:Nucleus.Model.IFamilyDataComponent">
            <summary>
            Interface for data components which can be attached to Families
            </summary>
        </member>
        <member name="T:Nucleus.Model.INodeDataComponent">
            <summary>
            Interface for data components which can be attached to nodes
            </summary>
        </member>
        <member name="M:Nucleus.Model.INodeDataComponent.Merge(Nucleus.Model.INodeDataComponent)">
            <summary>
            Merge the specified other data component of the same type into this component.
            Called when two nodes are merged together.
            </summary>
            <param name="other"></param>
        </member>
        <member name="T:Nucleus.Model.LinearElementSet">
            <summary>
            A parametrically-defined set of Linear elements.  
            Allows linear element collections to be defined via a base collection and a set of logical 
            filters which act upon that collection.
            </summary>
        </member>
        <member name="M:Nucleus.Model.LinearElementSet.#ctor">
            <summary>
            Create a new blank element set
            </summary>
        </member>
        <member name="M:Nucleus.Model.LinearElementSet.#ctor(System.Boolean)">
            <summary>
            Create a new 'all elements' set
            </summary>
            <param name="all"></param>
        </member>
        <member name="M:Nucleus.Model.LinearElementSet.#ctor(Nucleus.Model.LinearElement)">
            <summary>
            Initialise this set to contain a single item
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Nucleus.Model.LinearElementSet.#ctor(Nucleus.Model.ElementCollection)">
            <summary>
            Initialise this set to contain the specified base collection of items
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Nucleus.Model.LinearElementSet.#ctor(Nucleus.Model.SectionFamily)">
            <summary>
            Initialise a set to contain all elements in the model to which it
            belongs which are assigned the specified section.
            </summary>
            <param name="section"></param>
        </member>
        <member name="M:Nucleus.Model.LinearElementSet.Set(Nucleus.Model.LinearElementCollection)">
            <summary>
            Set this set to contain only the specified items.
            All existing items, filters etc. in this set will be removed.
            </summary>
            <param name="items"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nucleus.Model.LinearElementSet.Add(Nucleus.Model.LinearElementCollection)" -->
        <member name="T:Nucleus.Model.CircularHollowProfile">
            <summary>
            A circular hollow section profile with a constant wall thickness
            </summary>
        </member>
        <member name="F:Nucleus.Model.CircularHollowProfile._WallThickness">
            <summary>
            Private backing field for WallThickness property
            </summary>
        </member>
        <member name="P:Nucleus.Model.CircularHollowProfile.WallThickness">
            <summary>
            The thickness of the tube walls of the section
            </summary>
        </member>
        <member name="P:Nucleus.Model.CircularHollowProfile.HasVoids">
            <summary>
            Does this profile (potentially) have voids?
            </summary>
        </member>
        <member name="M:Nucleus.Model.CircularHollowProfile.#ctor">
            <summary>
            Default constructor.  Initialises a Circular Hollow Profile with no parameters set.
            </summary>
        </member>
        <member name="M:Nucleus.Model.CircularHollowProfile.#ctor(System.Double,System.Double)">
            <summary>
            Initialises a Circular Hollow Profile with the specified diameter and wall thickness.
            </summary>
            <param name="diameter"></param>
            <param name="wallThickness"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nucleus.Model.CircularHollowProfile.#ctor(System.String)" -->
        <member name="T:Nucleus.Model.CircularProfile">
            <summary>
            Parametric profile type to represent circular profiles and
            to act as a base class for section types which have a broadly
            circular shape and posess a diameter dimension.
            </summary>
        </member>
        <member name="F:Nucleus.Model.CircularProfile._Diameter">
            <summary>
            Private backing member variable for the Depth property
            </summary>
        </member>
        <member name="P:Nucleus.Model.CircularProfile.Diameter">
            <summary>
            The depth of the section
            </summary>
        </member>
        <member name="P:Nucleus.Model.CircularProfile.OverallDepth">
            <summary>
            Get the overall depth of this section profile.
            This is a utility property common to all profile types
            regardless of how their parameters are actually defined.
            It gives the overall bounding dimension of the profile
            (i.e. the depth between extreme points).
            </summary>
        </member>
        <member name="P:Nucleus.Model.CircularProfile.OverallWidth">
            <summary>
            Get the overall width of this section profile.
            This is a utility property common to all profile types
            regardless of how their parameters are actually defined.
            It gives the overall bounding dimension of the profile
            (i.e. the width between extreme points).
            </summary>
        </member>
        <member name="M:Nucleus.Model.CircularProfile.#ctor">
            <summary>
            Initialises a new Circular profile without any set parameters.
            </summary>
        </member>
        <member name="M:Nucleus.Model.CircularProfile.#ctor(System.Double)">
            <summary>
            Initialises a new Circlular profile with the specified diameter
            </summary>
            <param name="diameter"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nucleus.Model.CircularProfile.#ctor(System.String)" -->
        <member name="T:Nucleus.Model.ElementVertex">
            <summary>
            A wrapper for a vertex which forms part of an element definition, with
            properties set up to make the local properties easier to interrogate and set.
            This is a temporary object that is created when necessary and is not persisted
            beyond that.
            </summary>
        </member>
        <member name="F:Nucleus.Model.ElementVertex._Description">
            <summary>
            Private backing field for Description property
            </summary>
        </member>
        <member name="P:Nucleus.Model.ElementVertex.Description">
            <summary>
            The description of the position of this vertex relative to its parent element.
            Typically a number, "Start" or "End"
            </summary>
        </member>
        <member name="F:Nucleus.Model.ElementVertex._Element">
            <summary>
            Private backing field for Element property
            </summary>
        </member>
        <member name="P:Nucleus.Model.ElementVertex.Element">
            <summary>
            The element that this vertex belongs to
            </summary>
        </member>
        <member name="F:Nucleus.Model.ElementVertex._Vertex">
            <summary>
            Private backing field for Vertex property
            </summary>
        </member>
        <member name="P:Nucleus.Model.ElementVertex.Vertex">
            <summary>
            The vertex on the element
            </summary>
        </member>
        <member name="P:Nucleus.Model.ElementVertex.Node">
            <summary>
            Get or set the node that this vertex is connected to
            </summary>
        </member>
        <member name="P:Nucleus.Model.ElementVertex.Position">
            <summary>
            The position of the vertex
            </summary>
        </member>
        <member name="P:Nucleus.Model.ElementVertex.Offset">
            <summary>
            The offset of this vertex from its node.
            Setting this property will change the position of this vertex
            with reference to the node position, provided that a node exists for this
            vertex.
            </summary>
        </member>
        <member name="P:Nucleus.Model.ElementVertex.CombinedOffset">
            <summary>
            TODO: Provide the combined offset to the centreline of the element's
            section or build-up from this vertex.
            NOT YET IMPLEMENTED PROPERLY!
            </summary>
        </member>
        <member name="P:Nucleus.Model.ElementVertex.Releases">
            <summary>
            The translational and rotational releases of the element vertex
            </summary>
        </member>
        <member name="P:Nucleus.Model.ElementVertex.Release_X">
            <summary>
            The translational release in the X-axis direction
            </summary>
        </member>
        <member name="P:Nucleus.Model.ElementVertex.Release_Y">
            <summary>
            The translational release in the Y-axis direction
            </summary>
        </member>
        <member name="P:Nucleus.Model.ElementVertex.Release_Z">
            <summary>
            The translational release in the Z-axis direction
            </summary>
        </member>
        <member name="P:Nucleus.Model.ElementVertex.Release_XX">
            <summary>
            The rotational release about the X-axis
            </summary>
        </member>
        <member name="P:Nucleus.Model.ElementVertex.Release_YY">
            <summary>
            The rotational release about the Y-axis
            </summary>
        </member>
        <member name="P:Nucleus.Model.ElementVertex.Release_ZZ">
            <summary>
            The rotational release about the Z-axis
            </summary>
        </member>
        <member name="P:Nucleus.Model.ElementVertex.Stiffness">
            <summary>
            Get or set the release stiffness at this position of the element
            </summary>
        </member>
        <member name="P:Nucleus.Model.ElementVertex.LocalCoordinateSystem">
            <summary>
            Get the local coordinate system of the element at this vertex
            </summary>
        </member>
        <member name="M:Nucleus.Model.ElementVertex.#ctor(Nucleus.Model.Element,Nucleus.Geometry.Vertex,System.String)">
            <summary>
            Constructor.  Initialises a new ElementVertex belonging to the specified element
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Nucleus.Model.ElementVertex.SetReleases(Nucleus.Model.VertexReleases)">
            <summary>
            Set the releases data component on this vertex
            </summary>
            <param name="releases"></param>
        </member>
        <member name="M:Nucleus.Model.ElementVertex.ClearReleases">
            <summary>
            Remove any released degrees of freedom from this element vertex
            </summary>
        </member>
        <member name="M:Nucleus.Model.ElementVertex.GetLocalCoordinateSystem(System.Boolean)">
            <summary>
            Get the local coordinate system of the element at this vertex
            </summary>
            <param name="allowFlip">If true, the coordinate system may be aligned
            to point towards the centre of the element.  Otherwise, it will be the
            'real' coordinate system</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ElementVertexExtensions.ToMultiElementVertices(System.Collections.Generic.IList{Nucleus.Model.ElementVertex})">
            <summary>
            Convert this collection of ElementVertices into a collection of MultiElementVertices
            </summary>
            <param name="verts"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.FactoredCase`1">
            <summary>
            Abstract, generic base class for the combination of a case and a scalar factor
            </summary>
            <typeparam name="TCase"></typeparam>
        </member>
        <member name="F:Nucleus.Model.FactoredCase`1._Factor">
            <summary>
            Private backing field for Factor property
            </summary>
        </member>
        <member name="P:Nucleus.Model.FactoredCase`1.Factor">
            <summary>
            The factor by which the case results should be magnified
            </summary>
        </member>
        <member name="F:Nucleus.Model.FactoredCase`1._Case">
            <summary>
            Private backing field for Case property
            </summary>
        </member>
        <member name="P:Nucleus.Model.FactoredCase`1.Case">
            <summary>w
            The case which is to be factored
            </summary>
        </member>
        <member name="M:Nucleus.Model.FactoredCase`1.#ctor">
            <summary>
            Initialise an empty factored case.
            </summary>
        </member>
        <member name="M:Nucleus.Model.FactoredCase`1.#ctor(`0)">
            <summary>
            Initialise a new FactoredCase with a factor of 1 and the
            speciifed case.
            </summary>
            <param name="dCase"></param>
        </member>
        <member name="M:Nucleus.Model.FactoredCase`1.#ctor(System.Double,`0)">
            <summary>
            Initialise a new FactoredCase with the specifed factor
            and case.
            </summary>
            <param name="factor"></param>
            <param name="dCase"></param>
        </member>
        <member name="T:Nucleus.Model.IModelImporter">
            <summary>
            Interface for importer classes that 
            </summary>
        </member>
        <member name="T:Nucleus.Model.DataOwner">
            <summary>
            Abstract base class for model objects which own data components.
            These objects contain a data store which can be used to hold data of various kinds
            attached to this object in an easily extensible way.
            </summary>
        </member>
        <member name="M:Nucleus.Model.DataOwner.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nucleus.Model.DataOwner.#ctor(Nucleus.Model.DataOwner)" -->
        <member name="M:Nucleus.Model.DataOwner.#ctor(System.String)">
            <summary>
            Name constructor
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Nucleus.Model.DataOwner.HasData">
            <summary>
            Check whether this object has any attached data components
            </summary>
        </member>
        <member name="M:Nucleus.Model.DataOwner.HasData(System.Type)">
            <summary>
            Check whether this object has any attached data components of the specified type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.DataOwner.ClearData(System.Type)">
            <summary>
            Remove any attached data components of the specified type
            </summary>
            <param name="ofType"></param>
        </member>
        <member name="M:Nucleus.Model.DataOwner.ClearData">
            <summary>
            Remove all attached data components
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.DataOwner.NotifyComponentPropertyChanged(System.Object,System.String)">
            <summary>
            Notify this owner that a property of a data component has been changed.
            This may then be 'bubbled' upwards with a new event.
            </summary>
            <param name="component"></param>
            <param name="propertyName"></param>
        </member>
        <member name="M:Nucleus.Model.DataOwner.AllAttachedDataComponents">
            <summary>
            Get a flat collection of all the data components currently attached to this object
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.DataOwner`3">
            <summary>
            Abstract generic base class for model objects which own data components.
            These objects contain a data store which can be used to hold data of various kinds
            attached to this object in an easily extensible way.
            </summary>
        </member>
        <member name="F:Nucleus.Model.DataOwner`3._Data">
            <summary>
            Private backing field for Data property
            </summary>
        </member>
        <member name="P:Nucleus.Model.DataOwner`3.Data">
            <summary>
            The store of data objects attached to this model object.
            This container can be used to add and retrieve data objects of specific
            types.
            </summary>
        </member>
        <member name="M:Nucleus.Model.DataOwner`3.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Model.DataOwner`3.#ctor(Nucleus.Model.DataOwner{`0,`1,`2})">
            <summary>
            Duplication constructor
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Nucleus.Model.DataOwner`3.#ctor(System.String)">
            <summary>
            Name constructor
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Nucleus.Model.DataOwner`3.NewDataStore">
            <summary>
            Create a new data store suitable for this datatype
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.DataOwner`3.HasData">
            <summary>
            Check whether this object has any attached data components
            </summary>
        </member>
        <member name="M:Nucleus.Model.DataOwner`3.HasData(System.Type)">
            <summary>
            Check whether this object has any attached data components of the specified type
            </summary>
            <param name="componentType"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.DataOwner`3.HasData``1">
            <summary>
            Check whether this object has any attached data components of the specified type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.DataOwner`3.GetData``1">
            <summary>
            Get the data component of the specified type attached to this object (if one exists)
            </summary>
            <typeparam name="T">The type of the attached data component to be retrieved</typeparam>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.DataOwner`3.GetData``1(System.Boolean)">
            <summary>
            Get data of the specified generic type (or the closest available sub-type) attached to
            this object.  If no data component of the specified type is found then optionally a
            new one will be created.
            </summary>
            <typeparam name="T">The type of data component to be retrieved.</typeparam>
            <param name="create">If true, a new data component of the specified type will
            be created and returned should one not already exist.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.DataOwner`3.GetAllData``1">
            <summary>
            Get all data within this store that is of the specified generic type or which
            is assignable to that type.
            </summary>
            <typeparam name="T">The type of data component to be retrieved.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.DataOwner`3.SetData(`1)">
            <summary>
            Attach a data component to this object
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
        </member>
        <member name="M:Nucleus.Model.DataOwner`3.SetData(`1[])">
            <summary>
            Attach multiple data components to this object
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:Nucleus.Model.DataOwner`3.ClearData(System.Type)">
            <summary>
            Remove any attached data components of the specified type
            </summary>
            <param name="ofType"></param>
        </member>
        <member name="M:Nucleus.Model.DataOwner`3.ClearData">
            <summary>
            Remove all attached data components
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.DataOwner`3.AllAttachedDataComponents">
            <summary>
            Get a flat list of all data components currently attached to this object.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.DataStore`2">
            <summary>
            Extensible storage mechanism for adding tagged data to model objects
            </summary>
            <typeparam name="TData">The type of data that this store will contain</typeparam>
        </member>
        <member name="F:Nucleus.Model.DataStore`2._Owner">
            <summary>
            Private backing field for Owner property
            </summary>
        </member>
        <member name="P:Nucleus.Model.DataStore`2.Owner">
            <summary>
            The object that this data store belongs to
            </summary>
        </member>
        <member name="P:Nucleus.Model.DataStore`2.Item(System.String)">
            <summary>
            Get a data component within this store by it's type name.
            </summary>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.DataStore`2.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Model.DataStore`2.#ctor(`1)">
            <summary>
            Initialise a new DataStore with the given owner
            </summary>
            <param name="owner"></param>
        </member>
        <member name="M:Nucleus.Model.DataStore`2.GetKeyForItem(`0)">
            <summary>
            Get the key for the specified item
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nucleus.Model.DataStore`2.GetData(System.String)" -->
        <member name="M:Nucleus.Model.DataStore`2.GetData``1">
            <summary>
            Get data of the specified generic type from this
            data store.  Note that the type must match exactly - sub-types are not included.
            </summary>
            <typeparam name="T">The type of data component to be retrieved.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.DataStore`2.GetData``1(System.Boolean)">
            <summary>
            Get data of the specified generic type from this
            data store.  If no data component of the specified type is found then optionally a
            new one will be created.
            </summary>
            <typeparam name="T">The type of data component to be retrieved.</typeparam>
            <param name="create">If true, a new data component of the specified type will
            be created and returned should one not already exist.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.DataStore`2.SetData(`0)">
            <summary>
            Add the specified data component to this store.  This will replace
            any attached data component of the same type.
            </summary>
            <param name="component"></param>
        </member>
        <member name="M:Nucleus.Model.DataStore`2.RemoveData``1">
            <summary>
            Remove an attached data component of the specified type
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Nucleus.Model.DataStore`2.HasData``1">
            <summary>
            Does this data store contain data of the specified type?
            </summary>
            <typeparam name="T">The type of data component to check for</typeparam>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.DataStore`2.HasData(System.Type)">
            <summary>
            Does this data store contain data of the specified type?
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.DataStore`2.GetAllData``1">
            <summary>
            Get all data within this store that is of the specified generic type or which
            is assignable to that type.
            </summary>
            <typeparam name="T">The type of data component to be retrieved.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.DataStore`2.GetAllData``1(System.Collections.Generic.IList{``0})">
            <summary>
            Get all data within this store that is of the specified generic type or which
            is assignable to that type and add it to the specififed collection.
            </summary>
            <typeparam name="T">The type of data component to be retrieved.</typeparam>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.DataStore`3">
            <summary>
            Base class for data stores which allow component types to be specified via an additional
            [XXX]DataType enum
            </summary>
            <typeparam name="TData"></typeparam>
            <typeparam name="TTypeEnum"></typeparam>
        </member>
        <member name="P:Nucleus.Model.DataStore`3.Item(`2)">
            <summary>
            Get a data component of a standard built-in type
            </summary>
            <param name="typeEnum"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.DataStore`3.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Model.DataStore`3.#ctor(`1)">
            <summary>
            Initialise a new DataStore with the given owner
            </summary>
            <param name="owner"></param>
        </member>
        <member name="M:Nucleus.Model.DataStore`3.GetRepresentedType(`2)">
            <summary>
            Get the type represented by the specified data type enum
            </summary>
            <param name="typeEnum"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.DataStore`3.GetData(`2)">
            <summary>
            Get a data component of a standard built-in type
            </summary>
            <param name="typeEnum"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.DataStore`3.HasData(`2)">
            <summary>
            Does this data store contain data of the specified type?
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.ElementDataStore">
            <summary>
            A data storage mechanism for elements.
            Stores element data keyed by the type of data.
            </summary>
        </member>
        <member name="M:Nucleus.Model.ElementDataStore.#ctor(Nucleus.Model.Element)">
            <summary>
            Initialise a new Element data store belonging to the specified element
            </summary>
            <param name="owner"></param>
        </member>
        <member name="T:Nucleus.Model.ElementCollection`2">
            <summary>
            Generic base collection of elements
            </summary>
            <typeparam name="TElement">The sub-type of elements that this collection contains</typeparam>
        </member>
        <member name="M:Nucleus.Model.ElementCollection`2.#ctor">
            <summary>
            Default constructor.  Initialises a new empty ElementCollection
            </summary>
        </member>
        <member name="M:Nucleus.Model.ElementCollection`2.#ctor(Nucleus.Model.Model)">
            <summary>
            Owner constructor.  Initialises an empty ElementCollection with the specified owner
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Nucleus.Model.ElementCollection`2.AllWith(Nucleus.Model.Node)">
            <summary>
            Find and return the subset of elements in this collection that contain a reference to the
            specified node.
            </summary>
            <param name="node">The node to search for</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ElementCollection`2.AllWith(Nucleus.Model.Family)">
            <summary>
            Find and return the subset of elements in this collection that contain a reference to the
            specified property.
            </summary>
            <param name="property">The property to search for</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ElementCollection`2.BoundingBox">
            <summary>
            Calculate the bounding box of the elements in this collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ElementCollection`2.GenerateNodes(Nucleus.Model.NodeGenerationParameters)">
            <summary>
            Generate or update nodes within this collection to structurally represent
            the vertices of elements.
            </summary>
            <param name="options"></param>
        </member>
        <member name="M:Nucleus.Model.ElementCollection`2.GetNodes">
            <summary>
            Get all of the nodes which belong to elements in this collection.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ElementCollection`2.ExtractConnectedSubstructures">
            <summary>
            Extract from this collection subcollections of elements which
            are connected together.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ElementCollection`2.ConnectedSubstructureSearch(`0,`1,`1)">
            <summary>
            Recursive search for connected elements
            </summary>
            <param name="element"></param>
            <param name="pool"></param>
            <param name="current"></param>
        </member>
        <member name="M:Nucleus.Model.ElementCollection`2.FirstWithDataComponent``1(`0)">
            <summary>
            Get the first element in this collection with an attached data component
            of the specified type.
            </summary>
            <typeparam name="TDataComponent">The type of attached data component.</typeparam>
            <param name="ignore">Ignore this element in the collection, even if it has the
            relevant component.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ElementCollection`2.AllWithDataComponent``1(`0)">
            <summary>
            Get all elements in this collection with an attached data component
            of the specified type.
            </summary>
            <typeparam name="TDataComponent">The type of attached data component</typeparam>
            <param name="ignore">Ignore this element in the collection, even if it has the
            relevant component.</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.ElementCollection">
            <summary>
            A collection of elements
            </summary>
        </member>
        <member name="P:Nucleus.Model.ElementCollection.LinearElements">
            <summary>
            Extract a collection of all the linear elements in this collection.
            A new collection will be generated each time this is called.
            </summary>
        </member>
        <member name="P:Nucleus.Model.ElementCollection.PanelElements">
            <summary>
            Extract a collection of all the panel elements in this collection.
            A new collection will be generated each time this is called.
            </summary>
        </member>
        <member name="P:Nucleus.Model.ElementCollection.ConstraintElemnts">
            <summary>
            Extract a collection of all the constraint elements in this collection.
            A new collection will be generated each time this is called.
            </summary>
        </member>
        <member name="P:Nucleus.Model.ElementCollection.IsAllLinear">
            <summary>
            Does this collection contain linear elements and only linear elements?
            </summary>
        </member>
        <member name="P:Nucleus.Model.ElementCollection.IsAllPanels">
            <summary>
            Does this collection contain panel elements and only panel elements?
            </summary>
        </member>
        <member name="M:Nucleus.Model.ElementCollection.#ctor">
            <summary>
            Default constructor.  Initialises a new empty ElementCollection
            </summary>
        </member>
        <member name="M:Nucleus.Model.ElementCollection.#ctor(Nucleus.Model.Element)">
            <summary>
            Initialise a new collection containing the specified single element
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Nucleus.Model.ElementCollection.#ctor(System.Collections.Generic.IEnumerable{Nucleus.Model.Element})">
            <summary>
            Initialise a new collection containing the same elements as another
            </summary>
            <param name="elements"></param>
        </member>
        <member name="M:Nucleus.Model.ElementCollection.#ctor(Nucleus.Model.Model)">
            <summary>
            Owner constructor.  Initialises an empty ElementCollection with the specified owner
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Nucleus.Model.ElementCollection.Modified(System.DateTime)">
            <summary>
            Get the subset of this collection which has a recorded modification after the specified date and time
            </summary>
            <param name="since">The date and time to filter by</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ElementCollection.AllWithDataComponent``1">
            <summary>
            Get the subset of this collection which has an attached data component of the specified type
            </summary>
            <typeparam name="TData">The type of data component to check for</typeparam>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ElementCollection.GetMergedElementVertices">
            <summary>
            Get the merged element vertices for the elements in this collection
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.BuildUpFamily">
            <summary>
            A property which describes the cross-thickness
            makeup of a panel element in order to produce
            a 3D solid geometry
            </summary>
        </member>
        <member name="P:Nucleus.Model.BuildUpFamily.Layers">
            <summary>
            The collection of build-up layers that define the through-thickness
            properties of this family
            </summary>
        </member>
        <member name="F:Nucleus.Model.BuildUpFamily._SetOut">
            <summary>
            Private backing field for the SetOut property
            </summary>
        </member>
        <member name="P:Nucleus.Model.BuildUpFamily.SetOut">
            <summary>
            The set-out position of the layers
            </summary>
        </member>
        <member name="M:Nucleus.Model.BuildUpFamily.#ctor">
            <summary>
            Initialise a new blank Panel Family
            </summary>
        </member>
        <member name="M:Nucleus.Model.BuildUpFamily.#ctor(System.String)">
            <summary>
            Initialse a new Panel Family with the given name
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Nucleus.Model.BuildUpFamily.NotifyBuildUpChanged(Nucleus.Model.BuildUpLayer)">
            <summary>
            Notify this family that one of its constituant layers has been modified
            </summary>
            <param name="layer"></param>
        </member>
        <member name="M:Nucleus.Model.BuildUpFamily.GetPrimaryMaterial">
            <summary>
            Get the material of the first layer in this build-up
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.ElementTable">
            <summary>
            An extended ElementCollection that also maintains several other temporary
            data structures in order to provide additional fast lookup capabilities
            </summary>
        </member>
        <member name="F:Nucleus.Model.ElementTable._NextNumericID">
            <summary>
            Private backing field for NextNumericID property
            </summary>
        </member>
        <member name="P:Nucleus.Model.ElementTable.NextNumericID">
            <summary>
            The numeric ID that will be assigned to the next element to be added to this table
            </summary>
        </member>
        <member name="T:Nucleus.Model.IElementDataComponent">
            <summary>
            Interface for objects which contain data that can be attached to
            an element.
            </summary>
        </member>
        <member name="T:Nucleus.Model.IElementOrientation">
            <summary>
            Interface for objects which describe the orientation
            of the local coordinate system of an element,
            which in turn may influence how the volumetric property
            is applied to the set-out geometry to create the full
            solid representation of the object
            </summary>
        </member>
        <member name="T:Nucleus.Model.LetterProfile">
            <summary>
            An abstract base class for I-, T-, C- and L- shape profiles, which
            consist of a single web and one or two flanges in various arrangements
            </summary>
        </member>
        <member name="F:Nucleus.Model.LetterProfile._Depth">
            <summary>
            Private backing member variable for the Depth property
            </summary>
        </member>
        <member name="P:Nucleus.Model.LetterProfile.Depth">
            <summary>
            The depth of the section
            </summary>
        </member>
        <member name="F:Nucleus.Model.LetterProfile._Width">
            <summary>
            Private backing member variable for the Width property
            </summary>
        </member>
        <member name="P:Nucleus.Model.LetterProfile.Width">
            <summary>
            The width of the section
            </summary>
        </member>
        <member name="P:Nucleus.Model.LetterProfile.OverallDepth">
            <summary>
            Get the overall depth of this section profile.
            This is a utility property common to all profile types
            regardless of how their parameters are actually defined.
            It gives the overall bounding dimension of the profile
            (i.e. the depth between extreme points).
            </summary>
        </member>
        <member name="P:Nucleus.Model.LetterProfile.OverallWidth">
            <summary>
            Get the overall width of this section profile.
            This is a utility property common to all profile types
            regardless of how their parameters are actually defined.
            It gives the overall bounding dimension of the profile
            (i.e. the width between extreme points).
            </summary>
        </member>
        <member name="F:Nucleus.Model.LetterProfile._FlangeThickness">
            <summary>
            Private backing field for FlangeThickness property
            </summary>
        </member>
        <member name="P:Nucleus.Model.LetterProfile.FlangeThickness">
            <summary>
            The thickness of the flange
            of the section.
            </summary>
        </member>
        <member name="F:Nucleus.Model.LetterProfile._WebThickness">
            <summary>
            Private backing field for WebThickness property
            </summary>
        </member>
        <member name="P:Nucleus.Model.LetterProfile.WebThickness">
            <summary>
            The thickness of the web
            of the section
            </summary>
        </member>
        <member name="F:Nucleus.Model.LetterProfile._RootRadius">
            <summary>
            Private backing member variable for the Depth property
            </summary>
        </member>
        <member name="P:Nucleus.Model.LetterProfile.RootRadius">
            <summary>
            The root radius of the fillet between web and flange of this profile
            </summary>
        </member>
        <member name="M:Nucleus.Model.LetterProfile.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Model.LetterProfile.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initialises a profile with the specified dimensions
            </summary>
            <param name="depth"></param>
            <param name="width"></param>
            <param name="flangeThickness"></param>
            <param name="webThickness"></param>
        </member>
        <member name="M:Nucleus.Model.LetterProfile.#ctor(System.String)">
            <summary>
            Initialise a LetterProfile based on dimensions specified by a string.
            The string should consist of numeric values in mm separated by spaces,
            x's or the multiplication sign '×' and in the order Depth, Width,
            Flange Thickness, Web Thickness, Root Radius
            </summary>
            <param name="dimensionString"></param>
        </member>
        <member name="T:Nucleus.Model.Level">
            <summary>
            Object that represents a level in a model
            </summary>
        </member>
        <member name="F:Nucleus.Model.Level._Z">
            <summary>
            Private backing field for the Z property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Level.Z">
            <summary>
            The z-coordinate of the level
            </summary>
        </member>
        <member name="P:Nucleus.Model.Level.Name">
            <summary>
            The name of this level.
            </summary>
        </member>
        <member name="M:Nucleus.Model.Level.#ctor">
            <summary>
            Default constructor.  Initialises a new level situated at Z = 0.
            </summary>
        </member>
        <member name="M:Nucleus.Model.Level.#ctor(System.Double)">
            <summary>
            Initialise a new level at the specified Z-level.
            </summary>
            <param name="z"></param>
        </member>
        <member name="M:Nucleus.Model.Level.#ctor(System.String,System.Double)">
            <summary>
            Initialise a new level with the specified name at the specified Z-level.
            </summary>
            <param name="name"></param>
            <param name="z"></param>
        </member>
        <member name="M:Nucleus.Model.Level.IsAbove(Nucleus.Model.Level)">
            <summary>
            Is this level higher than the other specified level
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Level.IsBelow(Nucleus.Model.Level)">
            <summary>
            Is this level lower than the other specified level
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Level.IsCoincident(Nucleus.Model.Level)">
            <summary>
            Is this level coincident with the other specified level
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Level.CompareTo(Nucleus.Model.Level)">
            <summary>
            IComparable implementation
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Level.ProjectPoints(System.Collections.Generic.IList{Nucleus.Geometry.Vector})">
            <summary>
            Project the specified set of point vectors onto this level
            </summary>
            <param name="points">The initial set of points</param>
            <returns>A projected set of points on this level</returns>
        </member>
        <member name="T:Nucleus.Model.LevelCollection`1">
            <summary>
            A generic collection of levels
            </summary>
            <typeparam name="TLevel"></typeparam>
        </member>
        <member name="M:Nucleus.Model.LevelCollection`1.#ctor">
            <summary>
            Default constructor.  Initialises a new empty LevelCollection.
            </summary>
        </member>
        <member name="M:Nucleus.Model.LevelCollection`1.#ctor(Nucleus.Model.Model)">
            <summary>
            Owner constructor.  Initialises a new LevelCollection owned by the specified model.
            </summary>
            <param name="model">The model that owns the items in this collection</param>
        </member>
        <member name="M:Nucleus.Model.LevelCollection`1.NextLevelAbove(System.Double)">
            <summary>
            Search through this collection and find the next highest level after
            the one specified.
            </summary>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.LevelCollection`1.NextLevelBelow(System.Double)">
            <summary>
            Search through this collection and find the next level below the
            height value specified
            </summary>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.LevelCollection`1.LevelOf(System.Double,System.Double)">
            <summary>
            Find the level which the specified point lies on (within tolerance) or above
            </summary>
            <param name="z">The z coordinate to test</param>
            <param name="tolerance">The distance below which the position is assumed to
            lie 'on' the layer.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.LevelCollection`1.LevelOf(Nucleus.Geometry.Vector,System.Double)">
            <summary>
            Find the level which the specified point lies on (within tolerance) or above
            </summary>
            <param name="position">The position to test</param>
            <param name="tolerance">The distance below which the position is assumed to
            lie 'on' the layer.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.LevelCollection`1.NearestLevel(System.Double)">
            <summary>
            Find the level in this collection closest to the specified z-coordinate
            </summary>
            <param name="z"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.LevelCollection">
            <summary>
            A collection of levels.
            </summary>
        </member>
        <member name="M:Nucleus.Model.LevelCollection.#ctor">
            <summary>
            Default constructor.  Initialises a new empty LevelCollection.
            </summary>
        </member>
        <member name="M:Nucleus.Model.LevelCollection.#ctor(Nucleus.Model.Model)">
            <summary>
            Owner constructor.  Initialises a new LevelCollection owned by the specified model.
            </summary>
            <param name="model">The model that owns the items in this collection</param>
        </member>
        <member name="M:Nucleus.Model.LevelCollection.Modified(System.DateTime)">
            <summary>
            Get the subset of this collection which has a recorded modification after the specified date and time
            </summary>
            <param name="since">The date and time to filter by</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.LevelCollection.AllWithDataComponent``1">
            <summary>
            Get the subset of this collection which has an attached data component of the specified type
            </summary>
            <typeparam name="TData">The type of data component to check for</typeparam>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.LevelTable">
            <summary>
            A table of Levels, automatically ordered by Z-coordinate.
            </summary>
            <remarks>Currently, the case where the z-coordinate of a level is modified after being added
            is not dealt with.  TODO?</remarks>
        </member>
        <member name="F:Nucleus.Model.LevelTable._NextNumericID">
            <summary>
            Private backing field for NextNumericID property
            </summary>
        </member>
        <member name="P:Nucleus.Model.LevelTable.NextNumericID">
            <summary>
            The numeric ID that will be assigned to the next element to be added to this table
            </summary>
        </member>
        <member name="M:Nucleus.Model.LevelTable.#ctor">
            <summary>
            Default constructor.  Initialises a new empty LevelCollection.
            </summary>
        </member>
        <member name="M:Nucleus.Model.LevelTable.#ctor(Nucleus.Model.Model)">
            <summary>
            Owner constructor.  Initialises a new LevelCollection owned by the specified model.
            </summary>
            <param name="model">The model that owns the items in this collection</param>
        </member>
        <member name="M:Nucleus.Model.LevelTable.Resort">
            <summary>
            Sort the levels in this table by their z-values.
            This should rarely be necessary, as added items are automatically
            inserted in a position sorted by z-coordinate.  However, modification
            of the 'Z' coordinate of levels after insertion may mean that Levels can
            become out of order.
            </summary>
        </member>
        <member name="T:Nucleus.Model.LinearElement">
            <summary>
            A linear element is one defined in terms of a set-out curve
            and a section that is swept along the curve to define the 3D
            solid geometry.
            Used to represent objects where one dimension is greater than
            the others and the overall geometry can be represented as an
            extrusion along a curve, such as Beams, Columns, Walls, Pipes,
            etc.
            </summary>
        </member>
        <member name="P:Nucleus.Model.LinearElement.StartNode">
            <summary>
            The node (if any) that the start of this element is connected to.
            This is a shortcut property to get or set the node attached to the
            start of this element's geometry curve.
            Note that Nucleus element geometry is not dependent on nodes and
            so this property may have a null value.
            </summary>
        </member>
        <member name="P:Nucleus.Model.LinearElement.EndNode">
            <summary>
            The node (if any) that the end of this element is connected to.
            This is a shortcut property to get or set the node attached to the
            end of this element's geometry curve.
            Note that Nucleus element geometry is not dependent on nodes and
            so this property may have a null value.
            </summary>
        </member>
        <member name="P:Nucleus.Model.LinearElement.Start">
            <summary>
            Get a helper ElementVertex object that wraps the properties at the start of this
            element to allow for easy access and manipulation.
            </summary>
        </member>
        <member name="P:Nucleus.Model.LinearElement.End">
            <summary>
            Get a helper ElementVertex object that wraps the properties at the end of this
            element to allow for easy access and manipulation.
            </summary>
        </member>
        <member name="M:Nucleus.Model.LinearElement.#ctor">
            <summary>
            Default constructor.
            For use in factory methods only.
            </summary>
        </member>
        <member name="M:Nucleus.Model.LinearElement.#ctor(Nucleus.Geometry.Curve)">
            <summary>
            Curve geometry constructor
            </summary>
            <param name="geometry"></param>
        </member>
        <member name="M:Nucleus.Model.LinearElement.#ctor(Nucleus.Geometry.Curve,Nucleus.Model.SectionFamily)">
            <summary>
            Curve, property constructor
            </summary>
            <param name="geometry"></param>
            <param name="property"></param>
        </member>
        <member name="M:Nucleus.Model.LinearElement.#ctor(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Start and end point constructor
            Creates an element set-out along a straight line between
            the start and end points.
            </summary>
            <param name="startPoint"></param>
            <param name="endPoint"></param>
        </member>
        <member name="M:Nucleus.Model.LinearElement.#ctor(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Model.SectionFamily)">
            <summary>
            Start and end point constructor
            Creates an element set-out along a straight line between
            the start and end points.
            </summary>
            <param name="startPoint"></param>
            <param name="endPoint"></param>
            <param name="property"></param>
        </member>
        <member name="M:Nucleus.Model.LinearElement.#ctor(Nucleus.Model.Node,Nucleus.Model.Node,Nucleus.Model.SectionFamily)">
            <summary>
            Start and end node constructor.
            Initialises a new element set-out along a straight line
            between the start and end nodes.
            </summary>
            <param name="startNode"></param>
            <param name="endNode"></param>
        </member>
        <member name="M:Nucleus.Model.LinearElement.OrientateTowards(Nucleus.Geometry.Vector,Nucleus.Geometry.Angle)">
            <summary>
            Orientate this element such that the local Z axis at the centre of the element
            will point as closely as possible towards the given point, plus an additional offset angle
            </summary>
            <param name="point">The point to orientate the element Z axis towards</param>
            <param name="offset">An offset angle to be applied to the calculated orientation angle</param>
        </member>
        <member name="M:Nucleus.Model.LinearElement.OrientateTowards(Nucleus.Geometry.Vector)">
            <summary>
            Orientate this element such that the local Z axis at the centre of the element
            will point as closely as possible towards the given point.
            </summary>
            <param name="point">The point to orientate the element Z axis towards</param>
        </member>
        <member name="M:Nucleus.Model.LinearElement.OrientateToVector(Nucleus.Geometry.Vector)">
            <summary>
            Orientate this element such that the local Z axis at the centre of the element
            will point as closely as possible towards the given vector.
            </summary>
            <param name="vector"></param>
        </member>
        <member name="M:Nucleus.Model.LinearElement.CalculateVolume(Nucleus.Model.Material)">
            <summary>
            Calculate the total volume of the specified material contained within this element.
            If no material is specified, the total solid volume of the element will be returned.
            </summary>
            <param name="material"></param>
        </member>
        <member name="M:Nucleus.Model.LinearElement.LocalCoordinateSystem(System.Double)">
            <summary>
            Get the local coordinate system of this element
            </summary>
            <param name="t">The normalised parameter along the element at which to retrieve the
            coordinate system.  By default this will be 0 (i.e. the start of the element)</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.LinearElement.GetNominalPosition">
            <summary>
            Get a point in space which nominally describes the position of this element,
            to be used for display attachments and the like.
            On Linear Elements, this is the mid-parameter-space point of the curve.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.LinearElementCollection">
            <summary>
            A collection of linear elements
            </summary>
        </member>
        <member name="M:Nucleus.Model.LinearElementCollection.#ctor">
            <summary>
            Initialise a new empty LinearElementCollection
            </summary>
        </member>
        <member name="M:Nucleus.Model.LinearElementCollection.#ctor(Nucleus.Model.LinearElement)">
            <summary>
            Initialise a new LinearElementCollection containing the specified single item
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Nucleus.Model.LinearElementCollection.Modified(System.DateTime)">
            <summary>
            Get the subset of items in this collection which has a recorded modification 
            after the specified date and time
            </summary>
            <param name="since">The date/time to filter by</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.LinearElementCollection.TotalVolume(Nucleus.Model.Material)">
            <summary>
            Calculate the total volume of a material present within the elements within this collection.
            If no material is specified, this will be the total volume of all elements in the collection
            regardless of material.
            </summary>
            <param name="material"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.LinearElementCollection.ToElementCollection">
            <summary>
            Convert this LinearElementCollection to an ElementCollection containing the same elements
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.LoadCase">
            <summary>
            A set of loading which is applied to the model under a particular condition
            </summary>
        </member>
        <member name="F:Nucleus.Model.LoadCase._CaseType">
            <summary>
            Private backing field for CaseType
            </summary>
        </member>
        <member name="P:Nucleus.Model.LoadCase.CaseType">
            <summary>
            The type of loading that this case represents
            </summary>
        </member>
        <member name="M:Nucleus.Model.LoadCase.#ctor">
            <summary>
            Default constructor.  Initialises a new blank load case.
            </summary>
        </member>
        <member name="M:Nucleus.Model.LoadCase.#ctor(System.String)">
            <summary>
            Name constructor.  Initialises a new load case with the specified name.
            </summary>
            <param name="name">The load case name</param>
        </member>
        <member name="M:Nucleus.Model.LoadCase.#ctor(Nucleus.Model.LoadCaseType)">
            <summary>
            Type constructor.  Initialises a new load case of the specified type.
            The name will be automatically set to the string value of the caseType.
            </summary>
            <param name="caseType"></param>
        </member>
        <member name="M:Nucleus.Model.LoadCase.#ctor(System.String,Nucleus.Model.LoadCaseType)">
            <summary>
            Name and type constructor.  Initialises a new load case with the
            specified properties.
            </summary>
            <param name="name"></param>
            <param name="caseType"></param>
        </member>
        <member name="M:Nucleus.Model.LoadCase.Loads">
            <summary>
            Get the collection of loads which belong to this load case.
            This collection is automatically generated when called by
            searching through the load table of the model this case
            is part of.  This case thus needs to have been added to a
            model before calling this function and adding/removing items
            from the returned collection will not affect case assignments.
            </summary>
        </member>
        <member name="M:Nucleus.Model.LoadCase.Contains(Nucleus.Model.Loading.Load)">
            <summary>
            Does this case contain the specified load?
            </summary>
            <param name="load"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.LoadCaseCollection">
            <summary>
            A collection of load cases
            </summary>
        </member>
        <member name="M:Nucleus.Model.LoadCaseCollection.#ctor">
            <summary>
            Initialise a new blank load case collection
            </summary>
        </member>
        <member name="M:Nucleus.Model.LoadCaseCollection.#ctor(Nucleus.Model.Model)">
            <summary>
            Initialse a new load case collection owned by the specified model
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Nucleus.Model.LoadCaseCollection.#ctor(System.Collections.Generic.IEnumerable{Nucleus.Model.LoadCase})">
            <summary>
            Initialise a new load case collection containing the specified cases
            </summary>
            <param name="cases"></param>
        </member>
        <member name="T:Nucleus.Model.LoadCollection">
            <summary>
            A collection of loads
            </summary>
        </member>
        <member name="M:Nucleus.Model.LoadCollection.Modified(System.DateTime)">
            <summary>
            Get the subset of this collection which has a recorded modification after the specified date and time
            </summary>
            <param name="since">The date and time to filter by</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.LoadCollection.AllWithDataComponent``1">
            <summary>
            Get the subset of this collection which has an attached data component of the specified type
            </summary>
            <typeparam name="TData">The type of data component to check for</typeparam>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.LoadCollection.AllInCase(Nucleus.Model.LoadCase)">
            <summary>
            Get all loads in this collection that belong to the specified load case
            </summary>
            <param name="loadCase"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.LoadCollection.AllAppliedTo``1(``0)">
            <summary>
            Get all loads in this collection which are applied to the specified
            model object.
            </summary>
            <typeparam name="TObj"></typeparam>
            <param name="mObj"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.Material">
            <summary>
            Base class for materials
            </summary>
        </member>
        <member name="P:Nucleus.Model.Material.Steel">
            <summary>
            Default Steel material
            </summary>
        </member>
        <member name="P:Nucleus.Model.Material.Concrete">
            <summary>
            Default Concrete material
            </summary>
        </member>
        <member name="P:Nucleus.Model.Material.Wood">
            <summary>
            Get a default Wood material
            </summary>
        </member>
        <member name="P:Nucleus.Model.Material.Aluminium">
            <summary>
            Default Aluminium material
            </summary>
        </member>
        <member name="P:Nucleus.Model.Material.Glass">
            <summary>
            Default Glass material
            </summary>
        </member>
        <member name="P:Nucleus.Model.Material.Defaults">
            <summary>
            Get a collection of all the default materials
            </summary>
        </member>
        <member name="F:Nucleus.Model.Material._Density">
            <summary>
            Private backing field for Density property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Material.Density">
            <summary>
            The density of the material, in kg/m³
            </summary>
        </member>
        <member name="F:Nucleus.Model.Material._Category">
            <summary>
            Private backing field for Category property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Material.Category">
            <summary>
            The preset category under which this material falls.
            Used to determine applicable design codes and to map
            to equivalent material properties in other software.
            </summary>
        </member>
        <member name="M:Nucleus.Model.Material.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Model.Material.#ctor(System.String,Nucleus.Model.MaterialCategory)">
            <summary>
            Name constructor
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Nucleus.Model.Material.GetE(Nucleus.Geometry.Direction)">
            <summary>
            Get the Elastic (or, Young's) Modulus of this material
            in the specified direction, in N/m²
            </summary>
        </member>
        <member name="M:Nucleus.Model.Material.GetYieldStrength(Nucleus.Geometry.Direction)">
            <summary>
            Get the yield strength of this material in the specified
            direction, in Pa.
            </summary>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.MaterialCollection">
            <summary>
            A collection of Materials
            </summary>
        </member>
        <member name="M:Nucleus.Model.MaterialCollection.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Model.MaterialCollection.#ctor(Nucleus.Model.Material)">
            <summary>
            Constructor initialising a new MaterialCollection containing 
            the specified item
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Nucleus.Model.MaterialCollection.#ctor(System.Collections.Generic.IEnumerable{Nucleus.Model.Material})">
            <summary>
            Initialise a new MaterialCollection containing the specified items
            </summary>
            <param name="materials"></param>
        </member>
        <member name="M:Nucleus.Model.MaterialCollection.#ctor(Nucleus.Model.Model)">
            <summary>
            Owner constructor
            </summary>
            <param name="model"></param>
        </member>
        <member name="T:Nucleus.Model.MaterialTable">
            <summary>
            An extended material collection which may contain additional temporary data structures 
            to enable fast object lookup
            </summary>
        </member>
        <member name="F:Nucleus.Model.MaterialTable._NextNumericID">
            <summary>
            Private backing field for NextNumericID property
            </summary>
        </member>
        <member name="P:Nucleus.Model.MaterialTable.NextNumericID">
            <summary>
            The numeric ID that will be assigned to the next element to be added to this table
            </summary>
        </member>
        <member name="M:Nucleus.Model.MaterialTable.#ctor(Nucleus.Model.Model)">
            <summary>
            Initialises a new MaterialTable belonging to 
            </summary>
            <param name="model"></param>
        </member>
        <member name="T:Nucleus.Model.CoordinateSystemReference">
            <summary>
            A reference to a coordinate system that can be defined and stored within the model,
            then used as a definition parameter for geometry, load and result axes
            </summary>
        </member>
        <member name="P:Nucleus.Model.CoordinateSystemReference.Global">
            <summary>
            Get the object which represents the global coordinate system.
            This is a shortcut method to GlobalCoordinateSystem.Instance and will return the same object.
            </summary>
        </member>
        <member name="P:Nucleus.Model.CoordinateSystemReference.Local">
            <summary>
            Get the 'dummy' object which represents the use of the local coordinate system.
            This is a shortcut method to LocalCoordinateSystem.Instance and will return the same object.
            </summary>
        </member>
        <member name="P:Nucleus.Model.CoordinateSystemReference.StandardValues">
            <summary>
            A collection of the 'standard' CoordinateSystemReference values.
            </summary>
        </member>
        <member name="P:Nucleus.Model.CoordinateSystemReference.IsGlobal">
            <summary>
            Does this object represent the global coordinate system
            </summary>
        </member>
        <member name="P:Nucleus.Model.CoordinateSystemReference.IsLocal">
            <summary>
            Does this object represent the local coordinate system of an element or other object
            </summary>
        </member>
        <member name="M:Nucleus.Model.CoordinateSystemReference.GetCoordinateSystem(Nucleus.Model.ModelObject)">
            <summary>
            Get the coordinate system defined by this object as applicable to the specified object
            </summary>
            <param name="onObject">The object to which the coordinate system should relate.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.CoordinateSystemReference.GetCoordinateSystem(Nucleus.Model.LinearElement,System.Double)">
            <summary>
            Get the coordinate system defined by this object for the specified position along a linear element
            </summary>
            <param name="element">The linear element the coordinate system relates to</param>
            <param name="t">The position along the linear element that the coordinate system relates to</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.ModelDocumentCollection">
            <summary>
            A collection of model documents
            </summary>
        </member>
        <member name="T:Nucleus.Model.ModelObject">
            <summary>
            Abstract base class for Model objects - objects which can be directly added to a model
            and form the top-level of data within that model.
            </summary>
        </member>
        <member name="F:Nucleus.Model.ModelObject._Model">
            <summary>
            Private backing field for Model property
            </summary>
        </member>
        <member name="P:Nucleus.Model.ModelObject.Model">
            <summary>
            The Model, if any, that this object currently belongs to.
            May be null.
            </summary>
        </member>
        <member name="P:Nucleus.Model.ModelObject.Nucleus#Base#IOwned{Nucleus#Model#Model}#Owner">
            <summary>
            Get the owning Model of this object
            </summary>
        </member>
        <member name="F:Nucleus.Model.ModelObject._Modified">
            <summary>
            Private backing field for Modified property
            </summary>
        </member>
        <member name="P:Nucleus.Model.ModelObject.Modified">
            <summary>
            The date and time of the last significant modification
            performed on this object.
            </summary>
        </member>
        <member name="F:Nucleus.Model.ModelObject._NumericID">
            <summary>
            Private backing field for NumericID property
            </summary>
        </member>
        <member name="P:Nucleus.Model.ModelObject.NumericID">
            <summary>
            The table number of this object.
            This is used as a display ID and also when syncing with other
            software that uses numeric IDs.  However it is not generally used
            as an identifier internally as it is not guaranteed to be unique.
            </summary>
        </member>
        <member name="P:Nucleus.Model.ModelObject.Description">
            <summary>
            Get a description of this object.
            By default, this is the name of the object, but when the name is
            not set some types will generate a replacement description.
            </summary>
        </member>
        <member name="M:Nucleus.Model.ModelObject.#ctor">
            <summary>
            Protected base default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Model.ModelObject.#ctor(Nucleus.Model.ModelObject)">
            <summary>
            Duplication constructor
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Nucleus.Model.ModelObject.#ctor(System.String)">
            <summary>
            Name constructor
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Nucleus.Model.ModelObject.NotifyPropertyChanged(System.String)">
            <summary>
            Raise a PropertyChanged event for the specified property name.
            Will also update the stored last modification time.
            </summary>
            <param name="propertyName"></param>
        </member>
        <member name="M:Nucleus.Model.ModelObject.NotifyPropertyChanged(System.String,System.Object,System.Object)">
            <summary>
            Raise a PropertyChanged event for the specified property name
            with extended arguments.
            Will also update the stored last modification time.
            </summary>
            <param name="propertyName"></param>
        </member>
        <member name="M:Nucleus.Model.ModelObject.ToString">
            <summary>
            ToString override
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObject.ClearDataFromMismatchedModel">
            <summary>
            Delete from this object any references in its properties
            pointing to objects from a different model
            </summary>
        </member>
        <member name="T:Nucleus.Model.ModelObjectExtensions">
            <summary>
            Static extension methods for collections of ModelObjects
            </summary>
        </member>
        <member name="M:Nucleus.Model.ModelObjectExtensions.IndexOfLowestNumericID``1(System.Collections.Generic.IList{``0})">
            <summary>
            Find the index of the item in this list with the lowest NumericID
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectExtensions.GetByNumericID``1(System.Collections.Generic.IEnumerable{``0},System.Int64)">
            <summary>
            Find and return from this set of model objects the one with the specified numeric ID
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="numericID"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.ModelObjectCollection`1">
            <summary>
            A collection of model objects.
            Generic version to allow further specificity of object type.
            </summary>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCollection`1.#ctor">
            <summary>
            Default constructor.  Initialises a new model object collection
            </summary>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCollection`1.#ctor(Nucleus.Model.Model)">
            <summary>
            Owner constructor.  Initialises a model object collection with an owning model.
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCollection`1.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            Collection combination constructor
            </summary>
            <param name="toBeCombined"></param>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCollection`1.SetNumericID(`0)">
            <summary>
            Set the numeric ID of the specified item.  
            In standard collections, this does nothing.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCollection`1.FindByName(System.String,`0,System.Boolean)">
            <summary>
            Find the first item in this collection which has the specified name (if any)
            </summary>
            <param name="name">The name to search for.</param>
            <param name="ignore">Optional.  If specified this object will be ignore during the search.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCollection`1.FindByName``1(System.String,``0)">
            <summary>
            Find the first item in this collection of the specified subtype and 
            which has the specified name (if any)
            </summary>
            <param name="name">The name to search for.</param>
            <param name="ignore">Optional.  If specified this object will be ignore during the search.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCollection`1.NextAvailableName(System.String,`0,System.Boolean,System.Boolean)">
            <summary>
            Return the next version of this name with an attached numerical postfix that
            will be a unique name in this collection.
            </summary>
            <param name="baseName">The base name</param>
            <param name="ignore">Optional.  If specified, this object will be ignored during the search.</param>
            <param name="enforcePostFix">Optional.  If set true, a postfix numeral will always be applied, even if it is 1.</param>
            <param name="includeSpace">Optional.  If true (default) a space will be inserted between the name and number</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCollection`1.ToNumericIDs">
            <summary>
            Extract from this collection an array of all the numeric IDs of the
            objects in this collection.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCollection`1.ToString">
            <summary>
            Convert to a collapsed ID string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCollection`1.ClearAttachedData(System.Type)">
            <summary>
            Clear any attached data components of the specified type
            from the objects in this collection
            </summary>
            <param name="ofType"></param>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCollection`1.ClearAttachedData">
            <summary>
            Clear any attached data components (of any type)
            from the objects in this collection
            </summary>
            <param name="ofType"></param>
        </member>
        <member name="T:Nucleus.Model.ModelObjectCollection">
            <summary>
            A collection of model objects
            </summary>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCollection.#ctor">
            <summary>
            Default constructor.  Initialises a new model object collection
            </summary>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCollection.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Nucleus.Model.ModelObject}})">
            <summary>
            Collection combination constructor
            </summary>
            <param name="toBeCombined"></param>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCollection.Modified(System.DateTime)">
            <summary>
            Get the subset of this collection which has a recorded modification after the specified date and time
            </summary>
            <param name="since">The date and time to filter by</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCollection.AllWithDataComponent``1">
            <summary>
            Get the subset of this collection which has an attached data component of the specified type
            </summary>
            <typeparam name="TData">The type of data component to check for</typeparam>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.ModelObjectCollectionExtensions">
            <summary>
            Extension methods of ModelObjectCollections.
            Implemented as extension methods to take advantage of some return type trickery with generics
            </summary>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCollectionExtensions.Modified``2(``0,System.DateTime)">
            <summary>
            Get the subset of this collection which has a recorded modification after the specified date and time
            </summary>
            <typeparam name="TCollection"></typeparam>
            <typeparam name="TItem"></typeparam>
            <param name="collection"></param>
            <param name="since">The date and time to filter by</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCollectionExtensions.AllWithDataComponent``3(``0)">
            <summary>
            Get the subset of this collection which has an attached data component of the specified type
            </summary>
            <typeparam name="TCollection"></typeparam>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TData">The type of data component to check for</typeparam>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.ModelObjectCreator">
            <summary>
            A component of a model which acts as a factory class to create new objects 
            in the model or update previously created ones with matching execution information.
            </summary>
        </member>
        <member name="P:Nucleus.Model.ModelObjectCreator.Model">
            <summary>
            The model that this creator works on
            </summary>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCreator.#ctor(Nucleus.Model.Model)">
            <summary>
            Initialise a new ModelObjectCreator for the specified model
            </summary>
            <param name="model"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nucleus.Model.ModelObjectCreator.Node(Nucleus.Geometry.Vector,System.Double,Nucleus.Actions.ExecutionInfo)" -->
        <member name="M:Nucleus.Model.ModelObjectCreator.LinearElement(Nucleus.Geometry.Curve,Nucleus.Actions.ExecutionInfo)">
            <summary>
            Create a new (or update an existing) linear element in the model.
            </summary>
            <param name="geometry">The set-out geometry of the element</param>
            <param name="exInfo">Optional.  The execution information of the current action.
            If an object has been created previously with matching execution information then
            instead of creating a new item this previous one will be updated and returned instead.
            This enables this method to be used parametrically.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCreator.LinearElement(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Actions.ExecutionInfo)">
            <summary>
            Create a new (or update an existing) linear element in the model.
            </summary>
            <param name="startPoint">The start of the element set-out line</param>
            <param name="endPoint">The end of the element set-out line</param>
            <param name="exInfo">Optional.  The execution information of the current action.
            If an object has been created previously with matching execution information then
            instead of creating a new item this previous one will be updated and returned instead.
            This enables this method to be used parametrically.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCreator.LinearElement(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Model.SectionFamily,Nucleus.Actions.ExecutionInfo)">
            <summary>
            Create a new (or update an existing) linear element in the model.
            </summary>
            <param name="startPoint">The start of the element set-out line</param>
            <param name="endPoint">The end of the element set-out line</param>
            <param name="family">The section of the element</param>
            <param name="exInfo">Optional.  The execution information of the current action.
            If an object has been created previously with matching execution information then
            instead of creating a new item this previous one will be updated and returned instead.
            This enables this method to be used parametrically.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCreator.LinearElement(Nucleus.Model.Node,Nucleus.Model.Node,Nucleus.Model.SectionFamily,Nucleus.Actions.ExecutionInfo)">
            <summary>
            Create a new (or update an existing) linear element in the model.
            </summary>
            <param name="startPoint">The start of the element set-out line</param>
            <param name="endPoint">The end of the element set-out line</param>
            <param name="family">The section of the element</param>
            <param name="exInfo">Optional.  The execution information of the current action.
            If an object has been created previously with matching execution information then
            instead of creating a new item this previous one will be updated and returned instead.
            This enables this method to be used parametrically.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCreator.PanelElement(Nucleus.Geometry.Surface,Nucleus.Actions.ExecutionInfo)">
            <summary>
            Create a new (or update an existing) panel element in the model
            </summary>
            <param name="geometry">The set-out geometry of the element</param>
            <param name="exInfo">Optional.  The execution information of the current action.
            If an object has been created previously with matching execution information then
            instead of creating a new item this previous one will be updated and returned instead.
            This enables this method to be used parametrically.</param>
            <returns>A new or previously created Panel elemet</returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCreator.CopyOf(Nucleus.Model.Node,Nucleus.Actions.ExecutionInfo)">
            <summary>
            Create a new (or update an exisiting) node as a copy of another one
            </summary>
            <param name="node">The node to copy.</param>
            <param name="exInfo">Optional.  The execution information of the current action.
            If an object has been created previously with matching execution information then
            instead of creating a new item this previous one will be updated and returned instead.
            This enables this method to be used parametrically.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCreator.CopyOf(Nucleus.Model.Node,Nucleus.Geometry.Vector,Nucleus.Actions.ExecutionInfo)">
            <summary>
            Create a new (or update an exisiting) node as a copy of another one
            </summary>
            <param name="node">The node to copy.</param>
            <param name="newPosition">Optional.  The position of the new node.</param>
            <param name="exInfo">Optional.  The execution information of the current action.
            If an object has been created previously with matching execution information then
            instead of creating a new item this previous one will be updated and returned instead.
            This enables this method to be used parametrically.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCreator.CopyOf(Nucleus.Model.LinearElement,Nucleus.Geometry.Curve,Nucleus.Actions.ExecutionInfo)">
            <summary>
            Create a new (or update an existing) linear element as a copy of another one
            </summary>
            <param name="element">The element to copy.</param>
            <param name="newGeometry">Optional.  The set-out geometry to be used for the new element.</param>
            <param name="exInfo">Optional.  The execution information of the current action.
            If an object has been created previously with matching execution information then
            instead of creating a new item this previous one will be updated and returned instead.
            This enables this method to be used parametrically.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCreator.CopyFromAnotherModel(Nucleus.Model.LinearElement)">
            <summary>
            Create a copy of an element from another model inside this one.
            </summary>
            <param name="element">The element to copy</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCreator.CopyFromAnotherModel(Nucleus.Model.PanelElement)">
            <summary>
            Create a copy of an element from another model inside this one.
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCreator.CopyOf(Nucleus.Model.PanelElement,Nucleus.Geometry.Surface,Nucleus.Actions.ExecutionInfo)">
            <summary>
            Create a new (or update an existing) panel element as a copy of another one
            </summary>
            <param name="element">The element to copy.</param>
            <param name="newGeometry">Optional.  The set-out geometry to be used for the new element.</param>
            <param name="exInfo">Optional.  The execution information of the current action.
            If an object has been created previously with matching execution information then
            instead of creating a new item this previous one will be updated and returned instead.
            This enables this method to be used parametrically.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCreator.CopyOf(Nucleus.Model.Element,Nucleus.Geometry.VertexGeometry,Nucleus.Actions.ExecutionInfo)">
            <summary>
            Create a new (or update an existing) element as a copy of another one
            </summary>
            <param name="element">The element to copy.</param>
            <param name="newGeometry">Optional.  The set-out geometry to be used for the new element.
            Should be of the appropriate type for the element to be copied.</param>
            <param name="exInfo">Optional.  The execution information of the current action.
            If an object has been created previously with matching execution information then
            instead of creating a new item this previous one will be updated and returned instead.
            This enables this method to be used parametrically.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCreator.CopyOf``1(``0,Nucleus.Actions.ExecutionInfo)">
            <summary>
            Create a new (or update an existing) model object as a copy of another one
            </summary>
            <typeparam name="T"></typeparam>
            <param name="mObject"></param>
            <param name="exInfo"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCreator.SectionFamily(Nucleus.Actions.ExecutionInfo)">
            <summary>
            Create a new (or update an existing) section family in the model
            </summary>
            <param name="exInfo">Optional.  The execution information of the current action.
            If an object has been created previously with matching execution information then
            instead of creating a new item this previous one will be updated and returned instead.
            This enables this method to be used parametrically.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCreator.SectionFamily(System.String,Nucleus.Actions.ExecutionInfo)">
            <summary>
            Create a new (or update an existing) section family in the model
            </summary>
            <param name="name">The name of the section. 
            May be modified with a numerical suffix if the name already exists in
            the model.</param>
            <param name="exInfo">Optional.  The execution information of the current action.
            If an object has been created previously with matching execution information then
            instead of creating a new item this previous one will be updated and returned instead.
            This enables this method to be used parametrically.</param>
            <returns>The created or updated </returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCreator.SectionFamily(Nucleus.Model.SectionProfile,Nucleus.Actions.ExecutionInfo)">
            <summary>
            Create a new (or update an existing) section family in the model
            </summary>
            <param name="profile">The section profile to assign to the new property.</param>
            <param name="exInfo">Optional.  The execution information of the current action.
            If an object has been created previously with matching execution information then
            instead of creating a new item this previous one will be updated and returned instead.
            This enables this method to be used parametrically.</param>
            <returns>The created or updated section family</returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCreator.BuildUpFamily(Nucleus.Actions.ExecutionInfo)">
            <summary>
            Create a new (or update an existing) face family in the model
            </summary>
            <param name="exInfo">Optional.  The execution information of the current action.
            If an object has been created previously with matching execution information then
            instead of creating a new item this previous one will be updated and returned instead.
            This enables this method to be used parametrically.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCreator.BuildUpFamily(System.String,Nucleus.Actions.ExecutionInfo)">
            <summary>
            Create a new (or update an existing) face family in the model
            </summary>
            <param name="name">The name of the family. 
            May be modified with a numerical suffix if the name already exists in
            the model.</param>
            <param name="exInfo">Optional.  The execution information of the current action.
            If an object has been created previously with matching execution information then
            instead of creating a new item this previous one will be updated and returned instead.
            This enables this method to be used parametrically.</param>
            <returns>The created or updated </returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCreator.IsoMaterial(System.String,Nucleus.Actions.ExecutionInfo)">
            <summary>
            Create a new (or update an existing) material in the model
            </summary>
            <param name="name">The name of the material. 
            May be modified with a numerical suffix if the name already exists in
            the model.</param>
            <param name="exInfo">Optional.  The execution information of the current action.
            If an object has been created previously with matching execution information then
            instead of creating a new item this previous one will be updated and returned instead.
            This enables this method to be used parametrically.</param>
            <returns>The created or updated </returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCreator.UserCoordinateSystemReference(Nucleus.Geometry.ICoordinateSystem,System.String,Nucleus.Actions.ExecutionInfo)">
            <summary>
            Create a new (or update an existing) coordinate system in the model
            </summary>
            <param name="cSystem">The geometry coordinate system to assign as this user system</param>
            <param name="name">Optional.  The name of the user coordinate system.  If not specified a
            name will be automatically generated.</param>
            <param name="exInfo">Optional.  The execution information of the current action.
            If an object has been created previously with matching execution information then
            instead of creating a new item this previous one will be updated and returned instead.
            This enables this method to be used parametrically.</param>
            <returns>The created or updated user coordinate system.</returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCreator.LoadCase(System.String,Nucleus.Model.LoadCaseType,Nucleus.Actions.ExecutionInfo)">
            <summary>
            Create a new (or update an existing) load case in the model
            </summary>
            <param name="name">The name of the load case</param>
            <param name="exInfo">Optional.  The execution information of the current action.
            If an object has been created previously with matching execution information then
            instead of creating a new item this previous one will be updated and returned instead.
            This enables this method to be used parametrically.</param>
            <returns>The created or updated load case.</returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectCreator.LoadCase(System.String,Nucleus.Actions.ExecutionInfo)">
            <summary>
            Create a new (or update an existing) load case in the model
            </summary>
            <param name="name">The name of the load case</param>
            <param name="exInfo">Optional.  The execution information of the current action.
            If an object has been created previously with matching execution information then
            instead of creating a new item this previous one will be updated and returned instead.
            This enables this method to be used parametrically.</param>
            <returns>The created or updated load case.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nucleus.Model.ModelObjectCreator.Load``1(Nucleus.Model.LoadCase,Nucleus.Actions.ExecutionInfo)" -->
        <!-- Badly formed XML comment ignored for member "M:Nucleus.Model.ModelObjectCreator.NodeLoad(Nucleus.Model.LoadCase,Nucleus.Actions.ExecutionInfo)" -->
        <!-- Badly formed XML comment ignored for member "M:Nucleus.Model.ModelObjectCreator.GravityLoad(Nucleus.Model.LoadCase,Nucleus.Actions.ExecutionInfo)" -->
        <!-- Badly formed XML comment ignored for member "M:Nucleus.Model.ModelObjectCreator.ThermalLoad(Nucleus.Model.LoadCase,Nucleus.Actions.ExecutionInfo)" -->
        <!-- Badly formed XML comment ignored for member "M:Nucleus.Model.ModelObjectCreator.LinearElementLoad(Nucleus.Model.LoadCase,Nucleus.Actions.ExecutionInfo)" -->
        <!-- Badly formed XML comment ignored for member "M:Nucleus.Model.ModelObjectCreator.LinearElementPointLoad(Nucleus.Model.LoadCase,Nucleus.Actions.ExecutionInfo)" -->
        <!-- Badly formed XML comment ignored for member "M:Nucleus.Model.ModelObjectCreator.PanelLoad(Nucleus.Model.LoadCase,Nucleus.Actions.ExecutionInfo)" -->
        <!-- Badly formed XML comment ignored for member "M:Nucleus.Model.ModelObjectCreator.Level(System.Double,Nucleus.Actions.ExecutionInfo)" -->
        <member name="T:Nucleus.Model.ModelObjectSetBase">
            <summary>
            Abstract base class for parametrically defined 'sets' of objects which
            allow collections to be defined via a base collection and a set of logical 
            filters which act upon that collection.
            </summary>
        </member>
        <member name="F:Nucleus.Model.ModelObjectSetBase._All">
            <summary>
            Private backing field for All property
            </summary>
        </member>
        <member name="P:Nucleus.Model.ModelObjectSetBase.All">
            <summary>
            Gets or sets whether this set initially (before filtering) contains all objects
            of the relevant type within the model that this set belongs to.
            </summary>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSetBase.GetItems">
            <summary>
            Get the final set of items contained within this set, consisting of all items in the base collection
            and any subsets (or all items in the model if 'All' is true) that pass all filters specified via the
            Filters property.
            </summary>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSetBase.GetItemIDs``1(Nucleus.Conversion.IDMappingTable{System.Guid,``0})">
            <summary>
            Get a list of IDs of the final set of items contained within this set, consisting of all items in the base collection
            and any subsets (or all items in the model if 'All' is true) that pass all filters specified via the
            Filters property.
            </summary>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSetBase.GetItemIDs``1(Nucleus.Conversion.IDMappingTable{System.Guid,System.Collections.Generic.IList{``0}})">
            <summary>
            Get a list of IDs of the final set of items contained within this set, consisting of all items in the base collection
            and any subsets (or all items in the model if 'All' is true) that pass all filters specified via the
            Filters property.
            </summary>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSetBase.Add(Nucleus.Model.ModelObject)">
            <summary>
            Add an item to the base collection of this set.
            If the specified item is not a valid type for this set, adding it will
            fail and this function will return false.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSetBase.Nucleus#Model#IModelObjectSet#Add(Nucleus.Model.ModelObject)">
            <summary>
            Add an item to the base collection of this set.
            If the specified item is not a valid type for this set, adding it will
            fail and this function will return false.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSetBase.Contains(Nucleus.Model.ModelObject)">
            <summary>
            Does this set contain the specified item?
            (or, would it, if they were part of the same model?)
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSetBase.Nucleus#Model#IModelObjectSet#Contains(Nucleus.Model.ModelObject)">
            <summary>
            Does this set contain the specified item?
            (or, would it, if they were part of the same model?)
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.ModelObjectSet`2">
            <summary>
            Abstract generic base class for parametrically defined 'sets' of objects which
            allow collections to be defined via a base collection and a set of logical 
            filters which act upon that collection.
            </summary>
        </member>
        <member name="F:Nucleus.Model.ModelObjectSet`2._BaseCollection">
            <summary>
            Private backing field for BaseCollection property
            </summary>
        </member>
        <member name="P:Nucleus.Model.ModelObjectSet`2.BaseCollection">
            <summary>
            The base collection of items to be considered for inclusion in this set.
            Filters will be applied to this collection to determine the final collection of
            objects which constitute this set.
            If this and the SubSets property are null, but the Set has been added to a model,
            all objects of the relevant type within the model will be considered for inclusion.
            </summary>
        </member>
        <member name="T:Nucleus.Model.ModelObjectSet`6">
            <summary>
            Abstract generic base class for parametrically defined 'sets' of objects which
            allow collections to be defined via a base collection and a set of logical 
            filters which act upon that collection.
            </summary>
        </member>
        <member name="F:Nucleus.Model.ModelObjectSet`6._SubSets">
            <summary>
            Private backing field for SubSets property
            </summary>
        </member>
        <member name="P:Nucleus.Model.ModelObjectSet`6.SubSets">
            <summary>
            The base collection of other sets to be considered for inclusion in this set.
            FIlters will be applied to the expanded contents of these sets to determine the final
            collection of objects which constitute this set.
            If this and the BaseCollection property are null, but the set has been added to a model,
            all objects of the relevant type within the model will be considered for inclusion.
            </summary>
        </member>
        <member name="F:Nucleus.Model.ModelObjectSet`6._Filters">
            <summary>
            Private backing field for Filters property
            </summary>
        </member>
        <member name="P:Nucleus.Model.ModelObjectSet`6.Filters">
            <summary>
            A set of conditional filters to be applied to the base collection and
            subsets of this set in order to parametrically determine the final set of
            items to be included within it.
            </summary>
        </member>
        <member name="P:Nucleus.Model.ModelObjectSet`6.Items">
            <summary>
            Get the final set of items contained within this set, consisting of all items in the base collection
            and any subsets (or all items in the model if 'All' is true) that pass all filters specified via the
            Filters property.
            </summary>
        </member>
        <member name="P:Nucleus.Model.ModelObjectSet`6.IsCircular">
            <summary>
            Is this set circular - i.e. does it's definition include a reference to itself?
            </summary>
        </member>
        <member name="P:Nucleus.Model.ModelObjectSet`6.Definition">
            <summary>
            A textual definition of the items contained within this set
            </summary>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSet`6.#ctor">
            <summary>
            Base default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSet`6.#ctor(System.String)">
            <summary>
            Initialises a set with the specified name
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSet`6.#ctor(System.Boolean)">
            <summary>
            Initialises an 'all objects' set
            </summary>
            <param name="all"></param>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSet`6.#ctor(`0)">
            <summary>
            Initialises this set to contain a single item
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSet`6.#ctor(`1)">
            <summary>
            Initialises this set to contain the specified collection of items.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSet`6.#ctor(`2)">
            <summary>
            Initialises a set containing all objects in the model,
            filtered by the specified condition
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSet`6.OnDefinitionChanged">
            <summary>
            Called when the definition of this set is changed in some way
            </summary>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSet`6.GetItems">
            <summary>
            Get the final set of items contained within this set, consisting of all items in the base collection
            and any subsets (or all items in the model if 'All' is true) that pass all filters specified via the
            Filters property.
            </summary>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSet`6.Add(`0)">
            <summary>
            Add a new item to the base collection of this set, to be considered for inclusion.
            Note that adding an item to this set does not guarantee its inclusion should said
            item fail to pass any of the specified set filters.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSet`6.Add(`1)">
            <summary>
            Add a collection of items to the base collection of this set, to be considered for
            inclusion.  Note that adding an item to this set does not guarantee its inclusion 
            should said item fail to pass any of the specified set filters.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSet`6.Add(`4)">
            <summary>
            Add a new sub-set to the base collection of this set, to be considered for inclusion.
            Note that adding these items to this set does not guarantee their inclusion should said items
            fail to pass any of the specified set filters.
            </summary>
            <param name="set"></param>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSet`6.Add(`5)">
            <summary>
            Add a collection of sub-sets to the base collection of this set, to be considered for inclusion.
            Note that adding these items to this set does not guarantee their inclusion should said items
            fail to pass any of the specified set filters.
            </summary>
            <param name="set"></param>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSet`6.Set(`1)">
            <summary>
            Set this set to contain only the specified items.
            All existing items, filters etc. in this set will be removed.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSet`6.Set(System.String)">
            <summary>
            Set this set from a text definition.
            The Model property must be set before calling this function
            to allow items to be retrieved by ID.
            </summary>
            <param name="definition"></param>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSet`6.Clear">
            <summary>
            Clear this set, removing all items and filters
            </summary>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSet`6.Add(`2)">
            <summary>
            Add a new logical filter to this set.
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSet`6.Add(`3)">
            <summary>
            Add a collection of logical filters to this set
            </summary>
            <param name="filters"></param>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSet`6.ContainsReferenceTo(`4)">
            <summary>
            Does this set contain a reference to the specified set within
            its SubSets property, either directly or indirectly?
            </summary>
            <param name="set"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSet`6.Contains(Nucleus.Model.ModelObject)">
            <summary>
            Does this set contain the specified item?
            (or, would it, if they were part of the same model?)
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSet`6.Contains(`0)">
            <summary>
            Does this set contain the specified item?
            (or, would it, if they were part of the same model?)
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSet`6.PassInternalFilter(`0)">
            <summary>
            This function is used in some sub-types in order to provide built-in automatic filters.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSet`6.GetItemsInModel">
            <summary>
            Get all items of the relevent type from the model that this set belongs to
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSet`6.GenerateItems">
            <summary>
            Generate the expanded collection that contains all items in this set
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.ModelObjectSetCollection`1">
            <summary>
            A generic collection of ModelObjectSet objects
            </summary>
            <typeparam name="TSet"></typeparam>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSetCollection`1.#ctor">
            <summary>
            Default constructor.  Initialises a new model object set collection
            </summary>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSetCollection`1.#ctor(Nucleus.Model.Model)">
            <summary>
            Owner constructor.  Initialises a model object set collection with an owning model.
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSetCollection`1.FindOrCreate``1(System.String)">
            <summary>
            Find a set in this collection of the specified type and with the specified name
            or if a match does not exist create a new one
            </summary>
            <typeparam name="TSetType">The type of set to search for</typeparam>
            <param name="name">The name to search for</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nucleus.Model.ModelObjectSetCollection`1.TryAdd(Nucleus.Model.IModelObjectSet)" -->
        <member name="T:Nucleus.Model.ModelObjectSetCollection">
            <summary>
            A collection of ModelObjectSets
            </summary>
        </member>
        <member name="P:Nucleus.Model.ModelObjectSetCollection.ElementSets">
            <summary>
            Get a collection of all the sets of elements within this collection
            </summary>
        </member>
        <member name="P:Nucleus.Model.ModelObjectSetCollection.NodeSets">
            <summary>
            Get a collection of all the sets of nodes within this collection
            </summary>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSetCollection.#ctor">
            <summary>
            Default constructor.  Initialises a new model object set collection
            </summary>
        </member>
        <member name="M:Nucleus.Model.ModelObjectSetCollection.#ctor(Nucleus.Model.Model)">
            <summary>
            Owner constructor.  Initialises a model object set collection with an owning model.
            </summary>
            <param name="model"></param>
        </member>
        <member name="T:Nucleus.Model.ModelSourceHistory">
            <summary>
            Manager class to store, restore and merge model objects
            </summary>
        </member>
        <member name="P:Nucleus.Model.ModelSourceHistory.SourceMap">
            <summary>
            The map of objects to sources, stored as a list of UniqueObjects indexed by iteration and keyed by source reference
            </summary>
        </member>
        <member name="M:Nucleus.Model.ModelSourceHistory.ExecutionInfoFor(Nucleus.Model.ModelObject)">
            <summary>
            Search through the history to find the execution information (if any)
            bound to this model object
            </summary>
            <param name="mObj"></param>
            <returns>The reconstructed ExecutionInfo for the specified object's creation,
            if recorded.  Else, null.</returns>
        </member>
        <member name="M:Nucleus.Model.ModelSourceHistory.Get(Nucleus.Actions.ExecutionInfo)">
            <summary>
            Get a previously stored object
            </summary>
            <param name="exInfo"></param>
            <returns>The object previously stored with equivalent execution information, 
            or null if no previously stored object exists</returns>
        </member>
        <member name="M:Nucleus.Model.ModelSourceHistory.Set(Nucleus.Actions.ExecutionInfo,Nucleus.Model.ModelObject)">
            <summary>
            Store a generated object keyed by the given execution info of its generating action
            </summary>
            <param name="exInfo"></param>
            <param name="unique"></param>
        </member>
        <member name="M:Nucleus.Model.ModelSourceHistory.DeleteAllFromSource(System.String,System.Boolean)">
            <summary>
            Delete all objects created by the specified source
            </summary>
            <param name="sourceReference"></param>
        </member>
        <member name="M:Nucleus.Model.ModelSourceHistory.Update``1(Nucleus.Actions.ExecutionInfo,``0)">
            <summary>
            Replace the previous data stored with this execution information with the specified new value.
            If a stored object exists and is of the same type as the new one, it will be updated to match the new values
            otherwise the record will be replaced with the new object.
            </summary>
            <param name="exInfo">The execution information for the current operation</param>
            <param name="unique">The potential new item</param>
            <returns>The current object - either the orginal stored value if it was updated, or the new object
            if it was replaced</returns>
        </member>
        <member name="M:Nucleus.Model.ModelSourceHistory.CleanNodes(Nucleus.Model.ModelObject)">
            <summary>
            Clean up the nodes associated with this object.
            Will delete any nodes attached to this object that are
            not connected to any undeleted elements.
            </summary>
            <param name="unique"></param>
        </member>
        <member name="M:Nucleus.Model.ModelSourceHistory.CleanSubsequentIterations(System.String,System.Int32,System.Boolean)">
            <summary>
            Mark all items after the specified iteration number as deleted
            </summary>
            <param name="sourceRef"></param>
            <param name="iteration"></param>
            <param name="cleanNodes">If true, nodes on deleted elements that are not connected to
            any other undeleted elements will be deleted also</param>
        </member>
        <member name="M:Nucleus.Model.ModelSourceHistory.CleanSubsequentIterations(Nucleus.Actions.ExecutionInfo,System.Boolean)">
            <summary>
            Mark all items after the iteration number of the execution info as deleted
            </summary>
            <param name="exInfo"></param>
            <param name="cleanNodes">If true, nodes on deleted elements that are not connected to
            any other undeleted elements will be deleted also</param>
        </member>
        <member name="M:Nucleus.Model.ModelSourceHistory.CleanIteration(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Mark all items in the specified iteration after the specified historyItemCount as deleted
            </summary>
            <param name="sourceRef"></param>
            <param name="iteration"></param>
            <param name="historyItemCount"></param>
            <param name="cleanNodes">If true, nodes on deleted elements that are not connected to
            any other undeleted elements will be deleted also</param>
        </member>
        <member name="M:Nucleus.Model.ModelSourceHistory.CleanIteration(Nucleus.Actions.ExecutionInfo,System.Boolean)">
            <summary>
            Mark all items after the current iteration after the current historyItemCount as deleted
            </summary>
            <param name="exInfo"></param>
        </member>
        <member name="M:Nucleus.Model.ModelSourceHistory.CleanIterationData(System.Type,System.String,System.Int32,System.Int32)">
            <summary>
            Remove from the items stored under greater history count numbers the component of
            the specified type
            </summary>
            <param name="componentType"></param>
            <param name="sourceRef"></param>
            <param name="iteration"></param>
            <param name="historyItemCount"></param>
            <remarks>Intended to help tidy up parametric assignments (such as node supports) which
            could persist while the input nodes have changed.  Not currently used.</remarks>
        </member>
        <member name="T:Nucleus.Model.Node">
            <summary>
            A singular point which represents a shared connection point
            between multiple vertices within different objects.
            </summary>
        </member>
        <member name="F:Nucleus.Model.Node._Position">
            <summary>
            Internal backing member for Position property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Node.Position">
            <summary>
            The spatial position of this node
            </summary>
        </member>
        <member name="F:Nucleus.Model.Node._Vertices">
            <summary>
            Private backing field for Vertices property.
            </summary>
        </member>
        <member name="P:Nucleus.Model.Node.Vertices">
            <summary>
            The collection of vertices to which this node is connected
            </summary>
        </member>
        <member name="P:Nucleus.Model.Node.Description">
            <summary>
            Get a description of this node.
            Will be the node's name if it has one or will return "Node {ID}"
            if not.
            </summary>
        </member>
        <member name="M:Nucleus.Model.Node.#ctor">
            <summary>
            Default constructor.
            For use in factory methods only.
            </summary>
        </member>
        <member name="M:Nucleus.Model.Node.#ctor(Nucleus.Geometry.Vector)">
            <summary>
            Position constructor.
            Initialises a new node at the specified position.
            </summary>
            <param name="position"></param>
        </member>
        <member name="M:Nucleus.Model.Node.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            X, Y, Z position constructor.
            Initialises a new node at the specified position.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:Nucleus.Model.Node.GetConnectedElements(System.Boolean)">
            <summary>
            Get a collection of all elements connected to this node
            </summary>
            <param name="undeletedOnly">If true, only elements that are not marked
            as deleted will be returned</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Node.GetConnectedElements(Nucleus.Model.ElementCollection,System.Boolean,Nucleus.Model.Element)">
            <summary>
            Get a collection of all elements connected to this node
            </summary>
            <param name="addTo">Add the elements to this collection, which will be returned as the result</param>
            <param name="undeletedOnly">If true, only elements that are not marked
            as deleted will be returned</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Node.GetConnectedElements``2(``1,System.Boolean,``0)">
            <summary>
            Get a collection of all elements connected to this node
            </summary>
            <param name="addTo">Add the elements to this collection, which will be returned as the result</param>
            <param name="undeletedOnly">If true, only elements that are not marked
            as deleted will be returned</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Node.GetFirstConnectedElement``1(System.Boolean,Nucleus.Model.Element)">
            <summary>
            Get the first encountered element of the specified type connected to this node
            </summary>
            <typeparam name="TElement"></typeparam>
            <param name="undeletedOnly"></param>
            <param name="ignore"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Node.GetConnectedElementOnSide``1(Nucleus.Geometry.Vector,Nucleus.Geometry.HandSide,System.Boolean,Nucleus.Model.Element)">
            <summary>
            Get the first encountered element approached from the specified side of the specified direction
            </summary>
            <typeparam name="TElement"></typeparam>
            <param name="direction"></param>
            <param name="side"></param>
            <param name="undeletedOnly"></param>
            <param name="ignore"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Node.GetConnectedGeometry">
            <summary>
            Get a collection of the geometric objects whose vertices are connected to this node
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Node.ConnectionCount(System.Boolean)">
            <summary>
            Get the number of elements connected to this node
            </summary>
            <param name="undeletedOnly">If true, only elements not marked as deleted will
            be counted</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Node.MoveTo(Nucleus.Geometry.Vector,System.Boolean,Nucleus.Model.ElementCollection)">
            <summary>
            Change the position of this node, optionally dragging any
            attached vertices through the same transformation.
            </summary>
            <param name="newPosition"></param>
            <param name="dragVertices"></param>
        </member>
        <member name="M:Nucleus.Model.Node.AverageConnectionDirection">
            <summary>
            Calculate the average of the vectors from this node position to the centroid of connected elements.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Node.Merge(Nucleus.Model.Node,System.Boolean)">
            <summary>
            Merge the properties of another node with this one.
            </summary>
            <param name="other">The node to merge into this one</param>
            <param name="averagePositions">If true, the node position will
            be set to the average of the original value and the position of
            the other.</param>
        </member>
        <member name="T:Nucleus.Model.NodeExtensions">
            <summary>
            Static extension methods for collections of nodes
            </summary>
        </member>
        <member name="M:Nucleus.Model.NodeExtensions.Merge(System.Collections.Generic.IList{Nucleus.Model.Node},System.Boolean)">
            <summary>
            Merge a collection of nodes into one node.
            The lowest-numbered node will be retained, the others
            will have their data merged into that one and be deleted.
            </summary>
            <param name="nodes">The collection of nodes to merge.  Note that any
            deleted nodes which you do not want to include in this merge should be
            removed prior to running this operation.</param>
            <param name="averagePositions">If true, the resultant node position will
            be set to the average of the node positions.  Otherwise, the position of the
            original node will be retained.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.NodeExtensions.WithMaxConnectedElements(System.Collections.Generic.IList{Nucleus.Model.Node},System.Int32)">
            <summary>
            Find all the nodes in this list that have lower than or equal to the specified
            number of connected elements.  Can be used to identify isolated or 'dead-end' nodes
            </summary>
            <param name="nodes"></param>
            <param name="maxCount"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.NodeCollection">
            <summary>
            A collection of nodes
            </summary>
        </member>
        <member name="M:Nucleus.Model.NodeCollection.#ctor">
            <summary>
            Default constructor.  Initialises a new empty NodeCollection
            </summary>
        </member>
        <member name="M:Nucleus.Model.NodeCollection.#ctor(Nucleus.Model.Model)">
            <summary>
            Owner constructor.
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Nucleus.Model.NodeCollection.#ctor(Nucleus.Model.Node)">
            <summary>
            
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:Nucleus.Model.NodeCollection.Modified(System.DateTime)">
            <summary>
            Get the subset of this collection which has a recorded modification after the specified date and time
            </summary>
            <param name="since"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.NodeCollection.ToSet">
            <summary>
            Convert this collection to a set, which may be parametrically
            filtered.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.NodeDataStore">
            <summary>
            Extensible storage mechanism for adding attached data to nodes
            </summary>
        </member>
        <member name="M:Nucleus.Model.NodeDataStore.Merge(Nucleus.Model.NodeDataStore)">
            <summary>
            Merge the data in the specified other data store into this one,
            merging existing components of matching types and adding those
            which are unique.
            </summary>
            <param name="other"></param>
        </member>
        <member name="T:Nucleus.Model.NodeDataType">
            <summary>
            Enum to represent the standard built-in data types
            intended for use as attached data on nodes
            </summary>
        </member>
        <member name="T:Nucleus.Model.NodeDataTypeExtensions">
            <summary>
            Static extension methods for the NodeDataType enum
            </summary>
        </member>
        <member name="M:Nucleus.Model.NodeDataTypeExtensions.RepresentedType(Nucleus.Model.NodeDataType)">
            <summary>
            Get the type that this enum value represents
            </summary>
            <param name="nDT"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.NodeGenerationParameters">
            <summary>
            A set of parameters used in the generation of nodes
            </summary>
        </member>
        <member name="P:Nucleus.Model.NodeGenerationParameters.ExInfo">
            <summary>
            The execution info for the operation that the node generation is taking part as part of
            </summary>
        </member>
        <member name="P:Nucleus.Model.NodeGenerationParameters.ConnectionTolerance">
            <summary>
            The distance tolerance for creating connections
            </summary>
        </member>
        <member name="P:Nucleus.Model.NodeGenerationParameters.DisconnectionTolerance">
            <summary>
            The distance tolerance for deleting a previous connection
            </summary>
        </member>
        <member name="P:Nucleus.Model.NodeGenerationParameters.DeleteUnusedNodes">
            <summary>
            Delete encoungered nodes that are no longer connected to elements?
            </summary>
        </member>
        <member name="M:Nucleus.Model.NodeGenerationParameters.#ctor">
            <summary>
            Default constructor.  Initialises a set of parameters with the connection tolerance using 
            the current global geometric tolerance setting.
            </summary>
        </member>
        <member name="M:Nucleus.Model.NodeGenerationParameters.#ctor(System.Double,System.Boolean)">
            <summary>
            Initialises a set of parameters with the specified values.
            </summary>
            <param name="connectionTolerance"></param>
            <param name="deleteUnusedNodes"></param>
        </member>
        <member name="M:Nucleus.Model.NodeGenerationParameters.#ctor(System.Boolean)">
            <summary>
            Initialises a set of parameters with the specified DeleteUnusedNodes value and all
            others set to defaults.
            </summary>
            <param name="deleteUnusedNodes"></param>
        </member>
        <member name="T:Nucleus.Model.NodeSet">
            <summary>
            A parametrically-defined set of Nodes.  
            Allows node collections to be defined via a base collection and a set of logical 
            filters which act upon that collection.
            </summary>
        </member>
        <member name="T:Nucleus.Model.NodeSupport">
            <summary>
            A data component that represents support conditions that can be attached to a node to represent
            restraint in a finite element analysis or physical simulation
            </summary>
        </member>
        <member name="F:Nucleus.Model.NodeSupport._Fixity">
            <summary>
            Private backing field for Fixity property
            </summary>
        </member>
        <member name="P:Nucleus.Model.NodeSupport.Fixity">
            <summary>
            The lateral and rotational directions in which this node is
            fixed for the purpose of structural and physics-based analysis.
            Represented by a set of six booleans, one each for the X, Y, Z, 
            XX,YY and ZZ degrees of freedom.  If true, the node is restrained in
            that direction, if false it is free to move.
            </summary>
        </member>
        <member name="F:Nucleus.Model.NodeSupport._Axes">
            <summary>
            Private backing field for Axes property
            </summary>
        </member>
        <member name="P:Nucleus.Model.NodeSupport.Axes">
            <summary>
            The coordinate axis system to which the fixity directions refer
            </summary>
        </member>
        <member name="F:Nucleus.Model.NodeSupport._Stiffness">
            <summary>
            Private backing field for Stiffness property
            </summary>
        </member>
        <member name="P:Nucleus.Model.NodeSupport.Stiffness">
            <summary>
            The stiffnesses in the translational and rotational degrees of freedom
            of this support.  By default this stiffness is 0 in all directions.
            This property is only considered when the fixity in the relevent direction
            is set to false - otherwise the node is taken to be fully restrained in that
            axis and the stiffness is effectively infinite.
            Expressed in N/m.
            </summary>
        </member>
        <member name="P:Nucleus.Model.NodeSupport.IsFree">
            <summary>
            Does this support not actually restrain the node in any way?
            i.e. are all fixity directions false and all stiffness components zero?
            </summary>
        </member>
        <member name="M:Nucleus.Model.NodeSupport.#ctor">
            <summary>
            Initialise a new node support with no data
            </summary>
        </member>
        <member name="M:Nucleus.Model.NodeSupport.#ctor(Nucleus.Base.Bool6D)">
            <summary>
            Initialise a new node support with the fixed dimensions specified
            </summary>
            <param name="fixity"></param>
        </member>
        <member name="M:Nucleus.Model.NodeSupport.#ctor(Nucleus.Base.Bool6D,Nucleus.Geometry.SixVector)">
            <summary>
            Initialise a new node support with the fixed dimensions specified
            and the given stiffnesses in the other directions
            </summary>
            <param name="fixity"></param>
        </member>
        <member name="M:Nucleus.Model.NodeSupport.#ctor(Nucleus.Base.Bool6D,Nucleus.Model.CoordinateSystemReference)">
            <summary>
            Initialise a new node support with the specified fixed dimensions in the specified
            coordinate system.
            </summary>
            <param name="fixity"></param>
            <param name="axes"></param>
        </member>
        <member name="T:Nucleus.Model.PanelElement">
            <summary>
            A 2D element the geometry of which is determined by a
            set-out surface geometry and a face property which describes
            the cross-thickness properties.
            </summary>
        </member>
        <member name="M:Nucleus.Model.PanelElement.#ctor">
            <summary>
            Default constructor.  Initialises a panel element with no data.
            </summary>
        </member>
        <member name="M:Nucleus.Model.PanelElement.#ctor(Nucleus.Geometry.Surface)">
            <summary>
            Initialises a panel element with the specified set-out
            geometry.
            </summary>
            <param name="geometry">The set-out geometry which defines the shape of
            the element.</param>
        </member>
        <member name="M:Nucleus.Model.PanelElement.OrientateToVector(Nucleus.Geometry.Vector)">
            <summary>
            Orientate this element such that the local X axis at the centre of the element
            will point as closely as possible towards the given vector.
            </summary>
            <param name="vector"></param>
        </member>
        <member name="M:Nucleus.Model.PanelElement.LocalCoordinateSystem">
            <summary>
            Get the local coordinate system of this element
            </summary>
            <param name="t">The normalised parameter along the element at which to retrieve the
            coordinate system.  By default this will be 0 (i.e. the start of the element)</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.PanelElement.GetNominalPosition">
            <summary>
            Get a point in space which nominally describes the position of this element,
            to be used for display attachments and the like.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.NodeTable">
            <summary>
            An extended NodeCollection that also maintains several other temporary
            data structures in order to provide additional fast lookup capabilities
            </summary>
        </member>
        <member name="F:Nucleus.Model.NodeTable._NextNumericID">
            <summary>
            Private backing field for NextNumericID property
            </summary>
        </member>
        <member name="P:Nucleus.Model.NodeTable.NextNumericID">
            <summary>
            The numeric ID that will be assigned to the next element to be added to this table
            </summary>
        </member>
        <member name="F:Nucleus.Model.NodeTable._SpatialTree">
            <summary>
            Private backing member variable for the SpatialTree property
            </summary>
        </member>
        <member name="P:Nucleus.Model.NodeTable.SpatialTree">
            <summary>
            The spatial divided-dimension tree of this node collection.
            Speeds up spatial-based searches of node position.
            Generated automatically when required.
            </summary>
        </member>
        <member name="M:Nucleus.Model.NodeTable.#ctor(Nucleus.Model.Model)">
            <summary>
            Constructor.  Initialises a new NodeTable belonging to the specified model
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Nucleus.Model.NodeTable.ClosestNodeTo(Nucleus.Geometry.Vector,System.Double,Nucleus.Model.Node)">
            <summary>
            Find the closest node in this collection to the
            specified point.  
            </summary>
            <param name="point">The search point</param>
            <param name="maxDistance">The maximum distance within which to look for nodes</param>
            <param name="toBeIgnored">Optional.  A node within this collection that should be
            excluded from the search.  Use when trying to find another node close to the 
            specified one.</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.PanelElementCollection">
            <summary>
            A collection of PanelElements
            </summary>
        </member>
        <member name="M:Nucleus.Model.PanelElementCollection.#ctor">
            <summary>
            Initialise a new blank PanelElementCollection
            </summary>
        </member>
        <member name="M:Nucleus.Model.PanelElementCollection.#ctor(Nucleus.Model.PanelElement)">
            <summary>
            Initialise a new PanelElementCollection containing the specified single element
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Nucleus.Model.PanelElementCollection.Modified(System.DateTime)">
            <summary>
            Get the subset of items in this collection which has a recorded modification 
            after the specified date and time
            </summary>
            <param name="since">The date/time to filter by</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.PanelElementCollection.ToElementCollection">
            <summary>
            Convert this LinearElementCollection to an ElementCollection containing the same elements
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.ParameterProfile">
            <summary>
            Abstract base class for profiles which are defined by numerical
            parameters and have their geometry automatically generated based
            on them.
            </summary>
        </member>
        <member name="F:Nucleus.Model.ParameterProfile._Perimeter">
            <summary>
            Private backing field for the Perimeter property
            </summary>
        </member>
        <member name="P:Nucleus.Model.ParameterProfile.Perimeter">
            <summary>
            The (generated) shape of the outer perimeter of this profile
            </summary>
        </member>
        <member name="F:Nucleus.Model.ParameterProfile._Voids">
            <summary>
            Private backing field for Voids property
            </summary>
        </member>
        <member name="P:Nucleus.Model.ParameterProfile.Voids">
            <summary>
            The collection of curves which denote the edges of internal voids
            within this profile
            </summary>
        </member>
        <member name="F:Nucleus.Model.ParameterProfile._OriginOffset">
            <summary>
            Private backing field for MidPointOffset
            </summary>
        </member>
        <member name="P:Nucleus.Model.ParameterProfile.OriginOffset">
            <summary>
            Get the offset of the origin (/mid-point) of the section profile
            from the set-out location
            </summary>
        </member>
        <member name="F:Nucleus.Model.ParameterProfile._CentroidOffset">
            <summary>
            Private backing field for CentroidOffset property
            </summary>
        </member>
        <member name="P:Nucleus.Model.ParameterProfile.CentroidOffset">
            <summary>
            Get the offset of the area centroid of the section profile from
            the origin.  The total offset of the centroid from the set-out
            point will be OriginOffset + CentroidOffset.
            </summary>
        </member>
        <member name="M:Nucleus.Model.ParameterProfile.GeneratePerimeter">
            <summary>
            Generate the profile's perimeter
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ParameterProfile.GenerateVoids">
            <summary>
            Generate the edge curves of the internal voids.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ParameterProfile.CalculateOriginOffset(Nucleus.Geometry.Vector)">
            <summary>
            Calculate the total offset of the mid-point of this profile
            from the set-out point of the section with the specified horizontal
            and vertical set-out
            </summary>
            <param name="centroid">The centroid of the section profile</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ParameterProfile.CalculateOriginOffset(Nucleus.Geometry.Vector,Nucleus.Geometry.HorizontalSetOut,Nucleus.Geometry.VerticalSetOut)">
            <summary>
            Calculate the total offset of the mid-point of this profile
            from the set-out point of the section with the specified horizontal
            and vertical set-out
            </summary>
            <param name="centroid">The centroid of the section profile</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ParameterProfile.GenerateGeometry">
            <summary>
            Update the stored geometry properties of this profile
            </summary>
        </member>
        <member name="M:Nucleus.Model.ParameterProfile.CalculateCentroidOffset(Nucleus.Geometry.Curve,Nucleus.Geometry.CurveCollection)">
            <summary>
            Calculate the offset of the profile centroid from the origin (mid) point
            </summary>
            <returns></returns>
            <remarks>This basic version calculates the centroid from the perimeter and voids.
            This can be overridden for the sake of efficiency in derived classes to save having
            to calculate the centroid for symmetrical types where the offset is always 0,0</remarks>
        </member>
        <member name="M:Nucleus.Model.ParameterProfile.InvalidateCachedGeometry">
            <summary>
            Invalidate the stored generated geometry 
            </summary>
        </member>
        <member name="T:Nucleus.Model.ResultsCase">
            <summary>
            Abstract base class for cases which produce results
            </summary>
        </member>
        <member name="M:Nucleus.Model.ResultsCase.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Model.ResultsCase.#ctor(System.String)">
            <summary>
            Name constructor
            </summary>
            <param name="name"></param>
        </member>
        <member name="T:Nucleus.Model.SectionProfile">
            <summary>
            Base class for objects representing the profile of a SectionProperty.
            </summary>
        </member>
        <member name="F:Nucleus.Model.SectionProfile._CatalogueName">
            <summary>
            Private backing field for CatalogueName property
            </summary>
        </member>
        <member name="P:Nucleus.Model.SectionProfile.CatalogueName">
            <summary>
            The catalogue name of this profile, if this is a standard profile from
            a catalogue.  If this is a custom section this value will be null.
            </summary>
        </member>
        <member name="P:Nucleus.Model.SectionProfile.CatalogueTypeDesignation">
            <summary>
            The shorthand designating the type of catalogue section, obtained
            from the starting letters of the CatalogueName.  For example, for
            Universal Beams this would be "UB".
            </summary>
        </member>
        <member name="P:Nucleus.Model.SectionProfile.Perimeter">
            <summary>
            The outer perimeter curve of this section profile.
            </summary>
        </member>
        <member name="P:Nucleus.Model.SectionProfile.Voids">
            <summary>
            The collection of curves which denote the voids within this section profile.
            </summary>
        </member>
        <member name="P:Nucleus.Model.SectionProfile.HasVoids">
            <summary>
            Does this profile (potentially) have voids?
            </summary>
        </member>
        <member name="F:Nucleus.Model.SectionProfile._Material">
            <summary>
            Private backing field for Material property.
            </summary>
        </member>
        <member name="P:Nucleus.Model.SectionProfile.Material">
            <summary>
            The primary material assigned to this profile.
            </summary>
        </member>
        <member name="F:Nucleus.Model.SectionProfile._HorizontalSetOut">
            <summary>
            Private backing field for HorizontalSetOut property
            </summary>
        </member>
        <member name="P:Nucleus.Model.SectionProfile.HorizontalSetOut">
            <summary>
            The horizontal position of the base set-out point of the profile.
            This is the point on the profile which will be taken as running along 
            the element set-out curve when this profile is applied as a section property
            to a linear element, modified by the Offset vector.
            </summary>
        </member>
        <member name="F:Nucleus.Model.SectionProfile._VerticalSetOut">
            <summary>
            Private backing field for VerticalSetOut property
            </summary>
        </member>
        <member name="P:Nucleus.Model.SectionProfile.VerticalSetOut">
            <summary>
            The vertical position of the base set-out point of the profile.
            This is the point on the profile which will be taken as running along
            the element set-out curve when this profile is applied as a section property
            to a linear element, modified by the Offset vector.
            </summary>
        </member>
        <member name="F:Nucleus.Model.SectionProfile._Offset">
            <summary>
            Private backing field for Offset property
            </summary>
        </member>
        <member name="P:Nucleus.Model.SectionProfile.Offset">
            <summary>
            The set-out offset vector of this profile.  This describes the position of the
            base set-out point defined by the VerticalSetOut and HorizontalSetOut properties
            relative to the actual point along which the set-out curve is assumed to run when
            this profile is applied as a section profile to a linear element.
            </summary>
        </member>
        <member name="F:Nucleus.Model.SectionProfile._Section">
            <summary>
            Private backing field for Section property
            </summary>
        </member>
        <member name="P:Nucleus.Model.SectionProfile.Section">
            <summary>
            The section to which this profile belongs
            </summary>
        </member>
        <member name="P:Nucleus.Model.SectionProfile.OverallDepth">
            <summary>
            Get the overall depth of this section profile.
            This is a utility property common to all profile types
            regardless of how their parameters are actually defined.
            It gives the overall bounding dimension of the 
            (i.e. the depth between extreme points).
            </summary>
        </member>
        <member name="P:Nucleus.Model.SectionProfile.OverallWidth">
            <summary>
            Get the overall width of this section profile.
            This is a utility property common to all profile types
            regardless of how their parameters are actually defined.
            It gives the overall bounding dimension of the profile
            (i.e. the width between extreme points).
            </summary>
        </member>
        <member name="F:Nucleus.Model.SectionProfile._Area">
            <summary>
            Private backing field for the Area property
            </summary>
        </member>
        <member name="P:Nucleus.Model.SectionProfile.Area">
            <summary>
            The cross-sectional area of the profile, in m².
            Will be calculated automatically where necessary if not
            populated manually.
            </summary>
        </member>
        <member name="F:Nucleus.Model.SectionProfile._Ixx">
            <summary>
            Private backing field for the Ixx property.
            </summary>
        </member>
        <member name="P:Nucleus.Model.SectionProfile.Ixx">
            <summary>
            The second moment of area of the profile about the major 
            (X-X) axis, in m^4.
            Will be calculated automatically where necessary if not
            populated manually.
            </summary>
        </member>
        <member name="F:Nucleus.Model.SectionProfile._Iyy">
            <summary>
            Private backing field for the Iyy property.
            </summary>
        </member>
        <member name="P:Nucleus.Model.SectionProfile.Iyy">
            <summary>
            The second moment of area of the profile about the minor
            (Y-Y) axis, in m^4.
            Will be calculated automatically where necessary if not
            populated manually.
            </summary>
        </member>
        <member name="M:Nucleus.Model.SectionProfile.SetOut(Nucleus.Geometry.HorizontalSetOut,Nucleus.Geometry.VerticalSetOut)">
            <summary>
            Set the set-out point of this profile defined by horizontal and vertical set-out rules.
            </summary>
            <param name="horizontal">The horizontal set-out rule</param>
            <param name="vertical">The vertical set-out rule</param>
        </member>
        <member name="M:Nucleus.Model.SectionProfile.SetOut(Nucleus.Geometry.HorizontalSetOut,Nucleus.Geometry.VerticalSetOut,Nucleus.Geometry.Vector)">
            <summary>
            Set the set-out point of this profile defined by horizontal and vertical set-out rules.
            </summary>
            <param name="horizontal">The horizontal set-out rule</param>
            <param name="vertical">The vertical set-out rule</param>
            <param name="offset">The offset of the section relative to the the base set-out point</param>
        </member>
        <member name="M:Nucleus.Model.SectionProfile.InvalidateCachedGeometry">
            <summary>
            Invalidate the stored generated geometry 
            </summary>
        </member>
        <member name="M:Nucleus.Model.SectionProfile.CalculateArea">
            <summary>
            Calculate the cross-sectional area of this profile
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.SectionProfile.CalculateIxx">
            <summary>
            Calculate the second moment of area of this profile about the X-X axis
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.SectionProfile.CalculateIyy">
            <summary>
            Calculate the second moment of area of this profile about the Y-Y axis
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.SectionProfile.GetTotalOffset(Nucleus.Geometry.HorizontalSetOut,Nucleus.Geometry.VerticalSetOut)">
            <summary>
            Calculate the total combined offset of the centroid of the profile to the specified set-out location
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.SectionProfile.SectionClass(System.Double,System.Double,System.Double)">
            <summary>
            Determine and return the classification of this section according to Eurocode 3
            Section 5.5.  The cross-section
            </summary>
            <param name="compression">The axial force in the section, in N.
            Compression is positive, tension is negative.</param>
            <param name="bendingXX">Bending in the section about the local XX axis</param>
            <param name="bendingYY">Bending in the section about the local YY axis</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.SectionProfile.InternalCompressionCOverT">
            <summary>
            Get the value of c/t to be used when determining the cross-section
            class for this section profile
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.SectionProfile.GenerateDescription">
            <summary>
            Generate the string description of this profile
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.SectionProfile.FromDescription(System.String,Nucleus.Model.SectionProfileLibrary)">
            <summary>
            Create a new SectionProfile based on a string description.
            </summary>
            <param name="description"></param>
            <param name="catalogue"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.SectionProfile.TokeniseDimensionString(System.String)">
            <summary>
            Split the specified dimesion string into its constituent parts for subsequent
            parsing as dimension parameters
            </summary>
            <param name="dimensionString"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.RectangularHollowProfile">
            <summary>
            A profile which is rectangular and hollow, consisting
            of two webs and two flanges
            </summary>
        </member>
        <member name="F:Nucleus.Model.RectangularHollowProfile._FlangeThickness">
            <summary>
            Private backing field for FlangeThickness property
            </summary>
        </member>
        <member name="P:Nucleus.Model.RectangularHollowProfile.FlangeThickness">
            <summary>
            The thickness of the top and bottom flange plates
            of the section.
            </summary>
        </member>
        <member name="F:Nucleus.Model.RectangularHollowProfile._WebThickness">
            <summary>
            Private backing field for WebThickness property
            </summary>
        </member>
        <member name="P:Nucleus.Model.RectangularHollowProfile.WebThickness">
            <summary>
            The thickness of the left and right web plates
            of the section
            </summary>
        </member>
        <member name="P:Nucleus.Model.RectangularHollowProfile.HasVoids">
            <summary>
            Does this profile (potentially) have voids?
            </summary>
        </member>
        <member name="M:Nucleus.Model.RectangularHollowProfile.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Model.RectangularHollowProfile.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initialises a rectangular hollow section with the specified dimensions
            </summary>
            <param name="depth"></param>
            <param name="width"></param>
            <param name="flangeThickness"></param>
            <param name="webThickness"></param>
        </member>
        <member name="M:Nucleus.Model.RectangularHollowProfile.#ctor(System.String)">
            <summary>
            Initialise a rectangular hollow profile based on dimensions specified by a string.
            The string should consist of numeric values in mm separated by spaces,
            x's or the multiplication sign '×' and in the order Depth, Width, Flange Thickness,
            Web Thickness, Corner Radius
            Corner Radius
            </summary>
            <param name="dimensionString"></param>
        </member>
        <member name="T:Nucleus.Model.RectangularProfile">
            <summary>
            Parametric profile type to represent rectangular profiles and
            to act as a base class for section types which have a broadly
            rectangular shape and posess width and height dimensions.
            </summary>
        </member>
        <member name="F:Nucleus.Model.RectangularProfile._Depth">
            <summary>
            Private backing member variable for the Depth property
            </summary>
        </member>
        <member name="P:Nucleus.Model.RectangularProfile.Depth">
            <summary>
            The depth of the section
            </summary>
        </member>
        <member name="F:Nucleus.Model.RectangularProfile._Width">
            <summary>
            Private backing member variable for the Width property
            </summary>
        </member>
        <member name="P:Nucleus.Model.RectangularProfile.Width">
            <summary>
            The width of the section
            </summary>
        </member>
        <member name="F:Nucleus.Model.RectangularProfile._CornerRadius">
            <summary>
            Private backing field for CornerRadius property
            </summary>
        </member>
        <member name="P:Nucleus.Model.RectangularProfile.CornerRadius">
            <summary>
            The radius of the corners of the section
            </summary>
        </member>
        <member name="P:Nucleus.Model.RectangularProfile.OverallDepth">
            <summary>
            Get the overall depth of this section profile.
            This is a utility property common to all profile types
            regardless of how their parameters are actually defined.
            It gives the overall bounding dimension of the profile
            (i.e. the depth between extreme points).
            </summary>
        </member>
        <member name="P:Nucleus.Model.RectangularProfile.OverallWidth">
            <summary>
            Get the overall width of this section profile.
            This is a utility property common to all profile types
            regardless of how their parameters are actually defined.
            It gives the overall bounding dimension of the profile
            (i.e. the width between extreme points).
            </summary>
        </member>
        <member name="M:Nucleus.Model.RectangularProfile.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Model.RectangularProfile.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Initialises a Rectangular profile with the specified depth and width
            </summary>
            <param name="depth">The depth of the section</param>
            <param name="width">The width of the section</param>
        </member>
        <member name="M:Nucleus.Model.RectangularProfile.#ctor(System.String)">
            <summary>
            Initialise a rectangular profile based on dimensions specified by a string.
            The string should consist of numeric values in mm separated by spaces,
            x's or the multiplication sign '×' and in the order Depth, Width,
            Corner Radius
            </summary>
            <param name="dimensionString"></param>
        </member>
        <member name="T:Nucleus.Model.SectionProfileCollection">
            <summary>
            A collection of section profiles
            </summary>
        </member>
        <member name="M:Nucleus.Model.SectionProfileCollection.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Model.SectionProfileCollection.#ctor(Nucleus.Model.SectionProfile)">
            <summary>
            Initialise a new SectionProfileCollection containing the specified profile
            </summary>
            <param name="profile"></param>
        </member>
        <member name="M:Nucleus.Model.SectionProfileCollection.GetByCatalogueName(System.String)">
            <summary>
            Find and return the first profile in this collection
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.SectionProfileCollection.LoadFromCSV(Nucleus.Base.FilePath)">
            <summary>
            Add profiles to this collection by loading them from a CSV library file
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="M:Nucleus.Model.SectionProfileCollection.LoadFromCSV(System.IO.Stream)">
            <summary>
            Add profiles to this collection by loading them from a CSV library file
            accessed via a stream
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="M:Nucleus.Model.SectionProfileCollection.LoadFromCSVString(System.String)">
            <summary>
            Add profiles to this collection by loading them from a CSV string
            </summary>
            <param name="csvString"></param>
        </member>
        <member name="M:Nucleus.Model.SectionProfileCollection.GetByMinimumArea(System.Double)">
            <summary>
            Find and return the section profile in this collection with the smallest
            cross-sectional area that is greater than the specified value
            </summary>
            <param name="area"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.SectionProfileLibrary">
            <summary>
            A library of standard section profiles
            </summary>
        </member>
        <member name="T:Nucleus.Model.SectionFamily">
            <summary>
            An element section family -
            A family which describes a section which should be
            swept along the set-out curve of a linear element in
            order to produce a 3D solid geometry.
            </summary>
        </member>
        <member name="F:Nucleus.Model.SectionFamily._Profile">
            <summary>
            Private backing member variable for the Profile property
            </summary>
        </member>
        <member name="P:Nucleus.Model.SectionFamily.Profile">
            <summary>
            The description of the profile of this section property
            </summary>
        </member>
        <member name="P:Nucleus.Model.SectionFamily.ProfileType">
            <summary>
            Get or set the type of the assigned profile
            </summary>
        </member>
        <member name="P:Nucleus.Model.SectionFamily.Profiles">
            <summary>
            The collection of profiles which make up the section
            </summary>
        </member>
        <member name="M:Nucleus.Model.SectionFamily.#ctor">
            <summary>
            Default constructor.  Initialises a new section property with blank data 
            </summary>
        </member>
        <member name="M:Nucleus.Model.SectionFamily.#ctor(Nucleus.Model.SectionProfile)">
            <summary>
            Initialises a section property with the given profile
            </summary>
            <param name="profile"></param>
        </member>
        <member name="M:Nucleus.Model.SectionFamily.#ctor(System.String,Nucleus.Model.SectionProfile)">
            <summary>
            Initialises a section property with the given name and profile
            </summary>
            <param name="name"></param>
            <param name="profile"></param>
        </member>
        <member name="M:Nucleus.Model.SectionFamily.NotifyProfileChanged(Nucleus.Model.SectionProfile)">
            <summary>
            Notify this section that one of its constutuent profiles has been modified
            </summary>
            <param name="profile"></param>
        </member>
        <member name="M:Nucleus.Model.SectionFamily.ChangeProfileType``1">
            <summary>
            Change the type of profile of this section, copying across as much data as possible
            </summary>
            <typeparam name="TProfile">The type of the new profile</typeparam>
            <returns>The </returns>
        </member>
        <member name="M:Nucleus.Model.SectionFamily.ChangeProfieType(System.Type)">
            <summary>
            Change the type of profile of this section, copying across as much data as possible
            </summary>
            <param name="newType">The type of the new profile.  Must be a non-abstract subtype of SectionProfile</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.SectionFamily.GetPrimaryMaterial">
            <summary>
            Get the material of the outermost profile of this section
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.SectionFamily.EquivalentIxx">
            <summary>
            Get the overall second moment of area about the X-X (major) axis
            for this section.  If this section is composite, this will return the
            equivalent Ixx value if the entire section is composed of its primary 
            material - NOT IMPLEMENTED YET!
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.SectionFamily.EquivalentIyy">
            <summary>
            Get the overall second moment of area about the Y-Y (minor) axis
            for this section.  If this section is composite, this will return the
            equivalent Ixx value if the entire section is composed of its primary 
            material - NOT IMPLEMENTED YET!
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.SectionFamily.GetAxialStiffness">
            <summary>
            Calculate the combined axial stiffness of this section, in N/m
            </summary>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nucleus.Model.SectionFamily.GetArea(Nucleus.Model.Material)" -->
        <member name="M:Nucleus.Model.SectionFamily.GetTotalOffset(Nucleus.Geometry.HorizontalSetOut,Nucleus.Geometry.VerticalSetOut)">
            <summary>
            Calculate the total combined offset of the centroid of the section to the specified set-out location
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.SectionFamilyCollection">
            <summary>
            A collection of Section Families
            </summary>
        </member>
        <member name="M:Nucleus.Model.SectionFamilyCollection.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Model.SectionFamilyCollection.#ctor(Nucleus.Model.SectionFamily)">
            <summary>
            Initialise a new SectionFamilyCollection containing the specified single item
            </summary>
            <param name="section"></param>
        </member>
        <member name="M:Nucleus.Model.SectionFamilyCollection.#ctor(System.Collections.Generic.IEnumerable{Nucleus.Model.SectionFamily})">
            <summary>
            Initialise a new SectionFamilyCollection containing the specified set of sections
            </summary>
            <param name="sections"></param>
        </member>
        <member name="T:Nucleus.Model.SymmetricIProfile">
            <summary>
            Represents profiles shaped like a capital 'I' with a single web and
            top and bottom flanges of the same width.
            </summary>
        </member>
        <member name="M:Nucleus.Model.SymmetricIProfile.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Model.SymmetricIProfile.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initialises an I-profile
            </summary>
            <param name="depth">The depth of the section</param>
            <param name="width">The width of the section</param>
            <param name="flangeThickness">The thickness of the top and bottom flange plates</param>
            <param name="webThickness">The thickness of the web</param>
            <param name="rootRadius">The fillet root radius between web and flange</param>
        </member>
        <member name="M:Nucleus.Model.SymmetricIProfile.#ctor(System.String)">
            <summary>
            Initialise an I-profile based on dimensions specified by a string.
            The string should consist of numeric values in mm separated by spaces,
            x's or the multiplication sign '×' and in the order Depth, Width,
            Flange Thickness, Web Thickness, Root Radius
            </summary>
            <param name="dimensionString"></param>
        </member>
        <member name="T:Nucleus.Model.TProfile">
            <summary>
            Represents profiles shaped like a captial 'T' consisting of a top flange only
            and web.
            </summary>
        </member>
        <member name="M:Nucleus.Model.TProfile.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Model.TProfile.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initialises a T-profile with the specified parameters
            </summary>
            <param name="depth">The depth of the section</param>
            <param name="width">The width of the section</param>
            <param name="flangeThickness">The thickness of the flange</param>
            <param name="webThickness">The thickness of the web</param>
            <param name="rootRadius">The fillet root radius between web and flange</param>
        </member>
        <member name="M:Nucleus.Model.TProfile.#ctor(System.String)">
            <summary>
            Initialise a T-profile based on dimensions specified by a string.
            The string should consist of numeric values in mm separated by spaces,
            x's or the multiplication sign '×' and in the order Depth, Width,
            Flange Thickness, Web Thickness, Root Radius
            </summary>
            <param name="dimensionString"></param>
        </member>
        <member name="T:Nucleus.Model.Family">
            <summary>
            Base class for element families, which are
            a shared property that describes how to resolve
            an element's editable set-out geometry into a full
            3D solid object.
            </summary>
        </member>
        <member name="M:Nucleus.Model.Family.Elements">
            <summary>
            Get a collection of all elements in the same model which have this property assigned
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Family.GetPrimaryMaterial">
            <summary>
            Get the primary material of which this family is composed.
            This will be the material of the outer profile for Sections,
            the thickest layer for Build-Up families and so on.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.ModelDocument">
            <summary>
            A document which contains and stores a model
            </summary>
        </member>
        <member name="F:Nucleus.Model.ModelDocument._Model">
            <summary>
            Private backing field for Model property.
            </summary>
        </member>
        <member name="P:Nucleus.Model.ModelDocument.Model">
            <summary>
            The model contained within this document.
            </summary>
        </member>
        <member name="F:Nucleus.Model.ModelDocument._IDMappings">
            <summary>
            Private backing field for IDMappings property
            </summary>
        </member>
        <member name="P:Nucleus.Model.ModelDocument.IDMappings">
            <summary>
            A record of the ID mapping tables generated when reading this document from or
            writing it to files of other data types.
            This data can be used to synchronise with other data files and read/write data in a
            consistent form.
            </summary>
        </member>
        <member name="M:Nucleus.Model.ModelDocument.#ctor">
            <summary>
            Default constructor.
            Will create a new model.
            </summary>
        </member>
        <member name="M:Nucleus.Model.ModelDocument.#ctor(Nucleus.Model.Model)">
            <summary>
            Model constructor.  Initialises a ModelDocument containing the specified model.
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Nucleus.Model.ModelDocument.#ctor(Nucleus.Base.FilePath,Nucleus.Model.Model)">
            <summary>
            FilePath, Model constructor.  Initialises a ModelDocument with the specified model
            loaded from the specified filePath.
            </summary>
            <param name="filePath"></param>
            <param name="model"></param>
        </member>
        <member name="M:Nucleus.Model.ModelDocument.SaveAs(Nucleus.Base.FilePath,Nucleus.IO.TextFormat)">
            <summary>
            Save this document to the specified location
            in the specified text format
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filePath">The filepath to save to</param>
            <param name="format">The text format to save in</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelDocument.MergeIn(Nucleus.Model.ModelDocument)">
            <summary>
            Merge the contents of another ModelDocument into this one.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.ModelDocument.Load(Nucleus.Base.FilePath)">
            <summary>
            Load a ModelDocument from a file stored in binary format
            </summary>
            <param name="filePath">The path of the file to be loaded.</param>
            <returns>The loaded document, if a document could indeed be loaded.
            Else, null.</returns>
        </member>
        <member name="T:Nucleus.Model.Element">
            <summary>
            Abstract base class for Elements - objects which represent physical model
            entities and which are defined by a set-out geometry which describes the
            overall abstract form of the element and by a volumetric property which
            determines how that design representation converts into a 3D solid object.
            </summary>
        </member>
        <member name="P:Nucleus.Model.Element.Nodes">
            <summary>
            Get a collection containing all of the nodes attached to this element's
            geometry.  This collection will be generated as necessary and adding or removing
            objects from it will not have any effect on the geometry.
            </summary>
        </member>
        <member name="P:Nucleus.Model.Element.Nucleus#Model#IElement#Geometry">
            <summary>
            IElement Geometry implementation
            </summary>
        </member>
        <member name="P:Nucleus.Model.Element.Nucleus#Model#IElement#Family">
            <summary>
            IElement Family implementation
            </summary>
        </member>
        <member name="F:Nucleus.Model.Element._Orientation">
            <summary>
            Private backing field for Orientation property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Element.Orientation">
            <summary>
            The orientation description of this element - determines the relative orientation
            of the local coordinate system of this element.
            </summary>
        </member>
        <member name="P:Nucleus.Model.Element.Description">
            <summary>
            Get a description of this element.
            Will be the element's name if it has one or will return "Element {ID}"
            if not.
            </summary>
        </member>
        <member name="P:Nucleus.Model.Element.ElementVertices">
            <summary>
            Get a collection of element vertex wrappers for this element
            </summary>
        </member>
        <member name="M:Nucleus.Model.Element.GetElementVertexDescription(System.Int32,Nucleus.Geometry.VertexCollection)">
            <summary>
            Generate a text string to be used to describe the position of the element vertex
            in the specified position  in the specified collection.
            </summary>
            <param name="index"></param>
            <param name="vertices"></param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Model.Element.Item(System.Int32)">
            <summary>
            Get the element vertex wrapper for the specified vertex index
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Element.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Nucleus.Model.Element.#ctor(System.String)">
            <summary>
            Name constructor.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Nucleus.Model.Element.#ctor(Nucleus.Model.Element)">
            <summary>
            Duplication constructor
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Nucleus.Model.Element.NotifyGeometryUpdated">
            <summary>
            Notify this element that one or more of its vertices or another aspect
            of its geometric definition has been altered.
            or has been updated
            </summary>
        </member>
        <member name="M:Nucleus.Model.Element.GetGeometry">
            <summary>
            Protected internal function to return this element's geometry as a shape
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Element.GetFamily">
            <summary>
            IElement Family implementation
            </summary>
        </member>
        <member name="M:Nucleus.Model.Element.GetNominalPosition">
            <summary>
            Get a point in space which nominally describes the position of this element,
            to be used for display attachments and the like.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Element.GenerateNodes(Nucleus.Model.NodeGenerationParameters)">
            <summary>
            Generate nodes for this element's vertices, if they do not already posess them
            them.  This relies on the element being included as part of a Model to function.
            </summary>
            <param name="options">The node generation options</param>
        </member>
        <member name="M:Nucleus.Model.Element.GenerateNodes(Nucleus.Model.NodeGenerationParameters,Nucleus.Model.NodeCollection,Nucleus.DDTree.NodeDDTree)">
            <summary>
            Generate nodes for this element's vertices, if they do not already posess them
            them.  This override of the GenerateNodes function does not require the element
            to be part of a Model.
            </summary>
            <param name="options">The node generation options</param>
        </member>
        <member name="M:Nucleus.Model.Element.ContainsNode(Nucleus.Model.Node)">
            <summary>
            Does this element's geometry contain a reference to the specified node?
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Element.OrientateToVector(Nucleus.Geometry.Vector)">
            <summary>
            Modify the orientation of this element so that the appropriate axis
            of the local coordinate system (Z for linear elements, X for panels)
            points as closely as possible towards the specified guide vector.
            </summary>
            <param name="vector"></param>
        </member>
        <member name="T:Nucleus.Model.Element`2">
            <summary>
            Generic base class for elements - objects which represent physical model
            entities and which are defined by a set-out geometry which describes the
            overall abstract form of the element and by a volumetric property which
            determines how that design representation converts into a 3D solid object.
            </summary>
        </member>
        <member name="F:Nucleus.Model.Element`2._Geometry">
            <summary>
            Private backing member variable for the Geometry property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Element`2.Geometry">
            <summary>
            The set-out geometry of the element.
            Describes the editable control geometry that primarily defines
            the overall geometry of this object.
            The set-out curve of 1D Elements, the surface of slabs, etc.
            The assigned object should not already be assigned to any other
            element.
            When setting, the previous geometry (if any) will have any attached nodes removed
            to prevent memory leaks.
            If you wish to set the geometry of this element but retain existing attached
            data such as vertex nodes, use the ReplaceGeometry function instead of directly
            setting this property.
            </summary>
        </member>
        <member name="M:Nucleus.Model.Element`2.ReplaceGeometry(`0,System.Boolean)">
            <summary>
            Replace the set-out geometry of this element, automatically copying over any relevant data
            attached to the original geometry such as vertex nodes and cleaning up any residual data on
            the old geometry to prevent memory leaks.
            </summary>
            <param name="newGeometry"></param>
            <param name="copyOnlyIfCoincident">If true, data will only be copied between
            vertices if the old and new vertex are within tolerance of one another.
            If false (default) data will be copied regardless.</param>
        </member>
        <member name="F:Nucleus.Model.Element`2._DerivedGeometry">
            <summary>
            Private backing field for the DerivedGeometry property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Element`2.DerivedGeometry">
            <summary>
            Storage for derived geometric objects attached to this element.
            These represent geometric forms that the element may be represented by
            or may attain under certain circumstances (such as structural deflection plots)
            but they do not form part of the idealised defining geometry of the element - for
            the set-out geometry of the element consult the Geometry property instead.
            NOTE: Currently Not Serialized - temporary data only
            </summary>
        </member>
        <member name="F:Nucleus.Model.Element`2._Family">
            <summary>
            Private backing member variable for the Family property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Element`2.Family">
            <summary>
            The element family to which this element belongs.  The element family
            is a volumetric property that describes how the editable set-out 
            geometry of this element should be interpreted to produce a 
            full 3D solid object and which may be shared by multiple elements.
            </summary>
        </member>
        <member name="M:Nucleus.Model.Element`2.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Nucleus.Model.Element`2.#ctor(System.String)">
            <summary>
            Name constructor.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Nucleus.Model.Element`2.#ctor(Nucleus.Model.Element{`0,`1})">
            <summary>
            Duplication constructor
            </summary>
            <param name="other"></param>
        </member>
        <member name="T:Nucleus.Model.ElementExtensions">
            <summary>
            Static extension methods for the Element class
            </summary>
        </member>
        <member name="M:Nucleus.Model.ElementExtensions.TotalLength``3(``0)">
            <summary>
            Calculate the total length (of the set-out geometry curves) of all elements
            in this collection.
            </summary>
            <typeparam name="TList"></typeparam>
            <typeparam name="TElement"></typeparam>
            <typeparam name="TFamily"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.IElement">
            <summary>
            Entities posessing geometry defined by a set of vertices
            and potentially a set of attached data defining additional properties.
            The IElement interface provides a simple way of interacting with elements without needing to
            define specific generic parameters.
            </summary>
        </member>
        <member name="P:Nucleus.Model.IElement.Geometry">
            <summary>
            The set-out geometry of the element.
            Describes the editable control geometry that primarily defines
            the overall geometry of this object.
            The set-out curve of 1D Elements, the surface of slabs, etc.
            </summary>
        </member>
        <member name="P:Nucleus.Model.IElement.Family">
            <summary>
            The volumetric family that describes how the editable set-out 
            geometry of this element should be interpreted to produce a 
            full 3D solid object
            </summary>
        </member>
        <member name="P:Nucleus.Model.IElement.Orientation">
            <summary>
            The orientation angle of thi
            </summary>
        </member>
        <member name="M:Nucleus.Model.IElement.NotifyGeometryUpdated">
            <summary>
            Notify this element that it's geometric representation has been updated.
            This may prompt related properties to be invalidated or updated.
            </summary>
        </member>
        <member name="T:Nucleus.Model.Model">
            <summary>
            A self-contained data structure that represents an entire
            BIM or analysis model.
            </summary>
        </member>
        <member name="E:Nucleus.Model.Model.ObjectAdded">
            <summary>
            Event raised when an object is added to the model
            </summary>
        </member>
        <member name="E:Nucleus.Model.Model.ObjectPropertyChanged">
            <summary>
            Event raised when a property of an object in this model is changed.
            Bubbles the property changed event upwards.
            </summary>
        </member>
        <member name="F:Nucleus.Model.Model._Elements">
            <summary>
            Private backing field for Elements property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Model.Elements">
            <summary>
            Get the collection of elements that form the geometric representation 
            of this model.
            </summary>
        </member>
        <member name="F:Nucleus.Model.Model._Nodes">
            <summary>
            Private backing field for Nodes property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Model.Nodes">
            <summary>
            Get the collection of nodes that belong to this model.
            </summary>
        </member>
        <member name="F:Nucleus.Model.Model._Levels">
            <summary>
            Private backing field for Levels property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Model.Levels">
            <summary>
            Get the collection of Levels that belong to this model
            </summary>
        </member>
        <member name="F:Nucleus.Model.Model._CoordinateSystems">
            <summary>
            Private backing field for CoordinateSystems property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Model.CoordinateSystems">
            <summary>
            Get the collection of user-defined coordinate systems that belong to this model
            </summary>
        </member>
        <member name="F:Nucleus.Model.Model._Families">
            <summary>
            Private backing field for Families property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Model.Families">
            <summary>
            Get the collection of families that belong to this model.
            </summary>
        </member>
        <member name="F:Nucleus.Model.Model._Materials">
            <summary>
            Private backing field for Materials property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Model.Materials">
            <summary>
            Get the collection of materials that belong to this model
            </summary>
        </member>
        <member name="F:Nucleus.Model.Model._Sets">
            <summary>
            Private backing field for the Sets property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Model.Sets">
            <summary>
            The collection of stored sets that belong to this model.
            Sets represent parametric groupings of model objects that can be referenced
            in load applications etc.
            </summary>
        </member>
        <member name="F:Nucleus.Model.Model._Loads">
            <summary>
            Private backing field for Loads property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Model.Loads">
            <summary>
            The loads applied to this model
            </summary>
        </member>
        <member name="F:Nucleus.Model.Model._LoadCases">
            <summary>
            Private backing field for Loading property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Model.LoadCases">
            <summary>
            The load cases stored in this model
            </summary>
        </member>
        <member name="P:Nucleus.Model.Model.Everything">
            <summary>
            Get a single flat collection which contains all sub-objects within
            this model, for easy iteration through the entire database in one go.
            This collection is compiled when called from the different sub-tables
            within the model - it is not stored and modifying this collection
            will not result in any changes being made to the model itself.
            Use the Elements, Nodes, Properties, Materials etc. properties instead 
            to modify the model.
            </summary>
        </member>
        <member name="P:Nucleus.Model.Model.AllTables">
            <summary>
            Get all of the object tables in this Model.
            </summary>
        </member>
        <member name="F:Nucleus.Model.Model._Variables">
            <summary>
            Private backing field for UserVariables property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Model.Variables">
            <summary>
            The set of stored user variables to be used as an evaluation context
            for parametric expressions on objects within this model
            </summary>
        </member>
        <member name="F:Nucleus.Model.Model._BoundingBox">
            <summary>
            Private backing field for BoundingBox property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Model.BoundingBox">
            <summary>
            Get the bounding box of this model.  Calculated and cached as needed
            based on element geometry.
            </summary>
        </member>
        <member name="P:Nucleus.Model.Model.Create">
            <summary>
            Create new objects in this model.  Returns a ModelObjectCreator instance which
            provides factory functionality to create new objects within this model and to
            track their creation history.  The functions accessed via this property will normally
            create new objects and add them to the model, but if the execution information matches
            that of a stored object that object will be updated and returned instead.  This
            allows objects to be easily created and updated via parametric processes.
            Model objects may alternately be instantiated and added to the model manually,
            however this will not track their creation history.
            </summary>
        </member>
        <member name="F:Nucleus.Model.Model._History">
            <summary>
            Private backing field for History property
            </summary>
        </member>
        <member name="P:Nucleus.Model.Model.History">
            <summary>
            Record of the creation history of objects within this model.
            Used by the model object creator to replace or update previously created objects from
            the same source.
            </summary>
        </member>
        <member name="P:Nucleus.Model.Model.Item(System.Guid)">
            <summary>
            Get the object with the specified GUID, if it can be found in this model.
            </summary>
            <param name="guid"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Model.#ctor">
            <summary>
            Default constructor.  Initialises a new empty model.
            </summary>
        </member>
        <member name="M:Nucleus.Model.Model.Add(Nucleus.Model.ModelObjectCollection)">
            <summary>
            Try to add a collection of modelobjects to the model, if they are of a
            suitable type and do not already exist within it.  The correct storage
            table(s) will be automatically selected based on the object's type.
            </summary>
            <param name="objects">The collection of objects to add to the model</param>
            <returns>True if any of the objects in the collection could be added,
            else false.</returns>
        </member>
        <member name="M:Nucleus.Model.Model.Add``1(System.Collections.Generic.IList{``0})">
            <summary>
            Try to add a collection of modelobjects to the model, if they are of a
            suitable type and do not already exist within it.  The correct storage
            table(s) will be automatically selected based on the object's type.
            </summary>
            <param name="objects">The collection of objects to add to the model</param>
            <returns>True if any of the objects in the collection could be added,
            else false.</returns>
        </member>
        <member name="M:Nucleus.Model.Model.Add(Nucleus.Model.ModelObject)">
            <summary>
            Try to add a new modelobject to the model, if it is of a suitable type
            and does not already exist within it.  The correct storage table will be
            automatically selected based on the object's type.
            </summary>
            <param name="mObj"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Model.Add(Nucleus.Model.Element)">
            <summary>
            Add a new element to this model, if it does not already exist within it.
            </summary>
            <param name="element">The element to be added</param>
            <returns>True if the element could be added, false if it already existed within
            the model.</returns>
        </member>
        <member name="M:Nucleus.Model.Model.Add(Nucleus.Model.Node)">
            <summary>
            Add a new node to this model, if it does not already exist within it
            </summary>
            <param name="node">The node to be added.</param>
            <returns>True if the node could be added, false if it already existed within
            the model.</returns>
        </member>
        <member name="M:Nucleus.Model.Model.Add(Nucleus.Model.UserCoordinateSystemReference)">
            <summary>
            Add a new user-defined coordinate system to this model, if it does not
            already exist within it
            </summary>
            <param name="cSystem">The user-defined coordinate system to be added.</param>
            <returns>True if the coordinate system could be added, 
            false if it already existed within the model.</returns>
        </member>
        <member name="M:Nucleus.Model.Model.Add(Nucleus.Model.Level)">
            <summary>
            Add a new level to this model, if it does not already exist within it
            </summary>
            <param name="level">The level to be added.</param>
            <returns>True if the level could be added, false if it already existed within
            the model.</returns>
        </member>
        <member name="M:Nucleus.Model.Model.Add(Nucleus.Model.Family)">
            <summary>
            Add a new property to this model, if it does not already exist within it
            </summary>
            <param name="property">The property to be added.</param>
            <returns>True if the property could be added, false if it already existed within
            the model.</returns>
        </member>
        <member name="M:Nucleus.Model.Model.Add(Nucleus.Model.Material)">
            <summary>
            Add a new material to this model, if it does not already exist within it
            </summary>
            <param name="material">The material to be added.</param>
            <returns>True if the material could be added, false if it already existed within
            the model.</returns>
        </member>
        <member name="M:Nucleus.Model.Model.Add(Nucleus.Model.ModelObjectSetBase)">
            <summary>
            Add a new object set to this model, if it does not already exist within it
            </summary>
            <param name="set">The set to be added.</param>
            <returns>True if the material could be added, false if it had already
            been added to  the model.</returns>
        </member>
        <member name="M:Nucleus.Model.Model.Add(Nucleus.Model.LoadCase)">
            <summary>
            Add a new load case to this model, if it does not already exist within it
            </summary>
            <param name="loadCase">The load case to be added.</param>
            <returns>True if the load case could be added, false if it had already
            been added to the model.</returns>
        </member>
        <member name="M:Nucleus.Model.Model.Add(Nucleus.Model.Loading.Load)">
            <summary>
            Add a new load to this model, if it does not already exist within it
            </summary>
            <param name="load">The load to be added</param>
            <returns>True if the load could be added, false if it had already been added to the model.</returns>
        </member>
        <member name="M:Nucleus.Model.Model.Register(Nucleus.Model.ModelObject)">
            <summary>
            Register a new object with this model for event handling
            </summary>
            <param name="unique"></param>
        </member>
        <member name="M:Nucleus.Model.Model.GetObject(System.Guid)">
            <summary>
            Get the object with the specified GUID, if it can be found in this model.
            </summary>
            <param name="guid"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Model.GetTableFor(System.Type)">
            <summary>
            Get the table from this model (if any) responsible for storing the specified type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Model.GetByNumericID(System.Type,System.Int64)">
            <summary>
            Find and return an object in this model by it's type and numeric ID
            </summary>
            <param name="type"></param>
            <param name="numericID"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Model.GetByNumericID``1(System.Int64)">
            <summary>
            Find and return an object in this model of the specified type with the
            specifed numeric ID
            </summary>
            <typeparam name="T"></typeparam>
            <param name="numericID"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Model.GetByDescription(System.Type,System.String)">
            <summary>
            Find and return an object in this model of the specified type with a
            compatible description.  Descriptions may be the object name, a string
            containing the numeric ID or just the numeric ID itself.
            </summary>
            <param name="type"></param>
            <param name="description"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Model.GenerateNodes(Nucleus.Model.NodeGenerationParameters)">
            <summary>
            Generate or update nodes within this model to structurally represent
            the vertices of elements.
            </summary>
            <param name="options"></param>
        </member>
        <member name="M:Nucleus.Model.Model.GenerateLevels(System.Double,Nucleus.Model.ElementCollection,Nucleus.Actions.ExecutionInfo)">
            <summary>
            Automatically generate or update levels within this model to match the
            positions of horizontal elements
            </summary>
            <param name="minStoreyHeight">The minimum height above an existing level before a new one will be created</param>
            <param name="forElements"></param>
        </member>
        <member name="M:Nucleus.Model.Model.CalculateBoundingBox">
            <summary>
            Calculate and return the bounding box of this model.
            This is called automatically and the result cached by the
            BoundingBox property - so it is usually more efficient to
            use that rather than calling this function.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.Model.OnDeserialized(System.Runtime.Serialization.StreamingContext)">
            <summary>
            Called immediately after deserialisation to re-register all objects
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:Nucleus.Model.Model.ClearCachedData">
            <summary>
            Clear any volatile cached data that should be disposed when data within this model
            is updated. 
            </summary>
        </member>
        <member name="M:Nucleus.Model.Model.CleanDeleted">
            <summary>
            Clean this model of all deleted objects.  This will result in the
            permenant removal of these objects from the model database and it will
            no longer be possible to successfully undelete them.
            </summary>
        </member>
        <member name="T:Nucleus.Model.FamilyCollection">
            <summary>
            A collection of VolumetricProperty objects
            </summary>
        </member>
        <member name="M:Nucleus.Model.FamilyCollection.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Model.FamilyCollection.#ctor(Nucleus.Model.Model)">
            <summary>
            Owner constructor
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Nucleus.Model.FamilyCollection.GetSections">
            <summary>
            Extract all Section Families from this collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.FamilyCollection.GetPanelFamilies">
            <summary>
            Extract all Panel Families from this collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Model.FamilyCollection.Modified(System.DateTime)">
            <summary>
            Get the subset of items in this collection which has a recorded modification 
            after the specified date and time
            </summary>
            <param name="since">The date/time to filter by</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.FamilyTable">
            <summary>
            An extended FamilyCollection that also contains additional
            temporary data structures for fast lookup operations.
            </summary>
        </member>
        <member name="F:Nucleus.Model.FamilyTable._NextNumericID">
            <summary>
            Private backing field for NextNumericID property
            </summary>
        </member>
        <member name="P:Nucleus.Model.FamilyTable.NextNumericID">
            <summary>
            The numeric ID that will be assigned to the next element to be added to this table
            </summary>
        </member>
        <member name="F:Nucleus.Model.FamilyTable._Sections">
            <summary>
            Private backing field for Sections property
            </summary>
        </member>
        <member name="P:Nucleus.Model.FamilyTable.Sections">
            <summary>
            The subset of section properties in this table.
            Generated when necessary and cached.  Do not modify - modifications to this
            collection will have no effect on the source table.
            </summary>
        </member>
        <member name="F:Nucleus.Model.FamilyTable._PanelFamilies">
            <summary>
            Private backing field for FaceFamilies property
            </summary>
        </member>
        <member name="P:Nucleus.Model.FamilyTable.PanelFamilies">
            <summary>
            The subset of panel properties in this table.
            Generated when necessary and cached.  Do not modify - modifications to this
            collection will have no effect on the source table.
            </summary>
        </member>
        <member name="M:Nucleus.Model.FamilyTable.#ctor(Nucleus.Model.Model)">
            <summary>
            Initialises a new VolumetricPropertyTable belonging to the specified model
            </summary>
            <param name="model"></param>
        </member>
        <member name="T:Nucleus.Model.UserCoordinateSystemReferenceCollection">
            <summary>
            A collection of user coordinate systems
            </summary>
        </member>
        <member name="M:Nucleus.Model.UserCoordinateSystemReferenceCollection.#ctor">
            <summary>
            Default constructor.  Initialises a new model object collection
            </summary>
        </member>
        <member name="M:Nucleus.Model.UserCoordinateSystemReferenceCollection.#ctor(Nucleus.Model.Model)">
            <summary>
            Owner constructor.  Initialises a model object collection with an owning model.
            </summary>
            <param name="model"></param>
        </member>
        <member name="T:Nucleus.Model.UserCoordinateSystemReferenceTable">
            <summary>
            A collection of user coordinate systems
            </summary>
        </member>
        <member name="M:Nucleus.Model.UserCoordinateSystemReferenceTable.#ctor(Nucleus.Model.Model)">
            <summary>
            Owner constructor.  Initialises a model object collection with an owning model.
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Nucleus.Model.UserCoordinateSystemReferenceTable.GetByKeyword(System.String)">
            <summary>
            Get a coordinate system reference by its name.  This performs the same function as
            FindByName but with the addition that the keywords 'Global' and 'Local' can be used
            to specify the Global and Local axes respectively.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Model.VertexDataStore">
            <summary>
            A data component store belonging to a Vertex - can be used to attach
            data components to said vertex.
            </summary>
        </member>
        <member name="T:Nucleus.Model.VertexReleases">
            <summary>
            Data component which stores the translational and rotational
            releases of a vertex which forms part of an element definition,
            for use during structural analysis, physics simulation etc.
            If 
            </summary>
        </member>
        <member name="P:Nucleus.Model.VertexReleases.Fixed">
            <summary>
            Get a new VertexReleases component set up to represent full fixity in all directions.
            This is the default condition which will be assumed if no VertexReleases component is
            attached to the vertex, so you can simply remove any previous releases component from
            the vertex rather than use this value.
            </summary>
        </member>
        <member name="P:Nucleus.Model.VertexReleases.Pinned">
            <summary>
            Get a new VertexReleases component set up to represent full moment release of the vertex.
            </summary>
        </member>
        <member name="P:Nucleus.Model.VertexReleases.MomentsReleased">
            <summary>
            Get a new VertexReleases component set up to represent release in the XX and YY axes only.
            </summary>
        </member>
        <member name="P:Nucleus.Model.VertexReleases.Free">
            <summary>
            Get a new VertexReleases component set up to represent full rotational and translational release.
            </summary>
        </member>
        <member name="F:Nucleus.Model.VertexReleases._Releases">
            <summary>
            Private backing field for Releases property
            </summary>
        </member>
        <member name="P:Nucleus.Model.VertexReleases.Releases">
            <summary>
            The released directions.  These are stored relative
            to the local coordinate system of the owning element.
            </summary>
        </member>
        <member name="F:Nucleus.Model.VertexReleases._Stiffness">
            <summary>
            Private backing field for Stiffness property
            </summary>
        </member>
        <member name="P:Nucleus.Model.VertexReleases.Stiffness">
            <summary>
            The stiffnesses in the translational and rotational degrees of freedom
            of this release.  By default this stiffness is 0 in all directions.
            This property is only considered when the release in the relevent direction
            is set to true - otherwise the element is taken to be fully restrained in that
            axis and the stiffness is effectively infinite.
            Expressed in N/m.
            </summary>
        </member>
        <member name="M:Nucleus.Model.VertexReleases.#ctor">
            <summary>
            Initialise a new Vertex releases component with default values.
            </summary>
        </member>
        <member name="M:Nucleus.Model.VertexReleases.#ctor(Nucleus.Base.Bool6D)">
            <summary>
            Initialise a new vertex releases component with the specified 
            translational and rotational releases
            </summary>
            <param name="releases"></param>
        </member>
        <member name="M:Nucleus.Model.VertexReleases.#ctor(Nucleus.Base.Bool6D,Nucleus.Geometry.SixVector)">
            <summary>
            Initialise a new vertex releases component with the specified
            releases and stiffnesses.  Note that the stiffness values will
            typically be ignored in directions which are not also released.
            </summary>
            <param name="releases"></param>
            <param name="stiffness"></param>
        </member>
        <member name="T:Nucleus.Events.MessageRaisedEventArgs">
            <summary>
            Event args for a MessageRaised event
            </summary>
        </member>
        <member name="P:Nucleus.Events.MessageRaisedEventArgs.Message">
            <summary>
            The message string
            </summary>
        </member>
        <member name="M:Nucleus.Events.MessageRaisedEventArgs.#ctor(System.String)">
            <summary>
            Initialise a new MessageRaisedEventArgs object with the specified parameters
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:Nucleus.Events.PropertyChangedEventArgsExtended">
            <summary>
            Extended version of PropertyChangedEventArgs that also includes the previous and new
            values of the property
            </summary>
        </member>
        <member name="P:Nucleus.Events.PropertyChangedEventArgsExtended.OldValue">
            <summary>
            The previous value of the property
            </summary>
        </member>
        <member name="P:Nucleus.Events.PropertyChangedEventArgsExtended.NewValue">
            <summary>
            The new value of the property
            </summary>
        </member>
        <member name="T:Nucleus.Events.ModelObjectAddedEventArgs">
            <summary>
            Event arguments used when an object has been added to the model
            </summary>
        </member>
        <member name="P:Nucleus.Events.ModelObjectAddedEventArgs.Added">
            <summary>
            The object added to the model
            </summary>
        </member>
        <member name="M:Nucleus.Events.ModelObjectAddedEventArgs.#ctor(Nucleus.Base.Unique)">
            <summary>
            Constructor
            </summary>
            <param name="added"></param>
        </member>
        <member name="T:Nucleus.Events.ElementUpdateEventArgs">
            <summary>
            A set of arguments passed on during an element update event
            </summary>
        </member>
        <member name="T:Nucleus.Exceptions.ExpressionException">
            <summary>
            Exception that occurs during expression evaluation
            </summary>
        </member>
        <member name="T:Nucleus.Exceptions.MatrixException">
            <summary>
            Represents errors that occur during matrix mathematics operations
            </summary>
        </member>
        <member name="T:Nucleus.Exceptions.MeshConstructionException">
            <summary>
            Represents errors that occur during mesh building
            </summary>
        </member>
        <member name="T:Nucleus.Exceptions.GeometryException">
            <summary>
            Represents errors that occur during geometric calculation, typically because
            the operation to be performed is not possible with the input data
            </summary>
        </member>
        <member name="T:Nucleus.Exceptions.ConversionFailedException">
            <summary>
            Represents errors that occur during automated type conversion
            </summary>
        </member>
        <member name="T:Nucleus.Exceptions.NonExclusiveGeometryException">
            <summary>
            Represents errors that occur when a single geometry object is assigned to
            more than one element as its key set-out geometry
            </summary>
        </member>
        <member name="T:Nucleus.Optimisation.GeneticAlgorithmSettings">
            <summary>
            Class to contain parameters used in the solution of genetic algorithms
            </summary>
        </member>
        <member name="T:Nucleus.Optimisation.IGene">
            <summary>
            An interface for object types which may be utilised as
            a 'gene' - a controlling generative parameter which
            drives a characteristic of an option to be considered
            within a genetic algorithm optimisation.
            </summary>
        </member>
        <member name="M:Nucleus.Optimisation.IGene.Crossover(Nucleus.Optimisation.IGene,Nucleus.Optimisation.GeneticAlgorithmSettings)">
            <summary>
            Crossover this gene with another
            </summary>
            <param name="other"></param>
            <param name="settings"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Optimisation.IGene.Mutate(Nucleus.Optimisation.GeneticAlgorithmSettings)">
            <summary>
            Mutate this gene
            </summary>
            <param name="settings"></param>
        </member>
        <member name="T:Nucleus.Optimisation.IGeneticAlgorithmOption">
            <summary>
            An interface for objects which represent an option in a genetic algorithm solution
            </summary>
        </member>
        <member name="M:Nucleus.Optimisation.IGeneticAlgorithmOption.Breed(Nucleus.Optimisation.IGeneticAlgorithmOption,Nucleus.Optimisation.GeneticAlgorithmSettings)">
            <summary>
            Create a new option by breeding this option with another
            </summary>
            <param name="with">The other parent</param>
            <param name="settings">Genetic Algorithm settings</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Optimisation.IGeneticAlgorithmOption.GetFitness(Nucleus.Optimisation.GeneticAlgorithmSettings)">
            <summary>
            Get the fitness score for this option
            </summary>
            <param name="settings"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Optimisation.IGeneticAlgorithmOptionExtensions">
            <summary>
            Extension methods for the IGeneticAlgorithmOption interface
            </summary>
        </member>
        <member name="M:Nucleus.Optimisation.IGeneticAlgorithmOptionExtensions.Breed``1(``0,``0,Nucleus.Optimisation.GeneticAlgorithmSettings)">
            <summary>
            Create a new option by breeding this option with another
            </summary>
            <typeparam name="TOption"></typeparam>
            <param name="option"></param>
            <param name="with">The other parent</param>
            <param name="settings">Genetic Algorithm settings</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Optimisation.IGeneticSolver">
            <summary>
            An interface for classes which can be used to optimise
            via a genetic algorithm
            </summary>
        </member>
        <member name="T:Nucleus.Physics.IPhysicsEngineComponent">
            <summary>
            An interface for components of a physics engine that are used to
            perform part of the process being simulated
            </summary>
        </member>
        <member name="M:Nucleus.Physics.IPhysicsEngineComponent.Start(Nucleus.Physics.PhysicsEngine)">
            <summary>
            Perform any initialisation steps required before this component
            can be processed.
            </summary>
            <param name="engine"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Physics.IPhysicsEngineComponent.Cycle(System.Double,Nucleus.Physics.PhysicsEngine)">
            <summary>
            Perform the simulation steps governed by this component
            </summary>
            <param name="dt">The time-step</param>
            <param name="engine">The owning physics engine</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Physics.Particle">
            <summary>
            A data component that stores information necessary to simulate a particle subject to physical
            conditions.  May be attached to a node.
            </summary>
        </member>
        <member name="P:Nucleus.Physics.Particle.Node">
            <summary>
            The node to which this particle is attached
            </summary>
        </member>
        <member name="P:Nucleus.Physics.Particle.Position">
            <summary>
            The current, displaced, position of the node
            </summary>
        </member>
        <member name="P:Nucleus.Physics.Particle.Velocity">
            <summary>
            The current velocity of the particle
            </summary>
        </member>
        <member name="P:Nucleus.Physics.Particle.PastVelocity">
            <summary>
            The velocity of the particle during the previous cycle
            </summary>
        </member>
        <member name="P:Nucleus.Physics.Particle.Residual">
            <summary>
            The residual force in the particle
            </summary>
        </member>
        <member name="P:Nucleus.Physics.Particle.LumpedK">
            <summary>
            The stiffness 'lumped' at this node
            </summary>
        </member>
        <member name="P:Nucleus.Physics.Particle.Mass">
            <summary>
            The mass of the node
            </summary>
        </member>
        <member name="P:Nucleus.Physics.Particle.Fixity">
            <summary>
            The fixity of the node
            </summary>
        </member>
        <member name="M:Nucleus.Physics.Particle.#ctor(Nucleus.Model.Node)">
            <summary>
            Initialise a new ParticleComponent at the position of
            the specified node
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:Nucleus.Physics.Particle.Reset">
            <summary>
            Reset this particle to its initial position
            </summary>
        </member>
        <member name="M:Nucleus.Physics.Particle.Move(System.Double)">
            <summary>
            Move this particle according to its current velocity for the
            specified time-step
            </summary>
            <param name="dt"></param>
        </member>
        <member name="M:Nucleus.Physics.Particle.Damp(System.Double)">
            <summary>
            Reduce the velocity of this particle
            </summary>
            <param name="vFactor">The proportional velocity factor.
            Between 0-1.  The current velocity will be multiplied by
            this factor.</param>
        </member>
        <member name="M:Nucleus.Physics.Particle.ApplyForce(Nucleus.Geometry.Vector)">
            <summary>
            Apply a force to this particle.
            </summary>
            <param name="force"></param>
        </member>
        <member name="M:Nucleus.Physics.Particle.EndCycle">
            <summary>
            Reset transitory variables before the next cycle
            </summary>
        </member>
        <member name="M:Nucleus.Physics.Particle.KineticEnergy">
            <summary>
            Calculate the kinetic energy of the particle, 
            in Joules
            </summary>
            <returns></returns>
        </member>
        <member name="F:Nucleus.Physics.ParticleBaseComponent._Particles">
            <summary>
            Private backing field for Particles property
            </summary>
        </member>
        <member name="P:Nucleus.Physics.ParticleBaseComponent.Particles">
            <summary>
            The set of particles 
            </summary>
        </member>
        <member name="F:Nucleus.Physics.ParticleGravityComponent._Particles">
            <summary>
            Private backing field for Particles property
            </summary>
        </member>
        <member name="P:Nucleus.Physics.ParticleGravityComponent.Particles">
            <summary>
            The set of particles 
            </summary>
        </member>
        <member name="F:Nucleus.Physics.ParticleGravityComponent._Gravity">
            <summary>
            Private backing field for Gravity property
            </summary>
        </member>
        <member name="P:Nucleus.Physics.ParticleGravityComponent.Gravity">
            <summary>
            The direction and magnitude of the gravity acceleration, in m/s/s
            </summary>
        </member>
        <member name="M:Nucleus.Physics.ParticleGravityComponent.#ctor(Nucleus.Model.NodeCollection)">
            <summary>
            Initialise a ParticleMotionComponent, generating particles from the
            specified nodes.
            </summary>
            <param name="nodes"></param>
        </member>
        <member name="T:Nucleus.Physics.ParticleMotionComponent">
            <summary>
            A Physics Engine component that deals with resolving the motion of particles
            </summary>
        </member>
        <member name="F:Nucleus.Physics.ParticleMotionComponent._Damping">
            <summary>
            Private backing field for Damping property
            </summary>
        </member>
        <member name="P:Nucleus.Physics.ParticleMotionComponent.Damping">
            <summary>
            The damping factor to be applied to particle
            motion.  This is the proportional reduction
            in velocity of each particle each cycle.
            </summary>
        </member>
        <member name="P:Nucleus.Physics.ParticleMotionComponent.SpeedLimit">
            <summary>
            The maximum velocity of a particle
            </summary>
        </member>
        <member name="M:Nucleus.Physics.ParticleMotionComponent.#ctor(Nucleus.Model.NodeCollection)">
            <summary>
            Initialise a ParticleMotionComponent, generating particles from the
            specified nodes.
            </summary>
            <param name="nodes"></param>
        </member>
        <member name="T:Nucleus.Physics.PhysicsEngine">
            <summary>
            A customisable physics engine that can be used to manage
            iterative simulations of physical and pseudo-physical forces
            </summary>
        </member>
        <member name="F:Nucleus.Physics.PhysicsEngine._Components">
            <summary>
            Private backing field for Components property
            </summary>
        </member>
        <member name="P:Nucleus.Physics.PhysicsEngine.Components">
            <summary>
            The components that model the physical processes to be simulated by this
            engine.  These will be processed in order each cycle.
            </summary>
        </member>
        <member name="F:Nucleus.Physics.PhysicsEngine._MaximumTimeStep">
            <summary>
            Private backing field for MaximumTimeStep property
            </summary>
        </member>
        <member name="P:Nucleus.Physics.PhysicsEngine.MaximumTimeStep">
            <summary>
            The maximum allowable time-step per cycle.  If the time step entered in a cycle is
            greater than this then it will be split into several sub-cycles of no more than this
            limit.  If set to 0 no limit will be applied.
            </summary>
        </member>
        <member name="M:Nucleus.Physics.PhysicsEngine.#ctor">
            <summary>
            Initialise a new blank physics engine
            </summary>
        </member>
        <member name="M:Nucleus.Physics.PhysicsEngine.#ctor(Nucleus.Physics.PhysicsEngineComponentCollection)">
            <summary>
            Initialise a new physics engine to run the specified simulation components
            </summary>
            <param name="components"></param>
        </member>
        <member name="M:Nucleus.Physics.PhysicsEngine.Start">
            <summary>
            Start the simulation running
            </summary>
        </member>
        <member name="M:Nucleus.Physics.PhysicsEngine.Cycle(System.Double)">
            <summary>
            Advance the simulation by a certain timestep
            </summary>
            <param name="dt"></param>
        </member>
        <member name="T:Nucleus.Physics.PhysicsEngineComponentCollection">
            <summary>
            A collection of physics engine components
            </summary>
        </member>
        <member name="T:Nucleus.Physics.Spring">
            <summary>
            A data component used during physical simulations to model
            linear elements as strings
            </summary>
        </member>
        <member name="P:Nucleus.Physics.Spring.Element">
            <summary>
            The element this spring represents and is attached to
            </summary>
        </member>
        <member name="P:Nucleus.Physics.Spring.RestLength">
            <summary>
            The length of the spring at which it is at rest and
            is exerting no force, in m
            </summary>
        </member>
        <member name="P:Nucleus.Physics.Spring.Stiffness">
            <summary>
            The stiffness of the spring in N/m
            </summary>
        </member>
        <member name="P:Nucleus.Physics.Spring.Compression">
            <summary>
            Does this spring resist compression?
            </summary>
        </member>
        <member name="P:Nucleus.Physics.Spring.Tension">
            <summary>
            Does this spring resist tension?
            </summary>
        </member>
        <member name="P:Nucleus.Physics.Spring.StartParticle">
            <summary>
            The particle at the start of the spring
            </summary>
        </member>
        <member name="P:Nucleus.Physics.Spring.EndParticle">
            <summary>
            The particle at the end of the spring
            </summary>
        </member>
        <member name="M:Nucleus.Physics.Spring.ApplyForces">
            <summary>
            Calculate and apply any internal forces due to deformation
            to the particles connected to this spring
            </summary>
        </member>
        <member name="M:Nucleus.Physics.Spring.AxialForce">
            <summary>
            Calculate and return the axial force due to compression/tension in this spring
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Physics.SpringForceComponent">
            <summary>
            A physics engine component that applies Hooke's law to determine forces
            acting on the ends of a set of springs according to the current deformation
            </summary>
        </member>
        <member name="F:Nucleus.Physics.SpringForceComponent._Springs">
            <summary>
            Private backing field for Springs property
            </summary>
        </member>
        <member name="P:Nucleus.Physics.SpringForceComponent.Springs">
            <summary>
            The collection of springs to be processed
            </summary>
        </member>
        <member name="M:Nucleus.Physics.SpringForceComponent.#ctor(Nucleus.Model.LinearElementCollection)">
            <summary>
            Initialise a new spring force physics component including
            springs based on the specified set of linear elements
            </summary>
            <param name="elements"></param>
        </member>
        <member name="T:Nucleus.Rendering.Animation">
            <summary>
            Base class for Animations - tweened transitions between multiple
            states that happen over time.
            </summary>
        </member>
        <member name="F:Nucleus.Rendering.Animation._Time">
            <summary>
            Private backing field for Time property
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.Animation.Time">
            <summary>
            The current time of the animation
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.Animation.Finished">
            <summary>
            Has this animation finished playing?
            </summary>
        </member>
        <member name="F:Nucleus.Rendering.Animation._Looping">
            <summary>
            Private backing field for Looping property
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.Animation.Looping">
            <summary>
            Get or set whether this animation will loop
            </summary>
        </member>
        <member name="F:Nucleus.Rendering.Animation._Tweening">
            <summary>
            Private backing field for Tweening property
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.Animation.Tweening">
            <summary>
            The tweening algorithm to be used by this animation
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.Animation.Duration">
            <summary>
            The duration of this animation
            </summary>
        </member>
        <member name="M:Nucleus.Rendering.Animation.Advance(System.Double)">
            <summary>
            Progress the animation by the specified timestep
            </summary>
            <param name="dT">The timestep</param>
        </member>
        <member name="M:Nucleus.Rendering.Animation.Finish">
            <summary>
            End the animation.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Rendering.Animation.Reset">
            <summary>
            Restart the animation
            </summary>
        </member>
        <member name="M:Nucleus.Rendering.Animation.Apply">
            <summary>
            Apply this animation to the target object
            </summary>
        </member>
        <member name="T:Nucleus.Rendering.Animation`2">
            <summary>
            Generic base class for Animations - tweened transitions between multiple
            states that happen over time.
            </summary>
            <typeparam name="TTarget">The type of the target to which the animation is applied</typeparam>
            <typeparam name="TState">The type of the state value which will be modified throughout this animation</typeparam>
        </member>
        <member name="F:Nucleus.Rendering.Animation`2._Target">
            <summary>
            Private backing field for Target property
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.Animation`2.Target">
            <summary>
            The object being animated
            </summary>
        </member>
        <member name="F:Nucleus.Rendering.Animation`2._States">
            <summary>
            Private backing field for States property
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.Animation`2.States">
            <summary>
            Get the states of this animation, keyed by the time at which they occur
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.Animation`2.CustomInterpolationFunction">
            <summary>
            A custom interpolation delegate function to be used when determining between-state values.
            The function must take in a start state, end state, parameter from 0-1 between them, the
            interpolation type and return the intermediate state.
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.Animation`2.InitialState">
            <summary>
            The state value at the start of this animation
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.Animation`2.CurrentState">
            <summary>
            The (possibly interpolated) state at the current Time
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.Animation`2.Duration">
            <summary>
            The duration of this animation
            </summary>
        </member>
        <member name="M:Nucleus.Rendering.Animation`2.#ctor(`0,`1,`1,System.Double,System.Boolean)">
            <summary>
            
            </summary>
            <param name="target"></param>
            <param name="startState"></param>
            <param name="endState"></param>
            <param name="duration"></param>
            <param name="looping"></param>
        </member>
        <member name="M:Nucleus.Rendering.Animation`2.Initialise(`1,`1,System.Double)">
            <summary>
            Initialise the stored start and end states of this animation
            </summary>
            <param name="startState"></param>
            <param name="endState"></param>
            <param name="duration"></param>
        </member>
        <member name="F:Nucleus.Rendering.AnimationBinding._PropertyName">
            <summary>
            Private backing member variable for the PropertyName property
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.AnimationBinding.PropertyName">
            <summary>
            The name of the property to be watched for changes
            </summary>
        </member>
        <member name="F:Nucleus.Rendering.AnimationBinding._Animation">
            <summary>
            Private backing member variable for the Animation property
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.AnimationBinding.Animation">
            <summary>
            The animation to be played to transition changes in the property value
            </summary>
        </member>
        <member name="T:Nucleus.Rendering.Animator">
            <summary>
            Manager class which applies animations to objects
            </summary>
        </member>
        <member name="F:Nucleus.Rendering.Animator._Animations">
            <summary>
            Private backing field for Animations property
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.Animator.Animations">
            <summary>
            The current set of active animations
            </summary>
        </member>
        <member name="M:Nucleus.Rendering.Animator.AddAnimation(Nucleus.Rendering.Animation)">
            <summary>
            Add an animation to the purview of this animator
            </summary>
            <param name="animation"></param>
        </member>
        <member name="M:Nucleus.Rendering.Animator.Animate(System.Double)">
            <summary>
            Advance and apply all animations
            </summary>
            <param name="dt"></param>
        </member>
        <member name="M:Nucleus.Rendering.Animator.FinishAll">
            <summary>
            Finish all animations by advancing them to their end state
            </summary>
        </member>
        <member name="T:Nucleus.Rendering.ASCIIStyle">
            <summary>
            A data component that represents they styling of an
            ASCII visual representation
            </summary>
        </member>
        <member name="F:Nucleus.Rendering.ASCIIStyle._Symbol">
            <summary>
            Private backing member variable for the Symbol property
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.ASCIIStyle.Symbol">
            <summary>
            The ASCII symbol used to represent the element
            </summary>
        </member>
        <member name="T:Nucleus.Rendering.AvatarStyle">
            <summary>
            Abstract base class of styles which determine how a 
            particular object is to be represented graphically.
            </summary>
        </member>
        <member name="T:Nucleus.Rendering.Colour">
            <summary>
            An ARGB colour structure.
            Functionaly equivalent to the System.Media.Color structure,
            but implemented here to allow for future compatibility with
            Mono.
            </summary>
        </member>
        <member name="F:Nucleus.Rendering.Colour.Black">
            <summary> An opaque solid black colour </summary>
        </member>
        <member name="F:Nucleus.Rendering.Colour.White">
            <summary> An opaque solid white colour </summary>
        </member>
        <member name="F:Nucleus.Rendering.Colour.Red">
            <summary> An opaque solid red colour </summary>
        </member>
        <member name="F:Nucleus.Rendering.Colour.Green">
            <summary> An opaque solid green colour </summary>
        </member>
        <member name="F:Nucleus.Rendering.Colour.Blue">
            <summary> An opaque solid blue colour </summary>
        </member>
        <member name="F:Nucleus.Rendering.Colour.Yellow">
            <summary> An opaque solid yellow colour </summary>
        </member>
        <member name="F:Nucleus.Rendering.Colour.Transparent">
            <summary> A transparent colour </summary>
        </member>
        <member name="F:Nucleus.Rendering.Colour.RambollCyan">
            <summary> The shade of blue used in the Ramboll logo </summary>
        </member>
        <member name="F:Nucleus.Rendering.Colour.RambollDarkGrey">
            <summary> The shade of dark grey used in the Ramboll standard palette </summary>
        </member>
        <member name="F:Nucleus.Rendering.Colour.RambollLightBlue">
            <summary> The shade of light blue used in the Ramboll standard palette </summary>
        </member>
        <member name="F:Nucleus.Rendering.Colour.RambollLightGrey">
            <summary> The shade of light grey used in the Ramboll standard palette </summary>
        </member>
        <member name="F:Nucleus.Rendering.Colour.RambollLimeGreen">
            <summary> The shade of lime green used in the Ramboll standard palette </summary>
        </member>
        <member name="F:Nucleus.Rendering.Colour.RambollGreen">
            <summary> The shade of green used in the Ramboll standard palette </summary>
        </member>
        <member name="F:Nucleus.Rendering.Colour.RambollMagenta">
            <summary> The shade of magenta used in the Ramboll standard palette </summary>
        </member>
        <member name="F:Nucleus.Rendering.Colour.RambollWarmRed">
            <summary> The shade of magenta used in the Ramboll standard palette </summary>
        </member>
        <member name="F:Nucleus.Rendering.Colour.RambollBrown">
            <summary> The shade of brown used as an addition to the Ramboll standard palette </summary>
        </member>
        <member name="F:Nucleus.Rendering.Colour.RambollYellow">
            <summary> The shade of yellow used as an addition to the Ramboll standard palette </summary>
        </member>
        <member name="F:Nucleus.Rendering.Colour.SalamanderOrange">
            <summary> The shade of orange used in the Salamander logo </summary>
        </member>
        <member name="F:Nucleus.Rendering.Colour.RambollPalette">
            <summary>
            The standard Ramboll colour palette
            </summary>
        </member>
        <member name="F:Nucleus.Rendering.Colour.RambollPalette2">
            <summary>
            The standard Ramboll colour palette (re-ordered)
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.Colour.A">
            <summary>
            The alpha channel of the colour.
            Range from 0-255.
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.Colour.R">
            <summary>
            The red channel of the colour.
            Range from 0-255.
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.Colour.G">
            <summary>
            The green channel of the colour.
            Range from 0-255.
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.Colour.B">
            <summary>
            The blue channel of the colour.
            Range from 0-255.
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.Colour.Brightness">
            <summary>
            Obtain a measure of the apparent brightness of the colour,
            ranging between 0-1.
            The colour components are weighted differently when calculating
            'brightness' in this way; Red is weighted by 0.3, green by 0.59 
            and blue by 0.11 - the brightness is the unitized combination of
            all three values.
            </summary>
        </member>
        <member name="M:Nucleus.Rendering.Colour.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            A,R,G,B byte constructor
            </summary>
            <param name="a">The alpha channel.  0-255.</param>
            <param name="r">The red channel.  0-255.</param>
            <param name="g">The green channel.  0-255.</param>
            <param name="b">The blue channel.  0-255.</param>
        </member>
        <member name="M:Nucleus.Rendering.Colour.#ctor(System.Byte,System.Byte,System.Byte)">
            <summary>
            R,G,B byte constructor
            </summary>
            <param name="r">The red channel.  0-255.</param>
            <param name="g">The green channel.  0-255.</param>
            <param name="b">The blue channel.  0-255.</param>
        </member>
        <member name="M:Nucleus.Rendering.Colour.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            A, R, G, B integer constructor.
            Will automatically cap values that exceed 255.
            </summary>
            <param name="a">The alpha channel.  0-255.</param>
            <param name="r">The red channel.  0-255.</param>
            <param name="g">The green channel.  0-255.</param>
            <param name="b">The blue channel.  0-255.</param>
        </member>
        <member name="M:Nucleus.Rendering.Colour.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            R, G, B integer constructor.
            Will automatically cap values that exceed 255.
            </summary>
            <param name="r">The red channel.  0-255.</param>
            <param name="g">The green channel.  0-255.</param>
            <param name="b">The blue channel.  0-255.</param>
        </member>
        <member name="M:Nucleus.Rendering.Colour.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            A,R,G,B float constructor
            </summary>
            <param name="a">The alpha channel.  0-1.</param>
            <param name="r">The red channel.  0-1.</param>
            <param name="g">The green channel.  0-1.</param>
            <param name="b">The blue channel.  0-1.</param>
        </member>
        <member name="M:Nucleus.Rendering.Colour.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            A,R,G,B float constructor
            </summary>
            <param name="r">The red channel.  0-1.</param>
            <param name="g">The green channel.  0-1.</param>
            <param name="b">The blue channel.  0-1.</param>
        </member>
        <member name="M:Nucleus.Rendering.Colour.CapBrightness(System.Double)">
            <summary>
            If the brightness of the colour currently exceeds the specified
            value, reduce it to that value.
            </summary>
            <param name="brightness">The maximum brightness value,
            expressed as a value between 0-1.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Rendering.Colour.SetBrightness(System.Double)">
            <summary>
            Adjust the components of this colour to the specified brightness
            </summary>
            <param name="brightness"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Rendering.Colour.GetHashCode">
            <summary>
            Get the hash code for this colour
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Rendering.Colour.Equals(System.Object)">
            <summary>
            Is this colour equal to another object
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Rendering.Colour.Equals(Nucleus.Rendering.Colour)">
            <summary>
            Is this colour equal to another?
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Rendering.Colour.Add(Nucleus.Rendering.Colour)">
            <summary>
            Add another colour to this one and return the result
            </summary>
            <param name="other">The colour to add to this one</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Rendering.Colour.Subtract(Nucleus.Rendering.Colour)">
            <summary>
            Subtract another colour from this one and return the result
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Rendering.Colour.Invert(Nucleus.Rendering.Colour)">
            <summary>
            Invert this colour, subtracting its RGB values from white
            but keeping the same alpha value.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Rendering.Colour.ToByteArray">
            <summary>
            Convert this colour to an array of bytes
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Rendering.Colour.ToString">
            <summary>
            Convert this colour to a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Rendering.Colour.Scale(System.Double)">
            <summary>
            Multiply all components of this colour by a scalar factor.
            Components will be clamped to 0-255 to prevent overflow.
            </summary>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Rendering.Colour.Interpolate(Nucleus.Rendering.Colour,System.Double)">
            <summary>
            Interpolate between this colour and another
            </summary>
            <param name="towards">The colour to interpolate towards</param>
            <param name="factor">The interpolation factor.  0 = this colour, 1 = the 'towards' colour</param>
            <returns>An interpolated colour</returns>
        </member>
        <member name="M:Nucleus.Rendering.Colour.FromHSV(System.Double,System.Double,System.Double,System.Byte)">
            <summary>
            Create a colour from hue, saturation and value
            </summary>
            <param name="h">Hue, range 0-360</param>
            <param name="s">Saturation, range 0-255</param>
            <param name="v">Value, range 0-255</param>
            <param name="a">Alpha value, range 0-255</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Rendering.ColourBrush">
            <summary>
            A brush that uses a single solid colour
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.ColourBrush.Black">
            <summary>
            Get a default black colour brush
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.ColourBrush.White">
            <summary>
            Get a default white colour brush
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.ColourBrush.Red">
            <summary>
            Get a default red colour brush
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.ColourBrush.Green">
            <summary>
            Get a default green colour brush
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.ColourBrush.Blue">
            <summary>
            Get a default blue colour brush
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.ColourBrush.Transparent">
            <summary>
            Get a default transparent colour brush
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.ColourBrush.RambollBlue">
            <summary>
            Get a single-colour brush in Ramboll blue
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.ColourBrush.SalamanderOrange">
            <summary>
            Get a single-colour brush in Salamander orange
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.ColourBrush.Colour">
            <summary>
            The colour of the brush
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.ColourBrush.BaseColour">
            <summary>
            Get the base colour for this display brush - a single
            colour that can be used to represent this brush in cases where
            more complex shading is not available.
            For ColourBrushes this will return the Colour property.
            </summary>
        </member>
        <member name="M:Nucleus.Rendering.ColourBrush.#ctor(Nucleus.Rendering.Colour)">
            <summary>
            Colour constructor
            </summary>
            <param name="colour"></param>
        </member>
        <member name="T:Nucleus.Rendering.ColourCollection">
            <summary>
            A collection of colours
            </summary>
        </member>
        <member name="T:Nucleus.Rendering.ColourDictionary">
            <summary>
            A dictionary to store colours keyed by a string
            </summary>
        </member>
        <member name="T:Nucleus.Rendering.DisplayAttributes">
            <summary>
            A set of attributes which determine how an object should be rendered
            </summary>
        </member>
        <member name="F:Nucleus.Rendering.DisplayAttributes._Brush">
            <summary>
            Private backing field for the Brush property
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.DisplayAttributes.Brush">
            <summary>
            The brush which determines how this geometry should be drawn.
            </summary>
        </member>
        <member name="F:Nucleus.Rendering.DisplayAttributes._Weight">
            <summary>
            Private backing field for the Thickness property
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.DisplayAttributes.Weight">
            <summary>
            The scaling factor applied to the thickness of curves and the
            size of points when drawn.
            </summary>
        </member>
        <member name="T:Nucleus.Rendering.DisplayBrush">
            <summary>
            Abstract base class for objects which describe how an object should be drawn.
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.DisplayBrush.BaseColour">
            <summary>
            Get the base colour for this display brush - a single
            colour that can be used to represent this brush in cases where
            more complex shading is not available.
            </summary>
        </member>
        <member name="F:Nucleus.Rendering.DisplayBrush._CachedData">
            <summary>
            Private backing member variable for the CachedData property
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.DisplayBrush.CachedData">
            <summary>
            A store for cached data and resources used by this brush.  
            Usage will depend on context.
            </summary>
        </member>
        <member name="T:Nucleus.Rendering.ITextureLoader">
            <summary>
            Interface for classes which can be used to load textures
            </summary>
        </member>
        <member name="M:Nucleus.Rendering.ITextureLoader.GetTexture(System.String)">
            <summary>
            Get the texture indicated by the specified reference string
            </summary>
            <param name="textureReference"></param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Rendering.TextureLoader.Current">
            <summary>
            Get or set the current texture loader.
            </summary>
        </member>
        <member name="T:Nucleus.Rendering.ColourGradient">
            <summary>
            A colour gradient that smoothly varies between colours keyed
            at different double parameters
            </summary>
        </member>
        <member name="F:Nucleus.Rendering.ColourGradient.RedToGreen">
            <summary>
            A linear gradient from red to green
            </summary>
        </member>
        <member name="M:Nucleus.Rendering.ColourGradient.#ctor">
            <summary>
            Initialise a new blank ColourGradient
            </summary>
        </member>
        <member name="M:Nucleus.Rendering.ColourGradient.#ctor(System.Collections.Generic.IList{Nucleus.Rendering.Colour})">
            <summary>
            Initialise a new data set containing the specified values.
            Each value will be plotted against it's index in the list
            </summary>
            <param name="values"></param>
        </member>
        <member name="M:Nucleus.Rendering.ColourGradient.#ctor(Nucleus.Rendering.Colour[])">
            <summary>
            Initialise a new data set containing the specified values.
            Each value will be plotted against it's index in the list
            </summary>
            <param name="values"></param>
        </member>
        <member name="M:Nucleus.Rendering.ColourGradient.#ctor(System.Double,Nucleus.Rendering.Colour)">
            <summary>
            Initialise a new data set containing the specified initial pairing
            of values
            </summary>
            <param name="firstKey"></param>
            <param name="firstValue"></param>
        </member>
        <member name="M:Nucleus.Rendering.ColourGradient.#ctor(Nucleus.Rendering.Colour)">
            <summary>
            Initialise a new data set containing the specified constant value between
            0 and 1.0.
            </summary>
            <param name="constantValue"></param>
        </member>
        <member name="M:Nucleus.Rendering.ColourGradient.#ctor(System.Double,Nucleus.Rendering.Colour,System.Double,Nucleus.Rendering.Colour)">
            <summary>
            Initialise a new data set containing the two specified initial pairings
            </summary>
            <param name="firstKey"></param>
            <param name="firstValue"></param>
            <param name="secondKey"></param>
            <param name="secondValue"></param>
        </member>
        <member name="M:Nucleus.Rendering.ColourGradient.#ctor(System.Double,Nucleus.Rendering.Colour,System.Double,Nucleus.Rendering.Colour,System.Double,Nucleus.Rendering.Colour)">
            <summary>
            Initialise a new data set containing the two specified initial pairings
            </summary>
            <param name="firstKey"></param>
            <param name="firstValue"></param>
            <param name="secondKey"></param>
            <param name="secondValue"></param>
        </member>
        <member name="T:Nucleus.Rendering.PrefabStyle">
            <summary>
            A data component that represents the visual styling of an element
            by reference to a predefined visual model identified by a string key.
            </summary>
        </member>
        <member name="F:Nucleus.Rendering.PrefabStyle._PrefabKey">
            <summary>
            Private backing member variable for the PrefabKey property
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.PrefabStyle.PrefabKey">
            <summary>
            The key by which the pre-defined visual style is referenced.  Typically its name.
            </summary>
        </member>
        <member name="M:Nucleus.Rendering.PrefabStyle.#ctor">
            <summary>
            Creates an uninitialised Prefab style
            </summary>
        </member>
        <member name="M:Nucleus.Rendering.PrefabStyle.#ctor(System.String)">
            <summary>
            Creates a prefab style referencing the specified prefab
            </summary>
            <param name="prefabKey"></param>
        </member>
        <member name="T:Nucleus.Rendering.SFXSupervisor">
            <summary>
            Supervisor class responsible for cacheing special effects triggers
            </summary>
        </member>
        <member name="F:Nucleus.Rendering.SFXSupervisor._Triggers">
            <summary>
            Private backing member variable for the Triggers property
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.SFXSupervisor.Triggers">
            <summary>
            The 'to do' list for SFX triggers
            </summary>
        </member>
        <member name="M:Nucleus.Rendering.SFXSupervisor.Clear">
            <summary>
            Clear the list of SFX Triggers
            </summary>
        </member>
        <member name="M:Nucleus.Rendering.SFXSupervisor.Trigger(System.String)">
            <summary>
            Trigger a special effect
            </summary>
            <param name="keyword">The keyword denoting the effect to trigger</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Rendering.SFXSupervisor.Trigger(System.String,Nucleus.Geometry.Vector)">
            <summary>
            Trigger a special effect
            </summary>
            <param name="keyword">The keyword denoting the effect to trigger</param>
            <param name="position">The (starting) position of the effect</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Rendering.SFXSupervisor.Trigger(System.String,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Trigger a special effect
            </summary>
            <param name="keyword">The keyword denoting the effect to trigger</param>
            <param name="position">The (starting) position of the effect</param>
            <param name="direction">The direction or path of the effect</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Rendering.SFXTrigger">
            <summary>
            A class that is used to trigger a special effect
            </summary>
        </member>
        <member name="F:Nucleus.Rendering.SFXTrigger._KeyWord">
            <summary>
            Private backing member variable for the KeyWord property
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.SFXTrigger.KeyWord">
            <summary>
            The keyword which defines the type of special effect to be created
            </summary>
        </member>
        <member name="F:Nucleus.Rendering.SFXTrigger._Position">
            <summary>
            Private backing member variable for the Position property
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.SFXTrigger.Position">
            <summary>
            The position at which the effect is to be created, if applicable.
            </summary>
        </member>
        <member name="F:Nucleus.Rendering.SFXTrigger._Direction">
            <summary>
            Private backing member variable for the Direction property
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.SFXTrigger.Direction">
            <summary>
            The direction in/path along which the effect should be orientated/moved, if applicable
            </summary>
        </member>
        <member name="M:Nucleus.Rendering.SFXTrigger.#ctor(System.String)">
            <summary>
            Creates an SFX trigger for the specified keyword
            </summary>
            <param name="keyword"></param>
        </member>
        <member name="M:Nucleus.Rendering.SFXTrigger.#ctor(System.String,Nucleus.Geometry.Vector)">
            <summary>
            Creates an SFX trigger for the specified keyword at the specified position
            </summary>
            <param name="keyword"></param>
            <param name="position"></param>
        </member>
        <member name="M:Nucleus.Rendering.SFXTrigger.#ctor(System.String,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Creates an SFX trigger for the specified keyword, position and direction
            </summary>
            <param name="keyword"></param>
            <param name="position"></param>
            <param name="direction"></param>
        </member>
        <member name="T:Nucleus.Rendering.SpriteAnimation">
            <summary>
            Datastructure to hold the information of an animation in a sprite
            </summary>
        </member>
        <member name="F:Nucleus.Rendering.SpriteAnimation._Directions">
            <summary>
            Private backing member variable for the Directions property
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.SpriteAnimation.Directions">
            <summary>
            The animation directions
            </summary>
        </member>
        <member name="M:Nucleus.Rendering.SpriteAnimation.#ctor">
            <summary>
            Create a new SpriteAnimation
            </summary>
        </member>
        <member name="M:Nucleus.Rendering.SpriteAnimation.GetDirection(Nucleus.Geometry.Angle)">
            <summary>
            Get the 
            </summary>
            <param name="angle"></param>
            <returns></returns>
        </member>
        <member name="F:Nucleus.Rendering.SpriteAnimationDirection._Frames">
            <summary>
            Private backing member variable for the Frames property
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.SpriteAnimationDirection.Frames">
            <summary>
            The frames that make up this animation direction
            </summary>
        </member>
        <member name="T:Nucleus.Rendering.SpriteData">
            <summary>
            Class to hold the definition of a sprite
            </summary>
        </member>
        <member name="F:Nucleus.Rendering.SpriteData._Animations">
            <summary>
            Private backing member variable for the Animations property
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.SpriteData.Animations">
            <summary>
            The animations of this sprite
            </summary>
        </member>
        <member name="M:Nucleus.Rendering.SpriteData.GetDefaultAnimation">
            <summary>
            Get the default animation for this sprite
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Rendering.SpriteData.GetAnimation(System.String)">
            <summary>
            Get the animation on this Sprite with the specified name, if one exists.
            Otherwise, will return the default (usually, 'Idle') animation.
            </summary>
            <param name="animationName"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Rendering.SpriteData.GetDirection(System.String,Nucleus.Geometry.Angle)">
            <summary>
            Get the closest direction of the animation with the specified name (or,
            the default animation if no animation with this name exists).
            </summary>
            <param name="animationName"></param>
            <param name="orientation"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Rendering.SpriteData.GetFrame(System.String,Nucleus.Geometry.Angle,System.Double)">
            <summary>
            Get the appropriate frame of the appropriate direction of the animation with the
            specified name (or the default animation if no animation with the given name exists)
            </summary>
            <param name="animationName"></param>
            <param name="orientation"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Rendering.SpriteData.LoadSpriteSheet(Nucleus.Base.FilePath,Nucleus.Rendering.ITextureLoader)">
            <summary>
            Load sprite data from a sprite sheet
            </summary>
            <param name="filePath"></param>
            <param name="textureLoader"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Rendering.SpriteDataCollection">
            <summary>
            A collection of SpriteData
            </summary>
        </member>
        <member name="T:Nucleus.Rendering.TextureBrush">
            <summary>
            A brush which paints an area with an image texture
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.TextureBrush.Texture">
            <summary>
            The image to be drawn by the brush
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.TextureBrush.Region">
            <summary>
            The region of the texture to be displayed.
            If null, indicates the full texture is to be used
            without cropping.
            </summary>
        </member>
        <member name="M:Nucleus.Rendering.TextureBrush.#ctor">
            <summary>
            Initialise a blank TextureBrush
            </summary>
        </member>
        <member name="M:Nucleus.Rendering.TextureBrush.#ctor(Nucleus.Rendering.ITexture)">
            <summary>
            Initialise a TextureBrush with the specified texture
            </summary>
            <param name="texture"></param>
        </member>
        <member name="M:Nucleus.Rendering.TextureBrush.#ctor(Nucleus.Rendering.ITexture,Nucleus.Rendering.Rectangle)">
            <summary>
            Initialise a TextureBrush to paint the specified region 
            of the specified texture
            </summary>
            <param name="texture"></param>
            <param name="region"></param>
        </member>
        <member name="M:Nucleus.Rendering.TextureBrush.#ctor(Nucleus.Rendering.ITexture,System.String[])">
            <summary>
            Initialise a TextureBrush to paint the specified region 
            of the specified texture
            </summary>
            <param name="texture"></param>
            <param name="region"></param>
        </member>
        <member name="T:Nucleus.Rendering.IRenderable">
            <summary>
            An interface for renderable objects
            </summary>
        </member>
        <member name="M:Nucleus.Rendering.IRenderable.Draw(Nucleus.Rendering.RenderingParameters)">
            <summary>
            Draw this renderable
            </summary>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Rendering.ITexture">
            <summary>
            Interface for objects that represent bitmap image textures
            </summary>
        </member>
        <member name="T:Nucleus.Rendering.Rectangle">
            <summary>
            A class representing a 2D axis-aligned rectangle
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.Rectangle.Left">
            <summary>
            The starting value of the rectangle in the X-direction
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.Rectangle.Right">
            <summary>
            The ending value of the rectangle in the X-direction
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.Rectangle.Top">
            <summary>
            The starting value of the rectangle in the Y-direction
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.Rectangle.Bottom">
            <summary>
            The ending value of the rectangle in the Y-direction
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.Rectangle.Width">
            <summary>
            Get the width of this rectangle
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.Rectangle.Height">
            <summary>
            Get the height of this rectangle
            </summary>
        </member>
        <member name="M:Nucleus.Rendering.Rectangle.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Create a new Rectangle with the specified positions
            </summary>
            <param name="left"></param>
            <param name="top"></param>
            <param name="right"></param>
            <param name="bottom"></param>
        </member>
        <member name="T:Nucleus.Rendering.PropertyAnimation">
            <summary>
            An animation which animates a property specified by a path string.
            Uses reflection and therefore may be less performant than other animation types.
            </summary>
        </member>
        <member name="F:Nucleus.Rendering.PropertyAnimation._TargetPath">
            <summary>
            Private backing field for TargetPath property
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.PropertyAnimation.TargetPath">
            <summary>
            The path of the property to be animated on the
            target object.
            </summary>
        </member>
        <member name="M:Nucleus.Rendering.PropertyAnimation.#ctor">
            <summary>
            Initialise a new PropertyAnimation
            </summary>
        </member>
        <member name="M:Nucleus.Rendering.PropertyAnimation.#ctor(System.Object,System.String,System.Object,System.Double,Nucleus.Maths.Interpolation,System.Func{System.Object,System.Object,System.Double,Nucleus.Maths.Interpolation,System.Object})">
            <summary>
            Initialise a new PropertyAnimation
            </summary>
            <param name="target"></param>
            <param name="targetPath"></param>
            <param name="toValue"></param>
            <param name="duration"></param>
            <param name="tweening"></param>
            <param name="customInterpolationFunction"></param>
        </member>
        <member name="M:Nucleus.Rendering.PropertyAnimation.Apply">
            <summary>
            Apply the current state of the animation to the target property
            </summary>
        </member>
        <member name="T:Nucleus.Rendering.Renderer">
            <summary>
            Abstract base class for renderers which draw objects to the screen
            </summary>
        </member>
        <member name="T:Nucleus.Rendering.RenderingParameters">
            <summary>
            A set of parameters passed in to renderable objects to allow them to be drawn.
            Actual implementation will be application-specific
            </summary>
        </member>
        <member name="F:Nucleus.Rendering.RenderingParameters._CursorPosition">
            <summary>
            Private backing field for CursorPosition property
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.RenderingParameters.CursorPosition">
            <summary>
            The current position of the 3D cursor during dynamically-drawn selection operations
            </summary>
        </member>
        <member name="T:Nucleus.Rendering.TextureLoaderBase`1">
            <summary>
            Abstract generic base class to give a headstart on implementing an ITextureLoader
            </summary>
            <typeparam name="TTexture"></typeparam>
        </member>
        <member name="F:Nucleus.Rendering.TextureLoaderBase`1._Loaded">
            <summary>
            Private backing member variable for the Loaded property
            </summary>
        </member>
        <member name="P:Nucleus.Rendering.TextureLoaderBase`1.Loaded">
            <summary>
            The cached library of loaded textures
            </summary>
        </member>
        <member name="M:Nucleus.Rendering.TextureLoaderBase`1.GetTexture(System.String)">
            <summary>
            Get the texture indicated by the specified reference string.
            This will be loaded as necessary and possible.
            </summary>
            <param name="textureReference"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Rendering.TextureLoaderBase`1.LoadTexture(System.String)">
            <summary>
            Load a texture from a resource.
            </summary>
            <param name="resourceRef"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Results.Deprecated.CaseResults">
            <summary>
            A table of results for objects under a particular analysis case.
            Keyed by object GUID.
            </summary>
        </member>
        <member name="P:Nucleus.Results.Deprecated.CaseResults.Item(Nucleus.Model.ModelObject)">
            <summary>
            Get or set the results for the specified object
            </summary>
            <param name="mObject"></param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Results.Deprecated.CaseResults.Item(Nucleus.Model.Node)">
            <summary>
            Get or set the results table for the specified node
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Results.Deprecated.CaseResults.Item(Nucleus.Model.Node,Nucleus.Results.NodeResultTypes)">
            <summary>
            Get the maximum and minimum stored results of the specified type for the specified node
            </summary>
            <param name="node"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Results.Deprecated.CaseResults.Item(Nucleus.Model.LinearElement)">
            <summary>
            Get or set the results table for the specified linear element
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Results.Deprecated.CaseResults.Item(Nucleus.Model.LinearElement,Nucleus.Results.LinearElementResultTypes)">
            <summary>
            Get the result envelope graph for the specified element and result type
            </summary>
            <param name="element"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Results.Deprecated.CaseResults.Item(Nucleus.Model.LinearElement,Nucleus.Results.LinearElementResultTypes,System.Double)">
            <summary>
            Get the maximum and minimum result values for the specified element and result type
            at the specified position along the element
            </summary>
            <param name="element"></param>
            <param name="type"></param>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Results.Deprecated.CaseResults.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialisation constructor
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:Nucleus.Results.Deprecated.CaseResults.#ctor">
            <summary>
            Initialises a new empty CaseResults
            </summary>
        </member>
        <member name="T:Nucleus.Results.Deprecated.IModelObjectResult">
            <summary>
            An interface for objects which store a result for a single object
            for a single result type.  This may be a single value (e.g for nodes)
            </summary>
        </member>
        <member name="T:Nucleus.Results.Deprecated.LinearElementResults">
            <summary>
            Result storage table for elements, keyed by result type
            </summary>
        </member>
        <member name="P:Nucleus.Results.Deprecated.LinearElementResults.Item(Nucleus.Results.LinearElementResultTypes,System.Double)">
            <summary>
            Get the result envelope of the specified type at the specified position
            </summary>
            <param name="type"></param>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Results.Deprecated.ModelObjectResults`2">
            <summary>
            Abstract generic base class for object results dictionaries
            </summary>
            <typeparam name="TResultsType"></typeparam>
            <typeparam name="TResults"></typeparam>
        </member>
        <member name="M:Nucleus.Results.Deprecated.ModelObjectResults`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialisation constructor
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:Nucleus.Results.Deprecated.ModelObjectResults`2.#ctor">
            <summary>
            Initialises a new empty ResultsDictionary
            </summary>
        </member>
        <member name="T:Nucleus.Results.Deprecated.ModelResults">
            <summary>
            Storage dictionary for all the results belonging to a model,
            keyed by the analysis or combination case for which they were generated
            </summary>
        </member>
        <member name="P:Nucleus.Results.Deprecated.ModelResults.Item(Nucleus.Model.ResultsCase,System.Guid)">
            <summary>
            Get the object results for the specified case and item
            </summary>
            <param name="rCase"></param>
            <param name="itemGuid"></param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Results.Deprecated.ModelResults.Item(Nucleus.Model.ResultsCase,Nucleus.Model.ModelObject)">
            <summary>
            Get the object results for the specififed case and item
            </summary>
            <param name="rCase"></param>
            <param name="mObject"></param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Results.Deprecated.ModelResults.Item(Nucleus.Model.ResultsCase,Nucleus.Model.Node)">
            <summary>
            Get the node results table for the specified case and node
            </summary>
            <param name="rCase"></param>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Results.Deprecated.ModelResults.Item(Nucleus.Model.ResultsCase,Nucleus.Model.Node,Nucleus.Results.NodeResultTypes)">
            <summary>
            Get the result value(s) for the specified case, node and result type
            </summary>
            <param name="rCase"></param>
            <param name="node"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Results.Deprecated.ModelResults.Item(Nucleus.Model.ResultsCase,Nucleus.Model.LinearElement)">
            <summary>
            Get the results table for the specified linear element under the specified case
            </summary>
            <param name="rCase"></param>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Results.Deprecated.ModelResults.Item(Nucleus.Model.ResultsCase,Nucleus.Model.LinearElement,Nucleus.Results.LinearElementResultTypes)">
            <summary>
            Get the results interval graph along the specified linear element for the given
            case and result type
            </summary>
            <param name="rCase"></param>
            <param name="element"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Results.Deprecated.ModelResults.Item(Nucleus.Model.ResultsCase,Nucleus.Model.LinearElement,Nucleus.Results.LinearElementResultTypes,System.Double)">
            <summary>
            Get the maximum and minimum result interval for the specified case, linear element, type and position
            along the element.
            </summary>
            <param name="rCase"></param>
            <param name="element"></param>
            <param name="type"></param>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Results.Deprecated.ModelResults.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialisation constructor
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:Nucleus.Results.Deprecated.ModelResults.#ctor">
            <summary>
            Initialises a new empty ModelResults
            </summary>
        </member>
        <member name="T:Nucleus.Results.Deprecated.NodeResults">
            <summary>
            Results storage table for nodes, keyed by result type
            </summary>
        </member>
        <member name="M:Nucleus.Results.Deprecated.NodeResults.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialisation constructor
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:Nucleus.Results.Deprecated.NodeResults.#ctor">
            <summary>
            Initialises a new empty NodeResults dictionary
            </summary>
        </member>
        <member name="T:Nucleus.Results.Deprecated.AnalysisResults`1">
            <summary>
            Abstract base class for results relating to a specific object and stored on
            that object as a data component.  Within this dictionary, results are stored
            by type and then by case.
            </summary>
        </member>
        <member name="T:Nucleus.Results.CaseLinearElementResults">
            <summary>
            Analysis results for a linear element under a specific case
            </summary>
        </member>
        <member name="T:Nucleus.Results.CaseNodeResults">
            <summary>
            Node results for a specific results case, keyed by type
            </summary>
        </member>
        <member name="M:Nucleus.Results.CaseNodeResults.GetMaxDisplacementVector">
            <summary>
            Get the maximum nodal displacement vector from this set of results
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Results.CaseResults`2">
            <summary>
            Abstract base class for dictionaries of results for a particular
            case, keyed by result type
            </summary>
        </member>
        <member name="T:Nucleus.Results.ICaseResults">
            <summary>
            Interface for results dictionaries which store the results for a particular
            results case
            </summary>
        </member>
        <member name="T:Nucleus.Results.IModelObjectResults">
            <summary>
            Interface for dictionaries of results for a particular model object
            </summary>
        </member>
        <member name="M:Nucleus.Results.IModelObjectResults.Get(Nucleus.Model.ResultsCase)">
            <summary>
            Get the results for the specified case
            </summary>
            <param name="rCase"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Results.IModelObjectResults.Remove(Nucleus.Model.ResultsCase)">
            <summary>
            Remove any stored results for the specified case
            </summary>
            <param name="rCase"></param>
        </member>
        <member name="T:Nucleus.Results.LinearElementResults">
            <summary>
            Results dictionary for a specific linear element
            </summary>
        </member>
        <member name="T:Nucleus.Results.LinearElementResultTypes">
            <summary>
            Enum of standard linear element analysis result types
            </summary>
        </member>
        <member name="T:Nucleus.Results.ModelObjectResults`1">
            <summary>
            An abstract base class for dictionaries of results for an individual model object,
            keyed by results case and then by type
            </summary>
        </member>
        <member name="T:Nucleus.Results.ModelResults">
            <summary>
            A top-level storage mechanism for all analysis results for a particular
            model, keyed by object, then by case, then by type
            </summary>
        </member>
        <member name="P:Nucleus.Results.ModelResults.Item(Nucleus.Model.Node)">
            <summary>
            Get or set the stored results for the specified node.
            Will return null if no stored results are found or if they
            are not in the correct format.
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Results.ModelResults.Item(Nucleus.Model.Node,Nucleus.Model.ResultsCase)">
            <summary>
            Get the stored results (if any) for the specified node and
            case.
            </summary>
            <param name="node"></param>
            <param name="rCase"></param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Results.ModelResults.Item(Nucleus.Model.Node,Nucleus.Model.ResultsCase,Nucleus.Results.NodeResultTypes)">
            <summary>
            Get the stored result (if any) of the specified type for
            the specified node and case.
            </summary>
            <param name="node"></param>
            <param name="rCase"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Results.ModelResults.Item(Nucleus.Model.LinearElement)">
            <summary>
            Get or set the stored results for the specified linear element.
            Will return null if no stored results are found for this
            element of if they are not in the correct format.
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Results.ModelResults.Item(Nucleus.Model.LinearElement,Nucleus.Model.ResultsCase)">
            <summary>
            Get the stored results (if any) for the specified linear
            element and case.
            </summary>
            <param name="element"></param>
            <param name="rCase"></param>
            <returns></returns>
        </member>
        <member name="P:Nucleus.Results.ModelResults.Item(Nucleus.Model.LinearElement,Nucleus.Model.ResultsCase,Nucleus.Results.LinearElementResultTypes)">
            <summary>
            Get the stored results (if any) of the specified type for the
            specified linear element and case.
            </summary>
            <param name="element"></param>
            <param name="rCase"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Results.ModelResults.Add(Nucleus.Model.Node,Nucleus.Results.NodeResults)">
            <summary>
            Adds the results for the specified node to the store.
            </summary>
            <param name="node"></param>
            <param name="results"></param>
        </member>
        <member name="M:Nucleus.Results.ModelResults.Add(Nucleus.Model.LinearElement,Nucleus.Results.LinearElementResults)">
            <summary>
            Adds the results for the specified linear element to the store.
            </summary>
            <param name="element"></param>
            <param name="results"></param>
        </member>
        <member name="M:Nucleus.Results.ModelResults.ClearCaseResults(Nucleus.Model.ResultsCase)">
            <summary>
            Remove from this store any results belonging to the specfied case.
            </summary>
            <param name="rCase"></param>
        </member>
        <member name="M:Nucleus.Results.ModelResults.DeformedGeometry(Nucleus.Model.LinearElement,Nucleus.Model.ResultsCase)">
            <summary>
            Calculate the deformed centreline geometry of a linear element
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Results.NodeResults">
            <summary>
            Results dictionary for a specific node, keyed by case and then by type
            </summary>
        </member>
        <member name="T:Nucleus.Results.NodeResultTypes">
            <summary>
            Enum of standard node analysis result types.
            </summary>
            <remarks>The enumerated values follow a specific convention
            for result types composed of several different components.
            The overall magnitude value is given a value divisible by
            10, with the components then following.</remarks>
        </member>
        <member name="F:Nucleus.Results.NodeResultTypes.Displacement">
            <summary>
            The nodal displacement magnitude
            </summary>
        </member>
        <member name="F:Nucleus.Results.NodeResultTypes.Displacement_X">
            <summary>
            The X-component of the nodal displacement
            </summary>
        </member>
        <member name="F:Nucleus.Results.NodeResultTypes.Displacement_Y">
            <summary>
            The Y-component of the nodal displacement
            </summary>
        </member>
        <member name="F:Nucleus.Results.NodeResultTypes.Displacement_Z">
            <summary>
            The Z-component of the nodal displacement
            </summary>
        </member>
        <member name="F:Nucleus.Results.NodeResultTypes.Rotation">
            <summary>
            The nodal rotation magnitude
            </summary>
        </member>
        <member name="F:Nucleus.Results.NodeResultTypes.Rotation_XX">
            <summary>
            The component of rotation about the X axis
            </summary>
        </member>
        <member name="F:Nucleus.Results.NodeResultTypes.Rotation_YY">
            <summary>
            The component of rotation about the Y axis
            </summary>
        </member>
        <member name="F:Nucleus.Results.NodeResultTypes.Rotation_ZZ">
            <summary>
            The component of rotation about the Z axis
            </summary>
        </member>
        <member name="F:Nucleus.Results.NodeResultTypes.Force">
            <summary>
            The magnitude of reaction forces on the node.
            </summary>
        </member>
        <member name="F:Nucleus.Results.NodeResultTypes.Force_X">
            <summary>
            The reaction force component acting in the X-direction
            </summary>
        </member>
        <member name="F:Nucleus.Results.NodeResultTypes.Force_Y">
            <summary>
            The reaction force component acting in the Y-direction
            </summary>
        </member>
        <member name="F:Nucleus.Results.NodeResultTypes.Force_Z">
            <summary>
            The reaction force componen acting in the Z-direction
            </summary>
        </member>
        <member name="F:Nucleus.Results.NodeResultTypes.Moments">
            <summary>
            The combined reaction moments on the node.
            </summary>
        </member>
        <member name="F:Nucleus.Results.NodeResultTypes.Moments_XX">
            <summary>
            The reaction moments acting about the X-axis.
            </summary>
        </member>
        <member name="F:Nucleus.Results.NodeResultTypes.Moments_YY">
            <summary>
            The reaction moments acting about the Y-axis.
            </summary>
        </member>
        <member name="F:Nucleus.Results.NodeResultTypes.Moments_ZZ">
            <summary>
            The reaction moments acting about the Z-axis.
            </summary>
        </member>
        <member name="T:Nucleus.Results.NodeResultTypesExtensions">
            <summary>
            Extension methods for the NodeResultTypes enum
            </summary>
        </member>
        <member name="T:Nucleus.Results.ResultsDictionary`2">
            <summary>
            Abstract base class for dictionaries that store analysis results,
            either directly or within further sub-dictionaries.
            </summary>
        </member>
        <member name="P:Nucleus.Results.ResultsDictionary`2.Item(`0)">
            <summary>
            Indexer - hides the underlying dictionary implementation
            in order to return the default of the value type when no record matching the
            key is stored.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Results.ResultsDictionary`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialisation constructor
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:Nucleus.Results.ResultsDictionary`2.#ctor">
            <summary>
            Initialises a new empty ResultsDictionary
            </summary>
        </member>
        <member name="M:Nucleus.Results.ResultsDictionary`2.SafeGet(`0)">
            <summary>
            Returns either the value corresponding to the given key, if the key exists within the dictionary
            or the value type default value if it does not.  Essentially wraps TryGetValue in a form which can be used
            on a single line.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.UI.AutoUIAttribute">
            <summary>
            Attribute for automatic UI generation.  Add this attribute to properties
            for which you wish to have UI controls generated automatically.
            </summary>
        </member>
        <member name="P:Nucleus.UI.AutoUIAttribute.Order">
            <summary>
            The order weighting for this property.  Those with a lower order
            weighting will be displayed first.
            </summary>
        </member>
        <member name="P:Nucleus.UI.AutoUIAttribute.Label">
            <summary>
            The text that the field should be labelled with.  If not set,
            the property name itself will be used.
            </summary>
        </member>
        <member name="P:Nucleus.UI.AutoUIAttribute.SubProperty">
            <summary>
            The sub-property on this field that should be used as a proxy for
            this value.
            </summary>
        </member>
        <member name="P:Nucleus.UI.AutoUIAttribute.LabelBinding">
            <summary>
            The name of the string property on the same object which governs the
            label test of the generated UI control.  If this property is null or invalid
            then the label will use the Label property of this attribute or failing that
            the name of the property itself.
            </summary>
        </member>
        <member name="P:Nucleus.UI.AutoUIAttribute.VisibilityBinding">
            <summary>
            The name of the boolean property on the same object which governs
            the visibility of the generated UI control.  This property must return
            true when the control should be visible and false when it should be
            collapsed.  If this is omitted then the control will always be visible.
            </summary>
        </member>
        <member name="P:Nucleus.UI.AutoUIAttribute.ToolTip">
            <summary>
            The tooltip to be displayed when the mouse is over the generated UI control.
            </summary>
        </member>
        <member name="M:Nucleus.UI.AutoUIAttribute.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.UI.AutoUIAttribute.#ctor(System.Double)">
            <summary>
            Order constructor
            </summary>
            <param name="order"></param>
        </member>
        <member name="T:Nucleus.UI.AutoUIComboBoxAttribute">
            <summary>
            Attribute for automatic UI generation.  Add this attribute to properties
            for which you wish to have UI controls generated automatically.
            Properties tagged with this attribute will be represented by a ComboBox.
            </summary>
        </member>
        <member name="P:Nucleus.UI.AutoUIComboBoxAttribute.ItemsSource">
            <summary>
            The path of the property to use for the items source of the combobox
            </summary>
        </member>
        <member name="P:Nucleus.UI.AutoUIComboBoxAttribute.ExtraItemsSource">
            <summary>
            The path of the property to use for additional 'special' items to be included
            in the 
            </summary>
        </member>
        <member name="M:Nucleus.UI.AutoUIComboBoxAttribute.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Nucleus.UI.AutoUIComboBoxAttribute.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="itemsSource"></param>
        </member>
        <member name="M:Nucleus.UI.AutoUIComboBoxAttribute.#ctor(System.Double,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="itemsSource"></param>
        </member>
        <member name="P:Nucleus.UI.AutoUISliderAttribute.Min">
            <summary>
            The slider minimum value
            </summary>
        </member>
        <member name="P:Nucleus.UI.AutoUISliderAttribute.Max">
            <summary>
            The slider maximum value
            </summary>
        </member>
        <member name="M:Nucleus.UI.AutoUISliderAttribute.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.UI.AutoUISliderAttribute.#ctor(System.Double)">
            <summary>
            Order constructor
            </summary>
            <param name="order"></param>
        </member>
        <member name="T:Nucleus.UI.DataBinding">
            <summary>
            Class which implements basic functionality to support 
            property binding behaviour.
            </summary>
        </member>
        <member name="F:Nucleus.UI.DataBinding._DataContext">
            <summary>
            Private backing field for DataContext property
            </summary>
        </member>
        <member name="P:Nucleus.UI.DataBinding.DataContext">
            <summary>
            Get or set the datacontext of the binding.
            </summary>
        </member>
        <member name="F:Nucleus.UI.DataBinding._Path">
            <summary>
            Private backing member variable for the Path property
            </summary>
        </member>
        <member name="P:Nucleus.UI.DataBinding.Path">
            <summary>
            Get or set the path to the binding source property
            </summary>
        </member>
        <member name="F:Nucleus.UI.DataBinding._StringFormat">
            <summary>
            Private backing member variable for the StringFormat property
            </summary>
        </member>
        <member name="P:Nucleus.UI.DataBinding.StringFormat">
            <summary>
            Gets or sets a string that specifies how to format the bound value
            when retrieving it via the GetBoundValueString() method.
            </summary>
        </member>
        <member name="F:Nucleus.UI.DataBinding._UIRefreshRequired">
            <summary>
            Is a refresh of the UI necessary?
            If true, this should be performed on the next Update()
            </summary>
        </member>
        <member name="P:Nucleus.UI.DataBinding.UIRefreshRequired">
            <summary>
            Get or set whether a refresh of the UI should be performed
            on the next update.
            </summary>
        </member>
        <member name="F:Nucleus.UI.DataBinding._BindingRefreshIndex">
            <summary>
            Private backing field for BindingRefreshRequired
            </summary>
        </member>
        <member name="P:Nucleus.UI.DataBinding.BindingRefreshIndex">
            <summary>
            Get or set an integer value indicating whether the
            binding chain should be refreshed and if so from
            which position.  This is indicated by setting the value
            to the index of the item in the chain which should be
            refreshed.  If the value is lower than 0, no refresh is
            required.
            </summary>
        </member>
        <member name="P:Nucleus.UI.DataBinding.BindingRefreshRequired">
            <summary>
            Get or set whether a Binding refresh is required
            </summary>
        </member>
        <member name="F:Nucleus.UI.DataBinding._BindingChain">
            <summary>
            Private backing member variable for the BindingChain property
            </summary>
        </member>
        <member name="P:Nucleus.UI.DataBinding.BindingChain">
            <summary>
            The binding chain - the sequence of objects and properties that lead 
            from the data context to the target of the binding.
            </summary>
        </member>
        <member name="M:Nucleus.UI.DataBinding.GetBoundValue">
            <summary>
            Get the current value of the bound property
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.UI.DataBinding.GetBoundValueString">
            <summary>
            Get the current value of the bound property expressed
            as a string utilising the specififed StringFormat property
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.UI.DataBinding.SetBoundValue(System.Object)">
            <summary>
            Set the current value of the bound property
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.UI.DataBinding.RefreshBinding">
            <summary>
            Rebuild the binding chain to establish property change monitoring
            </summary>
        </member>
        <member name="M:Nucleus.UI.DataBinding.Source_PropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)">
            <summary>
            Handles propertychanged events on bound source objects
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Nucleus.UI.BindingChainLink">
            <summary>
            An entry in a binding chain.  This is used
            in binding operations to keep track of
            the chain of objects which must be traversed
            to reach the target.
            </summary>
        </member>
        <member name="P:Nucleus.UI.BindingChainLink.Source">
            <summary>
            The source object to watch for property changes
            </summary>
        </member>
        <member name="P:Nucleus.UI.BindingChainLink.PropertyName">
            <summary>
            The name of the property on the source object that
            is to be watched for changes.
            </summary>
        </member>
        <member name="M:Nucleus.UI.BindingChainLink.#ctor(System.ComponentModel.INotifyPropertyChanged,System.String)">
            <summary>
            Creates a new BindingChainEntry
            </summary>
            <param name="source"></param>
            <param name="propertyName"></param>
        </member>
        <member name="T:Nucleus.UI.BindingChainLinkExtensions">
            <summary>
            Extension methods for the BindingChainLink class and collections thereof
            </summary>
        </member>
        <member name="M:Nucleus.UI.BindingChainLinkExtensions.AddPropertyChangedHandler(System.Collections.Generic.IList{Nucleus.UI.BindingChainLink},System.ComponentModel.PropertyChangedEventHandler)">
            <summary>
            Subscribe a handler function to the PropertyChanged event of all the source
            objects in this chain
            </summary>
            <param name="chain"></param>
            <param name="handler"></param>
        </member>
        <member name="M:Nucleus.UI.BindingChainLinkExtensions.RemovePropertyChangedHandler(System.Collections.Generic.IList{Nucleus.UI.BindingChainLink},System.ComponentModel.PropertyChangedEventHandler)">
            <summary>
            Unsubscribe a handler function from the PropertyChanged event of all the source
            objects in this chain
            </summary>
            <param name="chain"></param>
            <param name="handler"></param>
        </member>
        <member name="M:Nucleus.UI.BindingChainLinkExtensions.IndexOfSource(System.Collections.Generic.IList{Nucleus.UI.BindingChainLink},System.ComponentModel.INotifyPropertyChanged)">
            <summary>
            Find the index of the item in this list with the specified source
            </summary>
            <param name="chain"></param>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.UI.IAutoUIHostable">
            <summary>
            Interface to mark objects which can be hosted within an AutoUI panel for modification
            </summary>
        </member>
        <member name="T:Nucleus.UI.ItemsSourceBinding">
            <summary>
            A specialised form of DataBinding which permits binding
            to an observable collection
            </summary>
        </member>
        <member name="F:Nucleus.UI.ItemsSourceBinding._Collection">
            <summary>
            Cached reference to the latest bound collection
            </summary>
        </member>
        <member name="P:Nucleus.UI.ItemsSourceBinding.AddedItems">
            <summary>
            Items which have been recently added.
            Null if all added items have been processed.
            </summary>
        </member>
        <member name="P:Nucleus.UI.ItemsSourceBinding.RemovedItems">
            <summary>
            Items which have been recently removed.
            Null if all removed items have been processed.
            </summary>
        </member>
        <member name="P:Nucleus.UI.ItemsSourceBinding.ItemsRefreshRequired">
            <summary>
            Get a boolean value indicating whether it is necessary to refresh
            items generated as a result of this binding
            </summary>
        </member>
        <member name="M:Nucleus.UI.ItemsSourceBinding.RefreshBinding">
            <summary>
            Rebuild the binding chain to establish property change monitoring,
            additionally setting up collection change event listening on the
            source object (if it is a collection)
            </summary>
        </member>
        <member name="T:Nucleus.UI.IUserInteraction`1">
            <summary>
            Interface for objects which represent assignable user interactions
            </summary>
        </member>
        <member name="M:Nucleus.UI.IUserInteraction`1.Execute(System.Object,`0)">
            <summary>
            Execute this interaction
            </summary>
            <param name="sender">The object raising this interaction</param>
            <param name="parameters">The interaction parameters</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.UI.SelectionViewModel">
            <summary>
            Abstract base class for ViewModel wrapper classes representing selections of unique objects
            </summary>
        </member>
        <member name="M:Nucleus.UI.SelectionViewModel.Add(System.Object)">
            <summary>
            Add an item to this selection, checking first whether it is of the appropriate type
            </summary>
            <param name="item">The item to be added</param>
        </member>
        <member name="M:Nucleus.UI.SelectionViewModel.Remove(System.Object)">
            <summary>
            Remove an item from this selection, checking first whether it is of the appropriate type
            </summary>
            <param name="item">The item to be removed</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.UI.SelectionViewModel.Clear">
            <summary>
            Clear the current selection
            </summary>
        </member>
        <member name="M:Nucleus.UI.SelectionViewModel.GetCollection">
            <summary>
            Get the Selection collection belonging to this viewmodel
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.UI.SelectionViewModel`2">
            <summary>
            Abstract generic base class for ViewModel wrapper classes representing selections of unique objects
            </summary>
            <typeparam name="TCollection"></typeparam>
            <typeparam name="TUnique"></typeparam>
        </member>
        <member name="P:Nucleus.UI.SelectionViewModel`2.Selection">
            <summary>
            The collection of selected objects
            </summary>
        </member>
        <member name="M:Nucleus.UI.SelectionViewModel`2.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Nucleus.UI.SelectionViewModel`2.Add(`1)">
            <summary>
            Add a new item to the selection
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Nucleus.UI.SelectionViewModel`2.Add(System.Object)">
            <summary>
            Add a new item to the selection, checking first whether it is of the appropriate type
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.UI.SelectionViewModel`2.Remove(`1)">
            <summary>
            Remove an item from the selection
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Nucleus.UI.SelectionViewModel`2.Remove(System.Object)">
            <summary>
            Remove an item from the selection, checking first whether it is of the appropriate type
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Nucleus.UI.SelectionViewModel`2.Set(`1)">
            <summary>
            Set the selection to the specified object
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Nucleus.UI.SelectionViewModel`2.Contains(`1)">
            <summary>
            Does the selection contain the specified item?
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.UI.SelectionViewModel`2.Clear">
            <summary>
            Clear the selection
            </summary>
        </member>
        <member name="M:Nucleus.UI.SelectionViewModel`2.CombinedValue``1(System.Func{`1,``0},``0,``0)">
            <summary>
            Retrieve the combined value of the property specified in the lambda function
            </summary>
            <param name="propertyDelegate">A lambda function that returns a particular property for each item in the selection</param>
            <param name="multiValue">The return value that indicates multiple inconsistent values</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.UI.SelectionViewModel`2.CombinedValue(System.Func{`1,System.Object})">
            <summary>
            Retrieve the combined value of the property specified in the lambda function
            </summary>
            <param name="propertyDelegate">A lambda function that returns a particular property for each item in the selection</param>
            <returns></returns>
        </member>
        <member name="F:Nucleus.UI.SelectionViewModel`2._SelectionUpdateTimer">
            <summary>
            Timer for deferred selection update notification
            </summary>
        </member>
        <member name="T:Nucleus.UI.UIOption">
            <summary>
            Class representing an option to be displayed within a user interface
            </summary>
        </member>
        <member name="P:Nucleus.UI.UIOption.OK">
            <summary>
            Default 'OK' option - returns true if selected
            </summary>
        </member>
        <member name="P:Nucleus.UI.UIOption.Cancel">
            <summary>
            Default 'Cancel' option - returns false if selected
            </summary>
        </member>
        <member name="F:Nucleus.UI.UIOption.Text">
            <summary>
            The text to be displayed to describe this option
            </summary>
        </member>
        <member name="F:Nucleus.UI.UIOption.ReturnValue">
            <summary>
            The value to be returned when this option is selected
            </summary>
        </member>
        <member name="M:Nucleus.UI.UIOption.#ctor(System.String,System.Object)">
            <summary>
            Initialise a new UIOption with the specified text and return value
            </summary>
            <param name="text"></param>
            <param name="returnValue"></param>
        </member>
        <member name="M:Nucleus.UI.UIOption.#ctor(System.String)">
            <summary>
            Initialise a new UIOption with the specified text.
            This object will be its own return value.
            </summary>
            <param name="text"></param>
        </member>
        <member name="T:Nucleus.Undo.CollectionUndoState">
            <summary>
            An undo state which can be used to revert a collection change
            </summary>
        </member>
        <member name="P:Nucleus.Undo.CollectionUndoState.Target">
            <summary>
            The object whose property state is being stored
            </summary>
        </member>
        <member name="P:Nucleus.Undo.CollectionUndoState.Args">
            <summary>
            The collection changed event arguments
            </summary>
        </member>
        <member name="T:Nucleus.Undo.PropertyUndoState">
            <summary>
            An undo state which can be used to revert a property value change
            </summary>
        </member>
        <member name="P:Nucleus.Undo.PropertyUndoState.Target">
            <summary>
            The object whose property state is being stored
            </summary>
        </member>
        <member name="P:Nucleus.Undo.PropertyUndoState.PropertyName">
            <summary>
            The name of the property the state of which is being stored
            </summary>
        </member>
        <member name="P:Nucleus.Undo.PropertyUndoState.PropertyValue">
            <summary>
            The value of the property to be stored
            </summary>
        </member>
        <member name="M:Nucleus.Undo.PropertyUndoState.#ctor(System.Object,System.String,System.Object)">
            <summary>
            Create a new undo state
            </summary>
            <param name="target"></param>
            <param name="propertyName"></param>
            <param name="propertyValue"></param>
        </member>
        <member name="M:Nucleus.Undo.PropertyUndoState.#ctor(System.Object,System.String)">
            <summary>
            Create a new undo state, automatically extracting the current value of the property
            </summary>
            <param name="target"></param>
            <param name="propertyName"></param>
        </member>
        <member name="M:Nucleus.Undo.PropertyUndoState.#ctor(System.Object,Nucleus.Events.PropertyChangedEventArgsExtended)">
            <summary>
            Create a new undo state based on an extended property changed event
            </summary>
            <param name="target"></param>
            <param name="args"></param>
        </member>
        <member name="M:Nucleus.Undo.PropertyUndoState.SetValue">
            <summary>
            Set the PropertyValue property by extracting it via reflection based on the current
            Target and PropertyName
            </summary>
        </member>
        <member name="T:Nucleus.Undo.TransformUndoState">
            <summary>
            An undo state which will reverse a transformation performed on
            a geometric object
            </summary>
        </member>
        <member name="T:Nucleus.Undo.UndoManager">
            <summary>
            Class for general undo/redo management
            </summary>
        </member>
        <member name="F:Nucleus.Undo.UndoManager._MaxStackSize">
            <summary>
            Private backing field for the MaxStackSize property
            </summary>
        </member>
        <member name="P:Nucleus.Undo.UndoManager.MaxStackSize">
            <summary>
            The maximum allowable size of the undo/redo stacks
            </summary>
        </member>
        <member name="F:Nucleus.Undo.UndoManager._Active">
            <summary>
            Private backing field for Active property
            </summary>
        </member>
        <member name="P:Nucleus.Undo.UndoManager.Active">
            <summary>
            Gets or sets whether the undo manager is active.
            If false, undo states will not be stored.
            </summary>
        </member>
        <member name="F:Nucleus.Undo.UndoManager._UndoStack">
            <summary>
            Private backing field for the UndoStack property
            </summary>
        </member>
        <member name="P:Nucleus.Undo.UndoManager.UndoStack">
            <summary>
            The stack of undo operations
            </summary>
        </member>
        <member name="F:Nucleus.Undo.UndoManager._RedoStack">
            <summary>
            Private backing field for the RedoStack property
            </summary>
        </member>
        <member name="P:Nucleus.Undo.UndoManager.RedoStack">
            <summary>
            The stack of Redo operations
            </summary>
        </member>
        <member name="F:Nucleus.Undo.UndoManager._ActiveStage">
            <summary>
            Private backing field for the ActiveStage property
            </summary>
        </member>
        <member name="P:Nucleus.Undo.UndoManager.ActiveStage">
            <summary>
            The currently active undo stage.
            New undo states will be added to this stage.
            </summary>
        </member>
        <member name="F:Nucleus.Undo.UndoManager._Locked">
            <summary>
            Private backing field for Locked property
            </summary>
        </member>
        <member name="P:Nucleus.Undo.UndoManager.Locked">
            <summary>
            Lock flag.  When locked, new states may not be added to the stack.
            This is automatically engaged when undoing a stage so as to avoid the undo
            operation itself being recorded.
            </summary>
        </member>
        <member name="M:Nucleus.Undo.UndoManager.AddUndoState(Nucleus.Undo.UndoState,System.Boolean)">
            <summary>
            Add an undo state to the current stage (if one is active) or directly 
            to the stack as a new stage (if one isn't). 
            </summary>
            <param name="state"></param>
            <param name="clearRedo">If true, the redo stack will be invalidated</param>
        </member>
        <member name="M:Nucleus.Undo.UndoManager.AddUndoStage(Nucleus.Undo.UndoStage,System.Boolean)">
            <summary>
            Add a new stage to the undo stack
            </summary>
            <param name="stage"></param>
        </member>
        <member name="M:Nucleus.Undo.UndoManager.LimitUndoStackSize">
            <summary>
            Reduce the size of the Undo stack to the specified maximum
            </summary>
        </member>
        <member name="M:Nucleus.Undo.UndoManager.AddRedoStage(Nucleus.Undo.UndoStage)">
            <summary>
            Add a new stage to the redo stack
            </summary>
            <param name="stage"></param>
        </member>
        <member name="M:Nucleus.Undo.UndoManager.LimitRedoStackSize">
            <summary>
            Reduce the size of the Undo stack to the specified maximum
            </summary>
        </member>
        <member name="M:Nucleus.Undo.UndoManager.BeginStage">
            <summary>
            Begin a new undo stage.
            Until EndStage() is called, all undo states added will be combined together into a single MultiUndoState.
            </summary>
            <returns>The new MultiUndoState that represents the current stage</returns>
        </member>
        <member name="M:Nucleus.Undo.UndoManager.EndStage">
            <summary>
            End the currently active undo stage, committing it to the stack
            </summary>
        </member>
        <member name="M:Nucleus.Undo.UndoManager.Undo">
            <summary>
            Undo the last undoable action
            </summary>
        </member>
        <member name="M:Nucleus.Undo.UndoManager.Redo">
            <summary>
            Redo the last redoable action
            </summary>
        </member>
        <member name="M:Nucleus.Undo.UndoManager.ClearUndoStack">
            <summary>
            Empty both the undo and redo stack
            </summary>
        </member>
        <member name="M:Nucleus.Undo.UndoManager.WatchCollection(System.Collections.Specialized.INotifyCollectionChanged)">
            <summary>
            Register the specified collection to be watched by this manager for undoable operations.
            Raised CollectionChanged events will result in a new undostate being automatically created
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Nucleus.Undo.UndoManager.WatchAll(System.Collections.IList)">
            <summary>
            Register the specified collection and all objects in it to be watched by this manager
            for undoable operations.
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Nucleus.Undo.UndoManager.WatchAll(System.Object)">
            <summary>
            Register the specified object and, if it is a collection, any items contained within it
            to be watched for undoable operations.  Raised CollectionChanged events and 
            PropertyChanged events that use the PropertyChangedEventArgsExtended type
            for arguments will result in a new UndoState being automatically created.
            Any new items added to a watched collection will themselves be automatically watched.
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:Nucleus.Undo.UndoManager.WatchProperties(System.ComponentModel.INotifyPropertyChanged)">
            <summary>
            Register the specified object to be watched by this manager for undoable operations.
            Raised PropertyChanged events that use the PropertyChangedEventArgsExtended type
            for arguments will result in a new UndoState being automatically created
            </summary>
            <param name="obj"></param>
        </member>
        <member name="T:Nucleus.Undo.UndoStage">
            <summary>
            An undo stage.  A collection of recorded states resulting
            from an undoable operation and which will all be reverted
            at once.
            </summary>
        </member>
        <member name="M:Nucleus.Undo.UndoStage.Undo">
            <summary>
            Revert this stage by restoring the states stored
            within this collection
            </summary>
            <returns>The redo stage necessary to redo this undo.</returns>
        </member>
        <member name="T:Nucleus.Undo.UndoState">
            <summary>
            Represents a particular state which can be returned to through an undo operation
            </summary>
        </member>
        <member name="P:Nucleus.Undo.UndoState.IsValid">
            <summary>
            Is this state valid?  i.e. does it represent a restorable state?
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Undo.UndoState.Restore">
            <summary>
            Restore this state
            </summary>
        </member>
        <member name="M:Nucleus.Undo.UndoState.GenerateRedo">
            <summary>
            Generate the redo operation that would undo this undo
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Undo.UndoStageCollection">
            <summary>
            A collection of undo states
            </summary>
        </member>
        <member name="T:Nucleus.Units.DimensionAttribute">
            <summary>
            Attribute to be applied to properties in order to specify the dimensions
            of the quantities they represent.
            </summary>
        </member>
        <member name="P:Nucleus.Units.DimensionAttribute.Type">
            <summary>
            The type of dimension of the annotated property
            </summary>
        </member>
        <member name="M:Nucleus.Units.DimensionAttribute.#ctor(Nucleus.Units.DimensionType)">
            <summary>
            Constructor
            </summary>
            <param name="type"></param>
        </member>
        <member name="T:Nucleus.Units.DimensionType">
            <summary>
            Enum to represent different physical dimensions
            </summary>
        </member>
        <member name="F:Nucleus.Units.DimensionType.Dimensionless">
            <summary>
            A quantity to which no physical dimension is applicable.
            </summary>
        </member>
        <member name="F:Nucleus.Units.DimensionType.Distance">
            <summary>
            A distance, or length, measurement.
            Default unit: m
            </summary>
        </member>
        <member name="F:Nucleus.Units.DimensionType.Angle">
            <summary>
            An angle or rotation measurement.
            Default unit: Radians
            </summary>
        </member>
        <member name="F:Nucleus.Units.DimensionType.Force">
            <summary>
            A measurement of force.
            Default unit: N
            </summary>
        </member>
        <member name="F:Nucleus.Units.DimensionType.Moments">
            <summary>
            A measurement of moments
            Default unit: Nm
            </summary>
        </member>
        <member name="T:Nucleus.Units.MeasurementUnit">
            <summary>
            Class which may be used to represent a unit of measurement
            </summary>
        </member>
        <member name="F:Nucleus.Units.MeasurementUnit.Percent">
            <summary>
            Percent, a number or ratio expressed as a fraction of 100
            </summary>
        </member>
        <member name="F:Nucleus.Units.MeasurementUnit.Meters">
            <summary>
            Meters, the SI unit of measurement for length
            </summary>
        </member>
        <member name="F:Nucleus.Units.MeasurementUnit.MetersSquared">
            <summary>
            Meters squared, the SI unit of measurement for area
            </summary>
        </member>
        <member name="F:Nucleus.Units.MeasurementUnit.MetersCubed">
            <summary>
            Meters cubed, the SI unit of measurement for volume
            </summary>
        </member>
        <member name="F:Nucleus.Units.MeasurementUnit.Radians">
            <summary>
            Radians, the SI unit of angle measurement
            </summary>
        </member>
        <member name="F:Nucleus.Units.MeasurementUnit.Degrees">
            <summary>
            Degrees, an angle measurement
            </summary>
        </member>
        <member name="F:Nucleus.Units.MeasurementUnit.Newtons">
            <summary>
            Newtons, the SI unit of force measurement
            </summary>
        </member>
        <member name="F:Nucleus.Units.MeasurementUnit.Kilograms">
            <summary>
            Kilograms, the SI unit of measurement for mass
            </summary>
        </member>
        <member name="F:Nucleus.Units.MeasurementUnit.Celsius">
            <summary>
            Celsius, the SI unit of measurement for temperature
            </summary>
        </member>
        <member name="F:Nucleus.Units.MeasurementUnit._Name">
            <summary>
            Private backing field for the Name property
            </summary>
        </member>
        <member name="P:Nucleus.Units.MeasurementUnit.Name">
            <summary>
            Get the name of this unit of measurement
            </summary>
        </member>
        <member name="F:Nucleus.Units.MeasurementUnit._Symbol">
            <summary>
            Private backing field for the 
            </summary>
        </member>
        <member name="P:Nucleus.Units.MeasurementUnit.Symbol">
            <summary>
            Get the symbol used to display this unit
            </summary>
        </member>
        <member name="F:Nucleus.Units.MeasurementUnit._SIFactor">
            <summary>
            Private backing field for SIFactor property
            </summary>
        </member>
        <member name="P:Nucleus.Units.MeasurementUnit.SIFactor">
            <summary>
            The number of SI equivalent units this unit is
            equivalent to.  Multiply a value in these units
            by this factor to get the SI equivalent value.
            </summary>
        </member>
        <member name="M:Nucleus.Units.MeasurementUnit.#ctor(System.String,System.String,System.Double)">
            <summary>
            Creates a new unit of measurement
            </summary>
            <param name="name">The name of the unit.  This should be in plural form
            and without capitalisation, save in cases where the capitalisation should
            always be applied.</param>
            <param name="symbol">The symbol of the unit</param>
            <param name="siFactor">The multiple of SI units to which this unit is equivalent</param>
        </member>
    </members>
</doc>
